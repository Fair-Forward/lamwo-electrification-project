(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('rdk'), require('ellipsize'), require('d3-array'), require('calculate-size'), require('d3-scale'), require('memoize-bind'), require('transformation-matrix'), require('classnames'), require('react-cool-dimensions'), require('big-integer'), require('human-format'), require('d3-shape'), require('chroma-js'), require('realayers'), require('memoize-one'), require('react-fast-compare'), require('framer-motion'), require('d3-interpolate'), require('d3-geo'), require('d3-sankey'), require('react-countup'), require('@upsetjs/venn.js'), require('d3-hierarchy')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'rdk', 'ellipsize', 'd3-array', 'calculate-size', 'd3-scale', 'memoize-bind', 'transformation-matrix', 'classnames', 'react-cool-dimensions', 'big-integer', 'human-format', 'd3-shape', 'chroma-js', 'realayers', 'memoize-one', 'react-fast-compare', 'framer-motion', 'd3-interpolate', 'd3-geo', 'd3-sankey', 'react-countup', '@upsetjs/venn.js', 'd3-hierarchy'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.reaviz = {}, global.React, global.rdk, global.ellipsize, global.d3Array, global.calculateSize, global.d3Scale, global.bind, global.transformationMatrix, global.classNames, global.useDimensions, global.bigInt, global.humanFormat, global.d3Shape, global.chroma, global.realayers, global.memoize, global.isEqual, global.framerMotion, global.d3Interpolate, global.d3Geo, global.d3Sankey, global.CountUp, global.venn_js, global.d3Hierarchy));
}(this, (function (exports, React, rdk, ellipsize, d3Array, calculateSize, d3Scale, bind, transformationMatrix, classNames, useDimensions, bigInt, humanFormat, d3Shape, chroma, realayers, memoize, isEqual, framerMotion, d3Interpolate, d3Geo, d3Sankey, CountUp, venn_js, d3Hierarchy) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var ellipsize__default = /*#__PURE__*/_interopDefaultLegacy(ellipsize);
  var calculateSize__default = /*#__PURE__*/_interopDefaultLegacy(calculateSize);
  var bind__default = /*#__PURE__*/_interopDefaultLegacy(bind);
  var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);
  var useDimensions__default = /*#__PURE__*/_interopDefaultLegacy(useDimensions);
  var bigInt__default = /*#__PURE__*/_interopDefaultLegacy(bigInt);
  var humanFormat__default = /*#__PURE__*/_interopDefaultLegacy(humanFormat);
  var chroma__default = /*#__PURE__*/_interopDefaultLegacy(chroma);
  var memoize__default = /*#__PURE__*/_interopDefaultLegacy(memoize);
  var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);
  var CountUp__default = /*#__PURE__*/_interopDefaultLegacy(CountUp);

  class LinearAxisTickLabel extends React.Component {
      getAlign() {
          const { align, half } = this.props;
          if ((align === 'inside' || align === 'outside') && half === 'center') {
              return 'center';
          }
          if (align === 'inside') {
              return half === 'start' ? 'end' : 'start';
          }
          if (align === 'outside') {
              return half === 'start' ? 'start' : 'end';
          }
          return align;
      }
      getTickLineSpacing() {
          const { line } = this.props;
          if (!line) {
              return [0, 0];
          }
          const size = line.props.size;
          const position = line.props.position;
          if (position === 'start') {
              return [size * -1, 0];
          }
          else if (position === 'end') {
              return [0, size];
          }
          else {
              return [size * -0.5, size * 0.5];
          }
      }
      getOffset() {
          const { padding, position, rotation, orientation } = this.props;
          const adjustedPadding = typeof padding === 'number'
              ? {
                  fromAxis: padding,
                  alongAxis: padding
              }
              : padding;
          const spacing = this.getTickLineSpacing();
          const offset1 = position === 'start'
              ? spacing[0] - adjustedPadding.fromAxis
              : position === 'end'
                  ? spacing[1] + adjustedPadding.fromAxis
                  : 0;
          const align = this.getAlign();
          let offset2 = rotation === true ? -5 : 0;
          offset2 +=
              align === 'center'
                  ? 0
                  : align === 'start'
                      ? -adjustedPadding.alongAxis
                      : adjustedPadding.alongAxis;
          const horz = orientation === 'horizontal';
          return {
              [horz ? 'x' : 'y']: offset2,
              [horz ? 'y' : 'x']: offset1
          };
      }
      getTextPosition() {
          const { angle, orientation, position } = this.props;
          let transform = '';
          let textAnchor = '';
          let alignmentBaseline = 'middle';
          if (angle !== 0) {
              transform = `rotate(${angle})`;
              textAnchor = 'end';
          }
          else {
              const align = this.getAlign();
              if (orientation === 'horizontal') {
                  textAnchor =
                      align === 'center' ? 'middle' : align === 'start' ? 'end' : 'start';
                  if (position === 'start') {
                      alignmentBaseline = 'baseline';
                  }
                  else if (position === 'end') {
                      alignmentBaseline = 'hanging';
                  }
              }
              else {
                  alignmentBaseline =
                      align === 'center'
                          ? 'middle'
                          : align === 'start'
                              ? 'baseline'
                              : 'hanging';
                  if (position === 'start') {
                      textAnchor = 'end';
                  }
                  else if (position === 'end') {
                      textAnchor = 'start';
                  }
                  else {
                      textAnchor = 'middle';
                  }
              }
          }
          return {
              transform,
              textAnchor: this.props.textAnchor || textAnchor,
              alignmentBaseline
          };
      }
      render() {
          const { fill, text, fullText, fontSize, fontFamily, className } = this.props;
          const { x, y } = this.getOffset();
          const textPosition = this.getTextPosition();
          return (React__default['default'].createElement("g", { transform: `translate(${x}, ${y})`, fontSize: fontSize, fontFamily: fontFamily },
              React__default['default'].createElement("title", null, fullText),
              React__default['default'].createElement("text", Object.assign({}, textPosition, { fill: fill, className: className }), text)));
      }
  }
  LinearAxisTickLabel.defaultProps = {
      fill: '#8F979F',
      fontSize: 11,
      fontFamily: 'sans-serif',
      rotation: true,
      padding: 0,
      align: 'center'
  };

  class LinearAxisTickLine extends React.PureComponent {
      positionTick() {
          const { size, position, orientation } = this.props;
          const isVertical = orientation === 'vertical';
          const tickSize = size || 0;
          const start = position === 'start'
              ? tickSize * -1
              : position === 'center'
                  ? tickSize * -0.5
                  : 0;
          const end = start + tickSize;
          return {
              x1: isVertical ? end : 0,
              x2: isVertical ? start : 0,
              y1: isVertical ? 0 : start,
              y2: isVertical ? 0 : end
          };
      }
      render() {
          const { strokeColor, strokeWidth, className } = this.props;
          const path = this.positionTick();
          return (React__default['default'].createElement("line", Object.assign({ className: className, strokeWidth: strokeWidth, stroke: strokeColor }, path)));
      }
  }
  LinearAxisTickLine.defaultProps = {
      strokeColor: '#8F979F',
      strokeWidth: 1,
      size: 5
  };

  // https://stackoverflow.com/questions/673905/best-way-to-determine-users-locale-within-browser
  const getNavigatorLanguage = () => {
      if (typeof window === 'undefined') {
          return 'en';
      }
      if (navigator.languages && navigator.languages.length) {
          return navigator.languages[0];
      }
      if (navigator.userLanguage ||
          navigator.language ||
          navigator.browserLanguage) {
          return 'en';
      }
  };
  const locale = getNavigatorLanguage();
  const options = {
      year: 'numeric',
      month: 'numeric',
      day: 'numeric',
      hour12: true,
      formatMatcher: 'best fit'
  };
  /**
   * Format a value based on type.
   */
  function formatValue(value) {
      if (value !== undefined) {
          if (value instanceof Date) {
              return value.toLocaleDateString(locale, options);
          }
          else if (typeof value === 'number') {
              return value.toLocaleString();
          }
          return value;
      }
      return 'No value';
  }

  const ONE_DAY = 60 * 60 * 24;
  const DURATION_TICK_STEPS = [
      0.001,
      0.005,
      0.01,
      0.05,
      0.1,
      0.5,
      1,
      5,
      10,
      15,
      60,
      60 * 15,
      60 * 30,
      60 * 60,
      60 * 60 * 2,
      60 * 60 * 4,
      60 * 60 * 6,
      60 * 60 * 8,
      60 * 60 * 12,
      ONE_DAY // 24 h
  ];
  /**
   * Reduce the ticks to the max number of ticks.
   */
  function reduceTicks(ticks, maxTicks) {
      if (ticks.length > maxTicks) {
          const reduced = [];
          const modulus = Math.floor(ticks.length / maxTicks);
          for (let i = 0; i < ticks.length; i++) {
              if (i % modulus === 0) {
                  reduced.push(ticks[i]);
              }
          }
          ticks = reduced;
      }
      return ticks;
  }
  /**
   * Determine the max ticks for the available width.
   */
  function getMaxTicks(size, dimension) {
      const tickWidth = Math.max(size, 0);
      return Math.floor(dimension / tickWidth);
  }
  /**
   * Formats the ticks in a duration format.
   */
  function getDurationTicks(domain, maxTicks) {
      const domainWidth = domain[1] - domain[0];
      let tickStep = null;
      for (const s of DURATION_TICK_STEPS) {
          if (domainWidth / s < maxTicks) {
              tickStep = s;
              break;
          }
      }
      if (tickStep === null) {
          const numDayTicks = domainWidth / ONE_DAY;
          const dayStep = Math.ceil(numDayTicks / maxTicks);
          tickStep = ONE_DAY * dayStep;
      }
      const ticks = [domain[0]];
      while (ticks[ticks.length - 1] + tickStep <= domain[1]) {
          ticks.push(ticks[ticks.length - 1] + tickStep);
      }
      return ticks;
  }
  /**
   * Get the tick values from the scale.
   */
  function getTicks(scale, tickValues, type, maxTicks = 100, interval) {
      let result;
      if (tickValues) {
          result = tickValues;
      }
      else {
          if (scale.ticks) {
              if (type === 'duration') {
                  result = getDurationTicks(scale.domain(), maxTicks);
              }
              else if (interval) {
                  result = scale.ticks(interval);
              }
              else {
                  if (type === 'time') {
                      // If its time, we need to handle the time count
                      // manually because d3 does this odd rounding
                      result = scale.ticks();
                      result = reduceTicks(result, maxTicks);
                  }
                  else {
                      result = scale.ticks(maxTicks);
                  }
              }
          }
          else {
              tickValues = scale.domain();
              result = reduceTicks(tickValues, maxTicks);
          }
      }
      return result;
  }

  const calculateDimensions = (text, fontFamily, fontSize) => {
      // SSR Rendering doesn't support canvas measurements
      // we have to make a guess in this case...
      if (typeof document === 'undefined') {
          return {
              width: text.length * 8,
              height: 25
          };
      }
      return calculateSize__default['default'](text, {
          font: fontFamily,
          fontSize: `${fontSize}px`
      });
  };

  class LinearAxisTickSeries extends React.Component {
      /**
       * Gets the adjusted scale given offsets.
       */
      getAdjustedScale() {
          const { scale } = this.props;
          if (scale.bandwidth) {
              let offset = scale.bandwidth() / 2;
              if (scale.round()) {
                  offset = Math.round(offset);
              }
              return (d) => +scale(d) + offset;
          }
          else {
              return (d) => +scale(d);
          }
      }
      /**
       * Gets the x/y position for a given tick.
       */
      getPosition(scaledTick) {
          const { orientation } = this.props;
          if (orientation === 'horizontal') {
              return { x: scaledTick, y: 0 };
          }
          else {
              return { x: 0, y: scaledTick };
          }
      }
      /**
       * Gets the dimension (height/width) this axis is calculating on.
       */
      getDimension() {
          const { height, width, orientation } = this.props;
          return orientation === 'vertical' ? height : width;
      }
      /**
       * Calculates the rotation angle that the ticks need to be shifted to.
       * This equation will measure the length of the text in a external canvas
       * object and determine what the longest label is and rotate until they fit.
       */
      getRotationAngle(ticks) {
          if (!this.props.label) {
              return 0;
          }
          const label = this.props.label.props;
          const dimension = this.getDimension();
          const maxTicksLength = d3Array.max(ticks, (tick) => tick.width);
          let angle = 0;
          if (label.rotation) {
              if (label.rotation === true) {
                  let baseWidth = maxTicksLength;
                  const maxBaseWidth = Math.floor(dimension / ticks.length);
                  while (baseWidth > maxBaseWidth && angle > -90) {
                      angle -= 30;
                      baseWidth = Math.cos(angle * (Math.PI / 180)) * maxTicksLength;
                  }
              }
              else {
                  angle = label.rotation;
              }
          }
          return angle;
      }
      /**
       * Gets the formatted label of the tick.
       */
      getLabelFormat() {
          const { label, scale } = this.props;
          if (label && label.props.format) {
              return label.props.format;
          }
          else if (scale.tickFormat) {
              return scale.tickFormat.apply(scale, [5]);
          }
          else {
              return (v) => formatValue(v);
          }
      }
      /**
       * Gets the ticks given the dimensions and scales and returns
       * the text and position.
       */
      getTicks() {
          const { scale, tickSize, tickValues, interval, axis, label } = this.props;
          const dimension = this.getDimension();
          const maxTicks = getMaxTicks(tickSize, dimension);
          const ticks = getTicks(scale, tickValues, axis.type, maxTicks, interval);
          const adjustedScale = this.getAdjustedScale();
          const format = this.getLabelFormat();
          const midpoint = dimension / 2;
          return ticks.map((tick) => {
              const fullText = format(tick);
              const scaledTick = adjustedScale(tick);
              const position = this.getPosition(scaledTick);
              const text = ellipsize__default['default'](fullText, 18);
              const size = label
                  ? calculateDimensions(text, label.props.fontFamily, label.props.fontSize.toString())
                  : {};
              return Object.assign(Object.assign(Object.assign({}, position), size), { text,
                  fullText, half: scaledTick === midpoint
                      ? 'center'
                      : scaledTick < midpoint
                          ? 'start'
                          : 'end' });
          });
      }
      render() {
          const { label, line, height, width, orientation } = this.props;
          const ticks = this.getTicks();
          const angle = this.getRotationAngle(ticks);
          return (React__default['default'].createElement(React.Fragment, null, ticks.map((tick, i) => (React__default['default'].createElement("g", { key: i, transform: `translate(${tick.x}, ${tick.y})` },
              line && (React__default['default'].createElement(rdk.CloneElement, { element: line, height: height, width: width, orientation: orientation })),
              label && (React__default['default'].createElement(rdk.CloneElement, { element: label, text: tick.text, fullText: tick.fullText, half: tick.half, angle: angle, orientation: orientation, line: line })))))));
      }
  }
  LinearAxisTickSeries.defaultProps = {
      line: React__default['default'].createElement(LinearAxisTickLine, null),
      label: React__default['default'].createElement(LinearAxisTickLabel, null),
      tickSize: 30
  };

  let axisLineId = 0;
  class LinearAxisLine extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {
              id: (axisLineId++).toString()
          };
      }
      render() {
          const { strokeColor, strokeGradient, scale, orientation, className } = this.props;
          const { id } = this.state;
          const [range0, range1] = scale.range();
          return (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement("line", { className: className, x1: orientation === 'vertical' ? 0 : range0, 
                  // Workaround for a Chrome/Firefox bug where it won't render gradients for straight lines
                  x2: orientation === 'vertical' ? 0.00001 : range1, y1: orientation === 'vertical' ? range0 : 0, y2: orientation === 'vertical' ? range1 : 0.00001, strokeWidth: 1, stroke: strokeGradient ? `url(#axis-gradient-${id})` : strokeColor }),
              strokeGradient && (React__default['default'].createElement(rdk.CloneElement, { element: strokeGradient, id: `axis-gradient-${id}` }))));
      }
  }
  LinearAxisLine.defaultProps = {
      strokeColor: '#8F979F',
      strokeWidth: 1
  };

  class LinearAxis extends React.Component {
      constructor(props) {
          super(props);
          this.ref = React.createRef();
          this.state = {
              height: props.height,
              width: props.width
          };
      }
      componentDidMount() {
          this.updateDimensions();
      }
      componentDidUpdate(prevProps) {
          const { height, width, scale } = this.props;
          if (width !== prevProps.width ||
              height !== prevProps.height ||
              scale !== prevProps.scale) {
              this.updateDimensions();
          }
      }
      updateDimensions() {
          const { onDimensionsChange, orientation, position } = this.props;
          const shouldOffset = position !== 'center';
          let height;
          let width;
          if (shouldOffset) {
              const dims = this.ref.current.getBoundingClientRect();
              width = Math.floor(dims.width);
              height = Math.floor(dims.height);
          }
          if (orientation === 'vertical') {
              if (this.state.width !== width) {
                  this.setState({ width });
                  onDimensionsChange({ width });
              }
          }
          else {
              if (this.state.height !== height) {
                  this.setState({ height });
                  onDimensionsChange({ height });
              }
          }
      }
      getPosition() {
          const { position, width, height, orientation } = this.props;
          let translateY = 0;
          let translateX = 0;
          if (position === 'end' && orientation === 'horizontal') {
              translateY = height;
          }
          else if (position === 'center' && orientation === 'horizontal') {
              translateY = height / 2;
          }
          else if (position === 'end' && orientation === 'vertical') {
              translateX = width;
          }
          else if (position === 'center' && orientation === 'vertical') {
              translateX = width / 2;
          }
          return { translateX, translateY };
      }
      render() {
          const { scale, height, width, orientation, axisLine, tickSeries } = this.props;
          const { translateX, translateY } = this.getPosition();
          return (React__default['default'].createElement("g", { transform: `translate(${translateX}, ${translateY})`, ref: this.ref },
              axisLine && (React__default['default'].createElement(rdk.CloneElement, { element: axisLine, height: height, width: width, scale: scale, orientation: orientation })),
              (tickSeries.props.line || tickSeries.props.label) && (React__default['default'].createElement(rdk.CloneElement, { element: tickSeries, height: height, width: width, scale: scale, orientation: orientation, axis: this.props }))));
      }
  }
  LinearAxis.defaultProps = {
      axisLine: React__default['default'].createElement(LinearAxisLine, null),
      tickSeries: React__default['default'].createElement(LinearAxisTickSeries, null),
      scaled: false,
      roundDomains: false,
      onDimensionsChange: () => undefined
  };

  class LinearXAxisTickLabel extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxisTickLabel, Object.assign({}, this.props));
      }
  }
  LinearXAxisTickLabel.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLabel.defaultProps), { rotation: true, position: 'end', align: 'center' });
  class LinearXAxisTickLine extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxisTickLine, Object.assign({}, this.props));
      }
  }
  LinearXAxisTickLine.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLine.defaultProps), { position: 'end' });
  class LinearXAxisTickSeries extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxisTickSeries, Object.assign({}, this.props));
      }
  }
  LinearXAxisTickSeries.defaultProps = Object.assign(Object.assign({}, LinearAxisTickSeries.defaultProps), { tickSize: 75, line: React__default['default'].createElement(LinearXAxisTickLine, null), label: React__default['default'].createElement(LinearXAxisTickLabel, null) });
  class LinearXAxis extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxis, Object.assign({}, this.props));
      }
  }
  LinearXAxis.defaultProps = Object.assign(Object.assign({}, LinearAxis.defaultProps), { position: 'end', roundDomains: false, scaled: false, type: 'value', orientation: 'horizontal', tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, null) });

  class LinearYAxisTickLabel extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxisTickLabel, Object.assign({}, this.props));
      }
  }
  LinearYAxisTickLabel.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLabel.defaultProps), { rotation: false, position: 'start', align: 'center' });
  class LinearYAxisTickLine extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxisTickLine, Object.assign({}, this.props));
      }
  }
  LinearYAxisTickLine.defaultProps = Object.assign(Object.assign({}, LinearAxisTickLine.defaultProps), { position: 'start' });
  class LinearYAxisTickSeries extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxisTickSeries, Object.assign({}, this.props));
      }
  }
  LinearYAxisTickSeries.defaultProps = Object.assign(Object.assign({}, LinearAxisTickSeries.defaultProps), { tickSize: 30, line: React__default['default'].createElement(LinearYAxisTickLine, null), label: React__default['default'].createElement(LinearYAxisTickLabel, null) });
  class LinearYAxis extends React.Component {
      render() {
          return React__default['default'].createElement(LinearAxis, Object.assign({}, this.props));
      }
  }
  LinearYAxis.defaultProps = Object.assign(Object.assign({}, LinearAxis.defaultProps), { orientation: 'vertical', scaled: false, roundDomains: false, type: 'value', position: 'start', tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, null) });

  /**
   * Returns whether the axis has a visual element or not.
   */
  const isAxisVisible = (axis) => !!axis.tickSeries.props.label || !!axis.tickSeries.props.line;

  class RadialAxisTickLine extends React.PureComponent {
      render() {
          const { stroke, size, position, innerRadius, outerRadius } = this.props;
          const x1 = position === 'outside' ? size : -(outerRadius - innerRadius);
          return (React__default['default'].createElement("line", { x1: x1, x2: 0, stroke: stroke, style: { pointerEvents: 'none' } }));
      }
  }
  RadialAxisTickLine.defaultProps = {
      stroke: 'rgba(113, 128, 141, .5)',
      size: 10,
      position: 'inside'
  };

  const rad2deg = (angle) => (angle * 180) / Math.PI;
  class RadialAxisTickLabel extends React.PureComponent {
      getPosition() {
          const { point, autoRotate, rotation, padding } = this.props;
          let textAnchor;
          let transform;
          if (autoRotate) {
              const l = point >= Math.PI;
              const r = point < 2 * Math.PI;
              // TODO: This centers the text, determine better way later
              if ((rotation >= 85 && rotation <= 95) ||
                  (rotation <= -85 && rotation >= -95)) {
                  textAnchor = 'middle';
              }
              else if (l && r) {
                  textAnchor = 'end';
              }
              else {
                  textAnchor = 'start';
              }
              transform = `rotate(${90 - rad2deg(point)}, ${padding}, 0)`;
          }
          else {
              const shouldRotate = rotation > 100 && rotation;
              const rotate = shouldRotate ? 180 : 0;
              const translate = shouldRotate ? -30 : 0;
              textAnchor = shouldRotate ? 'end' : 'start';
              transform = `rotate(${rotate}) translate(${translate})`;
          }
          return {
              transform,
              textAnchor
          };
      }
      render() {
          const { data, fill, fontFamily, fontSize, format, lineSize, index } = this.props;
          const text = format ? format(data, index) : formatValue(data);
          const { transform, textAnchor } = this.getPosition();
          return (React__default['default'].createElement("g", { transform: transform },
              React__default['default'].createElement("title", null, text),
              React__default['default'].createElement("text", { dy: "0.35em", x: lineSize + 5, textAnchor: textAnchor, fill: fill, fontFamily: fontFamily, fontSize: fontSize }, text)));
      }
  }
  RadialAxisTickLabel.defaultProps = {
      fill: '#71808d',
      fontSize: 11,
      padding: 15,
      fontFamily: 'sans-serif',
      autoRotate: true
  };

  class RadialAxisTick extends React.Component {
      render() {
          const { line, label, scale, outerRadius, data, index, padding, innerRadius } = this.props;
          const point = scale(data);
          const rotation = (point * 180) / Math.PI - 90;
          const transform = `rotate(${rotation}) translate(${outerRadius + padding},0)`;
          const lineSize = line ? line.props.size : 0;
          return (React__default['default'].createElement("g", { transform: transform },
              line && (React__default['default'].createElement(rdk.CloneElement, { element: line, innerRadius: innerRadius, outerRadius: outerRadius })),
              label && (React__default['default'].createElement(rdk.CloneElement, { element: label, index: index, point: point, rotation: rotation, lineSize: lineSize, data: data }))));
      }
  }
  RadialAxisTick.defaultProps = {
      outerRadius: 0,
      padding: 0,
      line: React__default['default'].createElement(RadialAxisTickLine, null),
      label: React__default['default'].createElement(RadialAxisTickLabel, null)
  };

  class RadialAxisTickSeries extends React.Component {
      render() {
          const { scale, count, outerRadius, tick, tickValues, innerRadius, interval, type } = this.props;
          const ticks = getTicks(scale, tickValues, type, count, interval || count);
          return (React__default['default'].createElement(React.Fragment, null, ticks.map((data, i) => (React__default['default'].createElement(rdk.CloneElement, { element: tick, key: i, index: i, scale: scale, data: data, innerRadius: innerRadius, outerRadius: outerRadius })))));
      }
  }
  RadialAxisTickSeries.defaultProps = {
      count: 12,
      type: 'time',
      tick: React__default['default'].createElement(RadialAxisTick, null)
  };

  class RadialAxisArc extends React.Component {
      render() {
          const { index, stroke, strokeDasharray, scale } = this.props;
          const r = scale(index);
          const strokeColor = typeof stroke === 'string' ? stroke : stroke(index);
          const strokeDash = typeof strokeDasharray === 'string'
              ? strokeDasharray
              : strokeDasharray(index);
          return (React__default['default'].createElement("circle", { fill: "none", strokeDasharray: strokeDash, stroke: strokeColor, style: { pointerEvents: 'none' }, cx: "0", cy: "0", r: r }));
      }
  }
  RadialAxisArc.defaultProps = {
      stroke: '#71808d',
      strokeDasharray: '1,4'
  };

  class RadialAxisArcSeries extends React.Component {
      render() {
          const { count, innerRadius, outerRadius, arc } = this.props;
          const scale = d3Scale.scaleLinear()
              .domain([0, count])
              .range([innerRadius, outerRadius]);
          const arcs = scale.ticks(count);
          return (React__default['default'].createElement(React.Fragment, null, arcs.map((d) => (React__default['default'].createElement(rdk.CloneElement, { element: arc, key: d, index: d, scale: scale })))));
      }
  }
  RadialAxisArcSeries.defaultProps = {
      count: 12,
      arc: React__default['default'].createElement(RadialAxisArc, null)
  };

  class RadialAxis extends React.Component {
      render() {
          const { arcs, ticks, xScale, height, width, innerRadius, type } = this.props;
          const outerRadius = Math.min(height, width) / 2;
          return (React__default['default'].createElement(React.Fragment, null,
              arcs && (React__default['default'].createElement(rdk.CloneElement, { element: arcs, outerRadius: outerRadius, innerRadius: innerRadius })),
              ticks && (React__default['default'].createElement(rdk.CloneElement, { element: ticks, scale: xScale, type: type, innerRadius: innerRadius, outerRadius: outerRadius }))));
      }
  }
  RadialAxis.defaultProps = {
      innerRadius: 10,
      type: 'value',
      arcs: React__default['default'].createElement(RadialAxisArcSeries, null),
      ticks: React__default['default'].createElement(RadialAxisTickSeries, null)
  };

  /**
   * Add ability to calculate scale band position.
   * Reference: https://stackoverflow.com/questions/38633082/d3-getting-invert-value-of-band-scales
   */
  const scaleBandInvert = (scale) => {
      const domain = scale.domain();
      const paddingOuter = scale(domain[0]);
      const eachBand = scale.step();
      const [, end] = scale.range();
      return (offset) => {
          let index = Math.floor((offset - paddingOuter) / eachBand);
          // Handle horizontal charts...
          if (end === 0) {
              index = index * -1;
          }
          return domain[Math.max(0, Math.min(index, domain.length - 1))];
      };
  };
  /**
   * Given a point position, get the closes data point in the dataset.
   */
  const getClosestPoint = (pos, scale, data, attr = 'x') => {
      if (scale.invert) {
          const domain = scale.invert(pos);
          // Select the index
          const bisect = d3Array.bisector((d) => d[attr]).right;
          const index = bisect(data, domain);
          // Determine min index
          const minIndex = Math.max(0, index - 1);
          const before = data[minIndex];
          // Determine max index
          const maxIndex = Math.min(data.length - 1, index);
          const after = data[maxIndex];
          // Determine which is closest to the point
          let beforeVal = before[attr];
          let afterVal = after[attr];
          beforeVal = domain - beforeVal;
          afterVal = afterVal - domain;
          return beforeVal < afterVal ? before : after;
      }
      else {
          // If we have a band scale, handle that special
          const domain = scale.domain();
          let prop;
          // Of course the Marimekko is a pain...
          if (scale.mariemkoInvert) {
              prop = scale.mariemkoInvert(pos);
          }
          else {
              prop = scaleBandInvert(scale)(pos);
          }
          const idx = domain.indexOf(prop);
          return data[idx];
      }
  };
  /**
   * Given an event, get the parent svg element;
   */
  const getParentSVG = (event) => {
      // set node to targets owner svg
      let node = event.target.ownerSVGElement;
      // find the outermost svg
      if (node) {
          while (node.ownerSVGElement) {
              node = node.ownerSVGElement;
          }
      }
      return node;
  };
  /**
   * Given an event, get the relative X/Y position for a target.
   */
  const getPositionForTarget = ({ target, clientX, clientY }) => {
      const { top, left } = target.getBoundingClientRect();
      return {
          x: clientX - left - target.clientLeft,
          y: clientY - top - target.clientTop
      };
  };
  /**
   * Gets the point from q given matrix.
   */
  const getPointFromMatrix = (event, matrix) => {
      const parent = getParentSVG(event);
      if (!parent) {
          return null;
      }
      // Determines client coordinates relative to the editor component
      const { top, left } = parent.getBoundingClientRect();
      const x = event.clientX - left;
      const y = event.clientY - top;
      // Transforms the coordinate to world coordinate (in the SVG/DIV world)
      return transformationMatrix.applyToPoint(transformationMatrix.inverse(matrix), { x, y });
  };
  /**
   * Get the start/end matrix.
   */
  const getLimitMatrix = (height, width, matrix) => transformationMatrix.applyToPoints(matrix, [
      { x: 0, y: 0 },
      { x: width, y: height }
  ]);
  /**
   * Constrain the matrix.
   */
  const constrainMatrix = (height, width, matrix) => {
      const [min, max] = getLimitMatrix(height, width, matrix);
      if (max.x < width || max.y < height) {
          return true;
      }
      if (min.x > 0 || min.y > 0) {
          return true;
      }
      return false;
  };
  /**
   * Determine if scale factor is less than allowed.
   */
  const lessThanScaleFactorMin = (value, scaleFactor) => value.scaleFactorMin && value.d * scaleFactor <= value.scaleFactorMin;
  /**
   * Determine if scale factor is larger than allowed.
   */
  const moreThanScaleFactorMax = (value, scaleFactor) => value.scaleFactorMax && value.d * scaleFactor >= value.scaleFactorMax;
  /**
   * Determine if both min and max scale fctors are going out of bounds.
   */
  const isZoomLevelGoingOutOfBounds = (value, scaleFactor) => {
      const a = lessThanScaleFactorMin(value, scaleFactor) && scaleFactor < 1;
      const b = moreThanScaleFactorMax(value, scaleFactor) && scaleFactor > 1;
      return a || b;
  };

  /**
   * Toggle the text selection of the body.
   */
  function toggleTextSelection(allowSelection) {
      const style = allowSelection ? '' : 'none';
      [
          '-webkit-touch-callout',
          '-webkit-user-select',
          '-khtml-user-select',
          '-moz-user-select',
          '-ms-user-select',
          'user-select'
      ].forEach((prop) => (document.body.style[prop] = style));
  }

  class Move extends React.Component {
      constructor() {
          super(...arguments);
          this.started = false;
          this.deltaX = 0;
          this.deltaY = 0;
          this.prevXPosition = 0;
          this.prevYPosition = 0;
          this.onMouseMove = (event) => {
              event.preventDefault();
              event.stopPropagation();
              const { movementX, movementY } = event;
              this.deltaX = this.deltaX + movementX;
              this.deltaY = this.deltaY + movementY;
              if (this.checkThreshold()) {
                  this.disableText(true);
                  this.setCursor(true);
                  this.deltaX = 0;
                  this.deltaY = 0;
                  this.started = true;
                  this.props.onMoveStart({
                      nativeEvent: event,
                      type: 'mouse'
                  });
              }
              else {
                  this.rqf = requestAnimationFrame(() => {
                      this.props.onMove({
                          nativeEvent: event,
                          type: 'mouse',
                          x: movementX,
                          y: movementY
                      });
                  });
              }
          };
          this.onMouseUp = (event) => {
              event.preventDefault();
              event.stopPropagation();
              this.disposeHandlers();
              if (this.started) {
                  this.props.onMoveEnd({
                      nativeEvent: event,
                      type: 'mouse'
                  });
              }
              else {
                  this.props.onMoveCancel({
                      nativeEvent: event,
                      type: 'mouse'
                  });
              }
          };
          this.onTouchMove = (event) => {
              event.preventDefault();
              event.stopPropagation();
              // Calculate delta from previous position and current
              const { clientX, clientY } = this.getTouchCoords(event);
              const deltaX = clientX - this.prevXPosition;
              const deltaY = clientY - this.prevYPosition;
              // Track the delta
              this.deltaX = this.deltaX + deltaX;
              this.deltaY = this.deltaY + deltaY;
              if (this.checkThreshold()) {
                  this.disableText(true);
                  this.setCursor(true);
                  this.deltaX = 0;
                  this.deltaY = 0;
                  this.started = true;
                  this.props.onMoveStart({
                      // TODO: Come back and clean this up...
                      nativeEvent: Object.assign(Object.assign({}, event), { clientX,
                          clientY }),
                      type: 'touch'
                  });
              }
              else {
                  this.rqf = requestAnimationFrame(() => {
                      this.props.onMove({
                          // TODO: Come back and clean this up...
                          nativeEvent: Object.assign(Object.assign({}, event), { clientX,
                              clientY }),
                          type: 'touch',
                          x: deltaX,
                          y: deltaY
                      });
                  });
              }
              this.prevXPosition = clientX;
              this.prevYPosition = clientY;
          };
          this.onTouchEnd = (event) => {
              event.preventDefault();
              event.stopPropagation();
              this.disposeHandlers();
              if (this.started) {
                  this.props.onMoveEnd({
                      nativeEvent: event,
                      type: 'touch'
                  });
              }
              else {
                  this.props.onMoveCancel({
                      nativeEvent: event,
                      type: 'touch'
                  });
              }
          };
      }
      componentWillUnmount() {
          cancelAnimationFrame(this.rqf);
          this.disposeHandlers();
      }
      disposeHandlers() {
          window.removeEventListener('mousemove', this.onMouseMove);
          window.removeEventListener('mouseup', this.onMouseUp);
          window.removeEventListener('touchmove', this.onTouchMove);
          window.removeEventListener('touchend', this.onTouchEnd);
          this.setCursor(false);
          this.disableText(true);
      }
      disableText(shouldDisable) {
          if (this.props.disableText) {
              toggleTextSelection(shouldDisable);
          }
      }
      setCursor(set) {
          let { cursor } = this.props;
          if (cursor) {
              if (!set) {
                  cursor = 'inherit';
              }
              document.body.style['cursor'] = cursor;
          }
      }
      checkThreshold() {
          const { threshold } = this.props;
          return (!this.started &&
              (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold));
      }
      getTouchCoords(event) {
          const { clientX, clientY } = event.touches[0];
          return {
              clientX,
              clientY
          };
      }
      onMouseDown(event) {
          const { preventRightClick, disabled } = this.props;
          const shouldCancel = event.nativeEvent.which === 3 && preventRightClick;
          if (shouldCancel || disabled) {
              return;
          }
          event.preventDefault();
          event.stopPropagation();
          this.started = false;
          // Always bind event so we cancel movement even if no action was taken
          window.addEventListener('mousemove', this.onMouseMove);
          window.addEventListener('mouseup', this.onMouseUp);
      }
      onTouchStart(event) {
          const { disabled } = this.props;
          if (disabled || event.touches.length !== 1) {
              return;
          }
          event.preventDefault();
          event.stopPropagation();
          this.started = false;
          this.prevXPosition = event.touches[0].clientX;
          this.prevYPosition = event.touches[0].clientY;
          // Always bind event so we cancel movement even if no action was taken
          window.addEventListener('touchmove', this.onTouchMove);
          window.addEventListener('touchend', this.onTouchEnd);
      }
      render() {
          return React.Children.map(this.props.children, (child) => React.cloneElement(child, Object.assign(Object.assign({}, child.props), { onMouseDown: (e) => {
                  this.onMouseDown(e);
                  if (child.props.onMouseDown) {
                      child.props.onMouseDown(e);
                  }
              }, onTouchStart: (e) => {
                  this.onTouchStart(e);
                  if (child.props.onTouchStart) {
                      child.props.onTouchStart(e);
                  }
              } })));
      }
  }
  Move.defaultProps = {
      preventRightClick: true,
      disableText: true,
      threshold: 0,
      onMoveStart: () => undefined,
      onMove: () => undefined,
      onMoveEnd: () => undefined,
      onMoveCancel: () => undefined
  };

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$s = ".BrushHandle-module_handle__1HtKb {\n  fill: var(--color-background);\n  stroke: var(--color-handle);\n}\n\n.BrushHandle-module_dragging__k86sG {\n  fill: var(--color-handle-drag);\n}\n\n.BrushHandle-module_dot__vx-R8 {\n  fill: var(--color-on-background);\n}\n\n.BrushHandle-module_line__1jJ7Y {\n  stroke: var(--color-handle);\n}\n";
  var css$s = {"handle":"BrushHandle-module_handle__1HtKb","dragging":"BrushHandle-module_dragging__k86sG","dot":"BrushHandle-module_dot__vx-R8","line":"BrushHandle-module_line__1jJ7Y"};
  styleInject(css_248z$s);

  class BrushHandle extends React.PureComponent {
      constructor() {
          super(...arguments);
          this.state = {
              isDragging: false
          };
      }
      onMoveStart() {
          this.setState({
              isDragging: true
          });
      }
      onMove(event) {
          this.props.onHandleDrag(event.x);
      }
      onMoveEnd() {
          this.setState({
              isDragging: false
          });
      }
      render() {
          const { height } = this.props;
          const { isDragging } = this.state;
          return (React__default['default'].createElement(Move, { cursor: "ew-resize", onMoveStart: bind__default['default'](this.onMoveStart, this), onMove: bind__default['default'](this.onMove, this), onMoveEnd: bind__default['default'](this.onMoveEnd, this) },
              React__default['default'].createElement("g", null,
                  React__default['default'].createElement("line", { className: css$s.line, y1: "0", y2: height, x1: "5", x2: "5" }),
                  React__default['default'].createElement("rect", { className: classNames__default['default'](css$s.handle, { [css$s.dragging]: isDragging }), height: height - 10, style: { cursor: 'ew-resize' }, width: 8, y: "5", y1: height - 5 }),
                  React__default['default'].createElement("g", { transform: `translate(-1, ${height / 2 - 10})`, style: { pointerEvents: 'none' } }, d3Array.range(5).map((i) => (React__default['default'].createElement("circle", { cy: i * 5, cx: "5", r: ".5", key: i, className: css$s.dot })))))));
      }
  }

  var css_248z$r = ".BrushSlice-module_slice__sa839 {\n  fill: var(--color-primary);\n}\n\n.BrushSlice-module_unsliced__1Ls_5 {\n  fill: var(--color-background);\n  opacity: 0.5;\n  pointer-events: none;\n}\n";
  var css$r = {"slice":"BrushSlice-module_slice__sa839","unsliced":"BrushSlice-module_unsliced__1Ls_5"};
  styleInject(css_248z$r);

  class BrushSlice extends React.PureComponent {
      constructor() {
          super(...arguments);
          this.state = {
              isDragging: false
          };
      }
      onMoveStart() {
          const { start, end, width } = this.props;
          const hasNoSlice = start === 0 && end === width;
          if (!hasNoSlice) {
              this.setState({
                  isDragging: true
              });
          }
      }
      onMove({ x }) {
          const { onBrushChange, width } = this.props;
          let { start, end } = this.props;
          start = start + x;
          end = end + x;
          if (start >= 0 && end <= width) {
              onBrushChange({
                  start,
                  end
              });
          }
      }
      onMoveEnd() {
          this.setState({
              isDragging: false
          });
      }
      onHandleDrag(direction, deltaX) {
          const { onBrushChange } = this.props;
          let { start, end } = this.props;
          start = direction === 'start' ? start + deltaX : start;
          end = direction !== 'start' ? end + deltaX : end;
          onBrushChange({
              start,
              end
          });
      }
      render() {
          const { height, start, end, width } = this.props;
          const { isDragging } = this.state;
          const sliceWidth = Math.max(end - start, 0);
          const endSliceWidth = Math.max(width - end, 0);
          const hasNoSlice = start === 0 && end === width;
          return (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement("rect", { className: css$r.unsliced, height: height, width: start }),
              React__default['default'].createElement("rect", { transform: `translate(${end}, 0)`, className: css$r.unsliced, height: height, width: endSliceWidth }),
              React__default['default'].createElement("g", { transform: `translate(${start}, 0)` },
                  React__default['default'].createElement(Move, { cursor: "grabbing", onMoveStart: bind__default['default'](this.onMoveStart, this), onMove: bind__default['default'](this.onMove, this), onMoveEnd: bind__default['default'](this.onMoveEnd, this) },
                      React__default['default'].createElement("rect", { className: css$r.slice, height: height, width: sliceWidth, style: {
                              cursor: isDragging ? 'grabbing' : 'grab',
                              opacity: hasNoSlice ? 0 : 0.1,
                              pointerEvents: !hasNoSlice ? 'initial' : 'none'
                          } })),
                  React__default['default'].createElement("g", { transform: 'translate(-4, 0)' },
                      React__default['default'].createElement(BrushHandle, { height: height, onHandleDrag: bind__default['default'](this.onHandleDrag, this, 'start') })),
                  React__default['default'].createElement("g", { transform: `translate(${sliceWidth - 5}, 0)` },
                      React__default['default'].createElement(BrushHandle, { height: height, onHandleDrag: bind__default['default'](this.onHandleDrag, this, 'end') })))));
      }
  }

  class Brush extends React.PureComponent {
      constructor(props) {
          super(props);
          this.state = {
              isSlicing: false,
              isPanning: false,
              start: props.start || 0,
              end: props.end || props.width
          };
      }
      componentDidUpdate(prevProps) {
          // If no brush is defined and width updates, update the offset of the end handle.
          if (prevProps.width !== this.props.width &&
              this.state.end === prevProps.width) {
              this.setState({ end: this.props.width });
          }
          // Don't update if we are doing the slicing
          if (!this.state.isSlicing && !this.state.isPanning) {
              const { start, end } = this.props;
              const startUpdated = start !== prevProps.start && start !== this.state.start;
              const endUpdated = end !== prevProps.end && end !== this.state.end;
              if (startUpdated || endUpdated) {
                  this.setState(Object.assign({}, this.ensurePositionInBounds(start, end)));
              }
          }
      }
      getStartEnd(event, state = this.state) {
          const { x } = this.getPositionsForPanEvent(event);
          let start;
          let end;
          if (x < state.initial) {
              start = x;
              end = state.initial;
          }
          else {
              start = state.initial;
              end = x;
          }
          return this.ensurePositionInBounds(start, end, state);
      }
      getPositionsForPanEvent(event) {
          const eventObj = {
              target: this.ref,
              clientX: event.clientX,
              clientY: event.clientY
          };
          return getPositionForTarget(eventObj);
      }
      ensurePositionInBounds(newStart, newEnd, state = this.state) {
          const { width } = this.props;
          let start = newStart;
          let end = newEnd;
          if (start === undefined || start <= 0) {
              start = 0;
          }
          if (end === undefined) {
              end = width;
          }
          if (start > end) {
              start = state.start;
          }
          if (end < start) {
              end = state.end;
          }
          if (end >= width) {
              end = width;
          }
          return { start, end };
      }
      onMoveStart(event) {
          const positions = this.getPositionsForPanEvent(event.nativeEvent);
          this.setState({
              isSlicing: true,
              initial: positions.x
          });
      }
      onMove(event) {
          this.setState((prev) => {
              const { onBrushChange } = this.props;
              // Use setState callback so we can get the true previous value
              // rather than the bulk updated value react will trigger
              const { start, end } = this.getStartEnd(event.nativeEvent, prev);
              if (onBrushChange) {
                  onBrushChange({
                      start,
                      end
                  });
              }
              return {
                  start,
                  end
              };
          });
      }
      onMoveEnd() {
          this.setState({
              isSlicing: false
          });
      }
      onMoveCancel() {
          const val = {
              start: 0,
              end: this.props.width
          };
          this.setState(val);
          if (this.props.onBrushChange) {
              this.props.onBrushChange(val);
          }
      }
      onSliceChange(event) {
          const val = this.ensurePositionInBounds(event.start, event.end);
          this.setState(val);
          if (this.props.onBrushChange) {
              this.props.onBrushChange(val);
          }
      }
      render() {
          const { children, disabled, height, width } = this.props;
          const { isSlicing, start, end } = this.state;
          return (React__default['default'].createElement(Move, { cursor: "crosshair", onMoveStart: bind__default['default'](this.onMoveStart, this), onMove: bind__default['default'](this.onMove, this), onMoveEnd: bind__default['default'](this.onMoveEnd, this), onMoveCancel: bind__default['default'](this.onMoveCancel, this) },
              React__default['default'].createElement("g", { style: {
                      pointerEvents: isSlicing ? 'none' : 'auto',
                      cursor: disabled ? '' : 'crosshair'
                  } },
                  children,
                  !disabled && (React__default['default'].createElement(React.Fragment, null,
                      React__default['default'].createElement("rect", { ref: (ref) => (this.ref = ref), height: height, width: width, opacity: 0 }),
                      start !== undefined && end !== undefined && (React__default['default'].createElement(BrushSlice, { start: start, end: end, height: height, width: width, onBrushChange: bind__default['default'](this.onSliceChange, this) })))))));
      }
  }
  Brush.defaultProps = {
      disabled: false,
      height: 0,
      width: 0,
      onBrushChange: () => undefined
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }

  class ChartBrush extends React.Component {
      getBrushOffset() {
          let start;
          let end;
          const { disabled, domain, scale } = this.props;
          if (!disabled && domain) {
              start = scale(domain[0]);
              end = scale(domain[1]);
          }
          return { start, end };
      }
      onBrushChange(event) {
          const { onBrushChange, scale, width } = this.props;
          if (onBrushChange) {
              let domain;
              if (event.start !== undefined &&
                  event.end !== undefined &&
                  (event.start !== 0 || event.end !== width)) {
                  const start = scale.invert(event.start);
                  const end = scale.invert(event.end);
                  domain = [start, end];
              }
              onBrushChange({
                  domain
              });
          }
      }
      render() {
          const _a = this.props, { scale, height, width, children } = _a, rest = __rest(_a, ["scale", "height", "width", "children"]);
          return (React__default['default'].createElement(Brush, Object.assign({}, rest, this.getBrushOffset(), { height: height, width: width, onBrushChange: bind__default['default'](this.onBrushChange, this) }), children));
      }
  }
  ChartBrush.defaultProps = {};

  /**
   * Given a margins object, returns the top/left/right/bottom positions.
   */
  function parseMargins(margins) {
      let top = 0;
      let right = 0;
      let bottom = 0;
      let left = 0;
      if (Array.isArray(margins)) {
          if (margins.length === 2) {
              top = margins[0];
              bottom = margins[0];
              left = margins[1];
              right = margins[1];
          }
          else if (margins.length === 4) {
              top = margins[0];
              right = margins[1];
              bottom = margins[2];
              left = margins[3];
          }
      }
      else if (margins !== undefined) {
          top = margins;
          right = margins;
          bottom = margins;
          left = margins;
      }
      return {
          top,
          right,
          bottom,
          left
      };
  }
  /**
   * Calculates the margins for the chart.
   */
  function calculateMarginOffsets(height, width, margins) {
      const { left, right, bottom, top } = margins;
      const newHeight = height - top - bottom;
      const newWidth = width - left - right;
      return {
          height: newHeight,
          width: newWidth
      };
  }
  /**
   * Calculates the dimensions for the chart.
   */
  function getDimension({ xOffset, yOffset, height, width, margins }) {
      const parsedMargins = parseMargins(margins);
      const marginDims = calculateMarginOffsets(height, width, parsedMargins);
      const chartWidth = marginDims.width - xOffset;
      const chartHeight = marginDims.height - yOffset;
      return {
          xOffset,
          yOffset,
          height,
          width,
          chartWidth,
          chartHeight,
          xMargin: xOffset + parsedMargins.left,
          yMargin: parsedMargins.top
      };
  }

  const ChartContainer = (_a) => {
      var { className, children, center, centerX, centerY, style, margins, xAxisVisible, yAxisVisible, id } = _a, rest = __rest(_a, ["className", "children", "center", "centerX", "centerY", "style", "margins", "xAxisVisible", "yAxisVisible", "id"]);
      const curId = id || rdk.useId();
      const [xAxisSized, setXAxisSized] = React.useState(false);
      const [yAxisSized, setYAxisSized] = React.useState(false);
      const [xOffset, setYOffset] = React.useState(0);
      const [yOffset, setXOffset] = React.useState(0);
      const { ref, width, height } = useDimensions__default['default']();
      const chartSized = React.useMemo(() => {
          if (!height || !width) {
              return false;
          }
          // TODO: @amcdnl refactor this to account for 0-2 axises on x/y
          if (xAxisVisible && !xAxisSized) {
              return false;
          }
          if (yAxisVisible && !yAxisSized) {
              return false;
          }
          return true;
      }, [height, width, xAxisSized, xAxisVisible, yAxisVisible, yAxisSized]);
      const onUpdateAxes = React.useCallback((orientation, event) => {
          if (orientation === 'horizontal') {
              setXAxisSized(true);
          }
          else {
              setYAxisSized(true);
          }
          if (event.height) {
              setYOffset(event.height);
          }
          if (event.width) {
              setXOffset(event.width);
          }
      }, []);
      const childProps = React.useMemo(() => (Object.assign({ chartSized, id: curId, updateAxes: onUpdateAxes, yAxisSized,
          xAxisSized }, getDimension({
          margins,
          height,
          width,
          yOffset,
          xOffset
      }))), [
          chartSized,
          id,
          onUpdateAxes,
          yAxisSized,
          xAxisSized,
          margins,
          height,
          width,
          yOffset,
          xOffset
      ]);
      const translateX = center || centerX ? width / 2 : childProps.xMargin;
      const translateY = center || centerY ? height / 2 : childProps.yMargin;
      const styleHeight = rest.height || '100%';
      const styleWidth = rest.width || '100%';
      return (React__default['default'].createElement("div", { ref: ref, style: { height: styleHeight, width: styleWidth } }, height > 0 && width > 0 && (React__default['default'].createElement("svg", { width: width, height: height, className: className, style: style },
          React__default['default'].createElement("g", { transform: `translate(${translateX}, ${translateY})` }, children(childProps))))));
  };

  const humanFormatScale = new humanFormat__default['default'].Scale({
      k: 1000,
      M: 1000000,
      B: 1000000000
  });
  const humanFormatMillionScale = new humanFormat__default['default'].Scale({
      M: 1,
      B: 1000,
      T: 1000000
  });
  const ONE_MILLION = 1000000;
  const ONE_BILLION = 1000000000;
  const humanFormatBigInteger = (bigInteger) => {
      if (bigInteger.greater(ONE_BILLION)) {
          return humanFormat__default['default'](bigInteger.divide(ONE_MILLION).toJSNumber(), {
              scale: humanFormatMillionScale
          });
      }
      return humanFormat__default['default'](bigInteger.toJSNumber(), { scale: humanFormatScale });
  };
  const bigIntegerToLocaleString = (bigInteger) => {
      let i = 0;
      let formattedString = '';
      for (const c of bigInteger.toString().split('').reverse()) {
          if (i > 0 && i % 3 === 0) {
              formattedString = ',' + formattedString;
          }
          formattedString = c + formattedString;
          i++;
      }
      return formattedString;
  };

  function normalizeValue(value, maxBigInt) {
      if (bigInt__default['default'].isInstance(value)) {
          if (maxBigInt.greater(1000000)) {
              const divideBy = maxBigInt.divide(1000000);
              return value.divide(divideBy).toJSNumber();
          }
          else {
              return value.toJSNumber();
          }
      }
      else {
          return value;
      }
  }
  function normalizeValueForFormatting(value) {
      if (bigInt__default['default'].isInstance(value)) {
          return bigIntegerToLocaleString(value);
      }
      return value;
  }
  function getMaxBigIntegerForNested(series) {
      let maxBigInteger = bigInt__default['default'].one;
      for (const group of series) {
          const maxBigIntegerForGroup = getMaxBigIntegerForShallow(group.data);
          if (maxBigIntegerForGroup.greater(maxBigInteger)) {
              maxBigInteger = maxBigIntegerForGroup;
          }
      }
      return maxBigInteger;
  }
  function getMaxBigIntegerForShallow(series) {
      let maxBigInteger = bigInt__default['default'].one;
      for (const point of series) {
          if (bigInt__default['default'].isInstance(point.data)) {
              const bigInteger = point.data;
              if (bigInteger.greater(maxBigInteger)) {
                  maxBigInteger = bigInteger;
              }
          }
      }
      return maxBigInteger;
  }

  /**
   * Accepts a `ChartDataShape` and transforms it to a chart readable data shape.
   *
   * Example:
   *
   *   [{
   *    key: 'Threat Intel',
   *    data: [{ key:'2011', data: 25 }]
   *   }]
   *
   * will be transformed to:
   *
   *  [{
   *    key: 'Threat Intel',
   *    data: [
   *      key: 'Threat Intel',
   *      x: '2011',
   *      y: 25
   *    ]
   *  }]
   */
  function buildNestedChartData(series, sort = false, direction = 'vertical') {
      let result = [];
      const maxBigInteger = getMaxBigIntegerForNested(series);
      const isVertical = direction === 'vertical';
      for (const point of series) {
          for (const nestedPoint of point.data) {
              const key = normalizeValueForFormatting(point.key);
              let idx = result.findIndex((r) => {
                  const left = r.key;
                  if (left instanceof Date && key instanceof Date) {
                      return left.getTime() === key.getTime();
                  }
                  return left === key;
              });
              if (idx === -1) {
                  result.push({
                      key,
                      metadata: point.metadata,
                      data: []
                  });
                  idx = result.length - 1;
              }
              const x = normalizeValue(isVertical ? nestedPoint.key : nestedPoint.data, maxBigInteger);
              const y = normalizeValue(isVertical ? nestedPoint.data : nestedPoint.key, maxBigInteger);
              result[idx].data.push({
                  key,
                  value: normalizeValueForFormatting(nestedPoint.data),
                  metadata: nestedPoint.metadata,
                  id: point.id,
                  x,
                  x0: isVertical ? x : 0,
                  x1: x,
                  y,
                  y0: isVertical ? 0 : y,
                  y1: y
              });
          }
      }
      // Sort the series data based on the median value
      if (sort) {
          result = result.sort((a, b) => {
              const aMax = d3Array.median(a.data, (d) => d.y);
              const bMax = d3Array.median(b.data, (d) => d.y);
              return aMax < bMax ? 1 : -1;
          });
      }
      return result;
  }
  function addToChartType(a, b) {
      if (bigInt__default['default'].isInstance(a) && bigInt__default['default'].isInstance(b)) {
          return a.add(b);
      }
      else if (a instanceof Date && typeof b === 'number') {
          return new Date(a.valueOf() + b);
      }
      else if (typeof a === 'number' && typeof b === 'number') {
          return a + b;
      }
      else {
          throw new Error('Invalid types to addToChartTypes');
      }
  }
  /**
   * Accepts a shallow shape and normalizes it to a chart readable format.
   */
  function buildShallowChartData(series, direction = 'vertical', binSize = undefined) {
      const result = [];
      const maxBigInteger = getMaxBigIntegerForShallow(series);
      const isVertical = direction === 'vertical';
      for (const point of series) {
          const isTuple = Array.isArray(point.data);
          let k1 = point.key;
          if (binSize) {
              k1 = addToChartType(point.key, binSize);
          }
          const props = {
              k0: normalizeValue(point.key, maxBigInteger),
              k1: normalizeValue(k1, maxBigInteger),
              v0: normalizeValue(isTuple ? point.data[0] : 0, maxBigInteger),
              v1: normalizeValue(isTuple ? point.data[1] : point.data, maxBigInteger)
          };
          const xProp = isVertical ? 'k' : 'v';
          const yProp = isVertical ? 'v' : 'k';
          result.push({
              key: normalizeValueForFormatting(props.k0),
              value: normalizeValueForFormatting(props.v1),
              metadata: point.metadata,
              id: point.id,
              x: props[`${xProp}1`],
              x0: props[`${xProp}0`],
              x1: props[`${xProp}1`],
              y: props[`${yProp}1`],
              y0: props[`${yProp}0`],
              y1: props[`${yProp}1`]
          });
      }
      return result;
  }

  /**
   * Build a histogram given data set.
   */
  function buildBins(xScale, thresholds, data) {
      const layout = d3Array.histogram()
          .value((d) => d.x)
          .domain(xScale.domain())
          .thresholds(xScale.ticks(thresholds));
      const bins = layout(data);
      return bins.map((bin) => ({
          x0: bin.x0,
          x1: bin.x1,
          y: bin.length,
          y0: 0,
          y1: bin.length
      }));
  }

  /**
   * Given a dataset and a list of accessors, returns a unique collection.
   */
  function uniqueBy(data, ...accessors) {
      const result = [];
      const ittr = (arr, depth) => {
          for (const a of arr) {
              const acc = accessors[depth];
              if (acc === undefined) {
                  throw new Error(`Accessor not found for depth: ${depth}`);
              }
              const val = acc(a);
              if (Array.isArray(val)) {
                  ittr(val, depth + 1);
              }
              else if (!result.includes(val)) {
                  result.push(val);
              }
          }
      };
      ittr(data, 0);
      return result;
  }

  /**
   * Given a dataset like:
   *
   *   [{
   *    key: 'Threat Intel',
   *    data: [{ key:'2011', data: 25 }]
   *   }]
   *
   * it will transform it to:
   *
   *  [
   *    { x: 'Theat Intel', '2011': 25 }
   *  ]
   */
  function transformDataToStack$1(data) {
      const result = [];
      const maxBigInteger = getMaxBigIntegerForNested(data);
      for (const category of data) {
          for (const value of category.data) {
              let idx = result.findIndex((r) => {
                  if (r.x instanceof Date && category.key instanceof Date) {
                      return r.x.getTime() === category.key.getTime();
                  }
                  return r.x === category.key;
              });
              if (idx === -1) {
                  result.push({
                      metadata: category.metadata,
                      x: category.key,
                      formattedValues: {}
                  });
                  idx = result.length - 1;
              }
              result[idx][value.key] = normalizeValue(value.data, maxBigInteger);
              result[idx].formattedValues[value.key] = normalizeValueForFormatting(value.data);
          }
      }
      return result;
  }
  /**
   * Translates the stack data to a chart standard dataset.
   */
  function transformStackToData$1(stackData, direction = 'vertical') {
      const result = [];
      const isVertical = direction === 'vertical';
      // Transform the data from the d3 stack format to our internal format
      for (const category of stackData) {
          for (const point of category) {
              const key = point.data.x;
              let idx = result.findIndex((r) => {
                  if (r.key instanceof Date && key instanceof Date) {
                      return r.key.getTime() === key.getTime();
                  }
                  return r.key === key;
              });
              if (idx === -1) {
                  result.push({
                      key,
                      data: []
                  });
                  idx = result.length - 1;
              }
              const categoryKey = category.key;
              const y = point.data[categoryKey];
              const [y0, y1] = point;
              result[idx].data.push({
                  metadata: point.data.metadata,
                  key,
                  x: isVertical ? categoryKey : y1,
                  x0: isVertical ? categoryKey : y0,
                  x1: isVertical ? categoryKey : y1,
                  y: isVertical ? y : categoryKey,
                  y0: isVertical ? y0 : categoryKey,
                  y1: isVertical ? y1 : categoryKey,
                  value: point.data.formattedValues[categoryKey]
              });
          }
      }
      return result;
  }
  /**
   * Builds a stack dataset from the standard data format.
   */
  function buildBarStackData(data, offset = 'default', direction = 'vertical') {
      const keys = uniqueBy(data, (d) => d.data, (d) => d.key);
      const stackData = transformDataToStack$1(data);
      let stackFn = d3Shape.stack();
      if (offset === 'expand') {
          stackFn = stackFn.offset(d3Shape.stackOffsetExpand);
      }
      else if (offset === 'diverging') {
          stackFn = stackFn.offset(d3Shape.stackOffsetDiverging);
      }
      const result = stackFn.keys(keys)(stackData);
      return transformStackToData$1(result, direction);
  }

  /**
   * Builds a stack dataset from the standard data format.
   */
  function buildMarimekkoData(data) {
      const result = buildBarStackData(data, 'expand');
      const sums = {};
      // Calculate the sum for each series and the total sum
      let totalSum = 0;
      for (const series of result) {
          const sum = series.data.reduce((acc, cur) => acc + cur.y, 0);
          sums[series.key] = sum;
          totalSum += sum;
      }
      // Calculate the x0/x1 for each series
      let prev = 0;
      for (const series of result) {
          const x0 = prev;
          const x1 = prev + sums[series.key] / totalSum;
          prev = x1;
          for (const point of series.data) {
              point.x0 = x0;
              point.x1 = x1;
          }
      }
      return result;
  }

  /**
   * Given a dataset like:
   *
   *   [{
   *    key: 'Threat Intel',
   *    data: [{ key:'2011', data: 25 }]
   *   }]
   *
   * it will transform it to:
   *
   *  [
   *    { x: '2011', 'Theat Intel': 25 }
   *  ]
   */
  function transformDataToStack(data) {
      const result = [];
      const maxBigInteger = getMaxBigIntegerForNested(data);
      for (const category of data) {
          for (const value of category.data) {
              let idx = result.findIndex((r) => {
                  if (r.x instanceof Date && value.key instanceof Date) {
                      return r.x.getTime() === value.key.getTime();
                  }
                  return r.x === value.key;
              });
              if (idx === -1) {
                  result.push({
                      x: value.key,
                      formattedValues: {}
                  });
                  idx = result.length - 1;
              }
              result[idx][category.key] = normalizeValue(value.data, maxBigInteger);
              result[idx].formattedValues[category.key] = normalizeValueForFormatting(value.data);
          }
      }
      return result;
  }
  /**
   * Translates the stack data to a chart standard dataset.
   */
  function transformStackToData(stackData) {
      const result = [];
      for (const category of stackData) {
          const series = [];
          for (const point of category) {
              const [y0, y1] = point;
              const x = point.data.x;
              series.push({
                  key: category.key,
                  x,
                  x0: x,
                  x1: x,
                  y: y1 - y0,
                  y0,
                  y1,
                  value: point.data.formattedValues[category.key]
              });
          }
          result.push({
              key: category.key,
              data: series
          });
      }
      return result;
  }
  /**
   * Builds a stack dataset from the standard data format.
   */
  function buildStackData(data, normalized = false) {
      const keys = uniqueBy(data, (d) => d.key);
      const stackData = transformDataToStack(data);
      const stackFn = !normalized ? d3Shape.stack() : d3Shape.stack().offset(d3Shape.stackOffsetExpand);
      const result = stackFn.keys(keys)(stackData);
      return transformStackToData(result);
  }

  const buildWaterfall = (series, direction = 'vertical', binSize = undefined) => {
      const data = buildShallowChartData(series, direction, binSize);
      const isVertical = direction === 'vertical';
      const v = isVertical ? 'y' : 'x';
      let cumulative = 0;
      for (const point of data) {
          point[`${v}0`] = cumulative;
          cumulative += point[v];
          point[`${v}1`] = cumulative;
          point[v] = cumulative;
      }
      return data;
  };

  class Pan extends React.Component {
      constructor() {
          super(...arguments);
          this.prevXPosition = 0;
          this.prevYPosition = 0;
          this.started = false;
          this.deltaX = 0;
          this.deltaY = 0;
          this.childRef = React.createRef();
          this.onMouseDown = (event) => {
              // Stop at disabled
              if (this.props.disabled) {
                  return;
              }
              // Ignore right click
              if (event.which === 3) {
                  return;
              }
              // If global panning is turned off, it will only pan on the container
              if (!this.props.globalPanning &&
                  event.target &&
                  !event.target.classList.contains('pan-container')) {
                  return;
              }
              event.preventDefault();
              event.stopPropagation();
              toggleTextSelection(false);
              this.started = false;
              // Always bind event so we cancel movement even if no action was taken
              window.addEventListener('mousemove', this.onMouseMove);
              window.addEventListener('mouseup', this.onMouseUp);
          };
          this.onMouseMove = (event) => {
              event.preventDefault();
              event.stopPropagation();
              this.deltaX = this.deltaX + event.movementX;
              this.deltaY = this.deltaY + event.movementY;
              if (this.checkThreshold()) {
                  if (this.props.cursor) {
                      document.body.style['cursor'] = this.props.cursor;
                  }
                  this.deltaX = 0;
                  this.deltaY = 0;
                  this.started = true;
                  this.onPanStart(event, 'mouse');
              }
              else {
                  this.pan(event.movementX, event.movementY, event, 'mouse');
              }
          };
          this.onMouseUp = (event) => {
              event.preventDefault();
              event.stopPropagation();
              this.disposeHandlers();
              toggleTextSelection(true);
              if (this.started) {
                  this.onPanEnd(event, 'mouse');
              }
              else {
                  this.props.onPanCancel({
                      nativeEvent: event,
                      source: 'mouse'
                  });
              }
          };
          this.onTouchStart = (event) => {
              // Stop at disabled
              if (this.props.disabled) {
                  return;
              }
              // Reqquire more than one touch
              if (event.touches.length !== 1) {
                  return;
              }
              event.preventDefault();
              event.stopPropagation();
              toggleTextSelection(false);
              this.started = false;
              this.prevXPosition = event.touches[0].clientX;
              this.prevYPosition = event.touches[0].clientY;
              // Always bind event so we cancel movement even if no action was taken
              window.addEventListener('touchmove', this.onTouchMove);
              window.addEventListener('touchend', this.onTouchEnd);
          };
          this.onTouchMove = (event) => {
              event.preventDefault();
              event.stopPropagation();
              // Calculate delta from previous position and current
              const x = event.touches[0].clientX;
              const y = event.touches[0].clientY;
              const deltaX = x - this.prevXPosition;
              const deltaY = y - this.prevYPosition;
              this.deltaX = this.deltaX + deltaX;
              this.deltaY = this.deltaY + deltaY;
              if (this.checkThreshold()) {
                  this.deltaX = 0;
                  this.deltaY = 0;
                  this.started = true;
                  this.onPanStart(event, 'touch');
              }
              else {
                  const contrained = this.pan(deltaX, deltaY, event, 'touch');
                  if (!contrained) {
                      this.prevXPosition = x;
                      this.prevYPosition = y;
                  }
              }
          };
          this.onTouchEnd = (event) => {
              event.preventDefault();
              event.stopPropagation();
              this.disposeHandlers();
              toggleTextSelection(true);
              if (this.started) {
                  this.onPanEnd(event, 'touch');
              }
              else {
                  this.props.onPanCancel({
                      nativeEvent: event,
                      source: 'touch'
                  });
              }
          };
      }
      componentDidMount() {
          if (this.childRef.current) {
              this.childRef.current.addEventListener('mousedown', this.onMouseDown, {
                  passive: false
              });
              this.childRef.current.addEventListener('touchstart', this.onTouchStart, {
                  passive: false
              });
          }
      }
      componentWillUnmount() {
          this.disposeHandlers();
          if (this.childRef.current) {
              this.childRef.current.removeEventListener('mousedown', this.onMouseDown);
              this.childRef.current.removeEventListener('touchstart', this.onTouchStart);
          }
      }
      disposeHandlers() {
          window.removeEventListener('mousemove', this.onMouseMove);
          window.removeEventListener('mouseup', this.onMouseUp);
          window.removeEventListener('touchmove', this.onTouchMove);
          window.removeEventListener('touchend', this.onTouchEnd);
          // Reset cursor on body back to original
          document.body.style['cursor'] = 'inherit';
          toggleTextSelection(true);
      }
      checkThreshold() {
          const { threshold } = this.props;
          return (!this.started &&
              (Math.abs(this.deltaX) > threshold || Math.abs(this.deltaY) > threshold));
      }
      onPanStart(nativeEvent, source) {
          this.props.onPanStart({
              nativeEvent,
              source
          });
      }
      onPanMove(x, y, source, nativeEvent) {
          this.props.onPanMove({
              source,
              nativeEvent,
              x,
              y
          });
      }
      onPanEnd(nativeEvent, source) {
          const { onPanEnd } = this.props;
          onPanEnd({
              nativeEvent,
              source
          });
      }
      pan(x, y, nativeEvent, source) {
          const { scale, constrain, width, height, matrix } = this.props;
          const newMatrix = transformationMatrix.smoothMatrix(transformationMatrix.transform(matrix, transformationMatrix.translate(x / scale, y / scale)), 100);
          const shouldConstrain = constrain && constrainMatrix(height, width, newMatrix);
          if (!shouldConstrain) {
              this.onPanMove(newMatrix.e, newMatrix.f, source, nativeEvent);
          }
          return shouldConstrain;
      }
      render() {
          return React__default['default'].createElement("g", { ref: this.childRef }, this.props.children);
      }
  }
  Pan.defaultProps = {
      x: 0,
      y: 0,
      disabled: false,
      scale: 1,
      threshold: 10,
      globalPanning: true,
      onPanStart: () => undefined,
      onPanMove: () => undefined,
      onPanEnd: () => undefined,
      onPanCancel: () => undefined
  };

  /**
   * Gets the position between a given set of points.
   */
  const getMidpoint = (pointA, pointB) => ({
      x: (pointA.x + pointB.x) / 2,
      y: (pointA.y + pointB.y) / 2
  });
  /**
   * Gets the distance between a given set of points.
   */
  const getDistanceBetweenPoints = (pointA, pointB) => Math.sqrt(Math.pow(pointB.y - pointA.y, 2) + Math.pow(pointB.x - pointA.x, 2));
  /**
   * Get touch points.
   */
  function getTouchPoints(event, node) {
      const { left, top } = node.getBoundingClientRect();
      const [pointA, pointB] = [...event.touches].map((touch) => ({
          x: touch.clientX - Math.round(left),
          y: touch.clientY - Math.round(top)
      }));
      const distance = getDistanceBetweenPoints(pointA, pointB);
      const midpoint = getMidpoint(pointA, pointB);
      return {
          pointA,
          pointB,
          distance,
          midpoint
      };
  }

  class Zoom extends React.Component {
      constructor() {
          super(...arguments);
          this.childRef = React.createRef();
          this.onMouseWheel = (event) => {
              const { disableMouseWheel, requireZoomModifier, matrix, onZoomEnd } = this.props;
              if (disableMouseWheel) {
                  return false;
              }
              const hasModifier = event.metaKey || event.ctrlKey;
              if (requireZoomModifier && !hasModifier) {
                  return false;
              }
              event.preventDefault();
              event.stopPropagation();
              const point = getPointFromMatrix(event, matrix);
              if (point) {
                  const { x, y } = point;
                  const step = this.getStep(event.deltaY);
                  this.scale(x, y, step, event);
                  // Do small timeout to 'guess' when its done zooming
                  clearTimeout(this.timeout);
                  this.timeout = setTimeout(() => onZoomEnd(), 500);
              }
          };
          this.onTouchStart = (event) => {
              if (event.touches.length === 2) {
                  event.preventDefault();
                  event.stopPropagation();
                  toggleTextSelection(false);
                  this.firstTouch = getTouchPoints(event, this.childRef.current);
                  this.lastDistance = this.firstTouch.distance;
                  window.addEventListener('touchmove', this.onTouchMove);
                  window.addEventListener('touchend', this.onTouchEnd);
              }
          };
          this.onTouchMove = (event) => {
              if (event.touches.length === 2) {
                  event.preventDefault();
                  event.stopPropagation();
                  const { distance } = getTouchPoints(event, this.childRef.current);
                  const distanceFactor = distance / this.lastDistance;
                  const point = transformationMatrix.applyToPoint(transformationMatrix.inverse(this.props.matrix), {
                      x: this.firstTouch.midpoint.x,
                      y: this.firstTouch.midpoint.y
                  });
                  if (point.x && point.y) {
                      const outside = this.scale(point.x, point.y, distanceFactor, event);
                      if (!outside) {
                          this.lastDistance = distance;
                      }
                  }
              }
          };
          this.onTouchEnd = (event) => {
              event.preventDefault();
              event.stopPropagation();
              window.removeEventListener('touchmove', this.onTouchMove);
              window.removeEventListener('touchend', this.onTouchEnd);
              toggleTextSelection(true);
              this.props.onZoomEnd();
          };
      }
      componentDidMount() {
          const { disabled, disableMouseWheel } = this.props;
          const ref = this.childRef.current;
          if (!disabled && ref) {
              if (!disableMouseWheel) {
                  ref.addEventListener('mousewheel', this.onMouseWheel, {
                      passive: false
                  });
              }
              ref.addEventListener('touchstart', this.onTouchStart, { passive: false });
          }
      }
      componentWillUnmount() {
          window.removeEventListener('touchmove', this.onTouchMove);
          window.removeEventListener('touchend', this.onTouchEnd);
          cancelAnimationFrame(this.rqf);
          clearTimeout(this.timeout);
          const ref = this.childRef.current;
          if (ref) {
              ref.removeEventListener('mousewheel', this.onMouseWheel);
              ref.removeEventListener('touchstart', this.onTouchStart);
          }
          toggleTextSelection(true);
      }
      getStep(delta) {
          const { scaleFactor } = this.props;
          return -delta > 0 ? scaleFactor + 1 : 1 - scaleFactor;
      }
      scale(x, y, step, nativeEvent) {
          const { minZoom, maxZoom, onZoom, matrix } = this.props;
          const outside = isZoomLevelGoingOutOfBounds({
              d: matrix.a,
              scaleFactorMin: minZoom,
              scaleFactorMax: maxZoom
          }, step);
          if (!outside) {
              const newMatrix = transformationMatrix.smoothMatrix(transformationMatrix.transform(matrix, transformationMatrix.translate(x, y), transformationMatrix.scale(step, step), transformationMatrix.translate(-x, -y)), 100);
              this.rqf = requestAnimationFrame(() => {
                  onZoom({
                      scale: newMatrix.a,
                      x: newMatrix.e,
                      y: newMatrix.f,
                      nativeEvent
                  });
              });
          }
          return outside;
      }
      render() {
          const { style, children } = this.props;
          return (React__default['default'].createElement("g", { ref: this.childRef, style: style }, children));
      }
  }
  Zoom.defaultProps = {
      x: 0,
      y: 0,
      scale: 1,
      scaleFactor: 0.1,
      minZoom: 1,
      maxZoom: 10
  };

  var css_248z$q = ".DiscreteLegend-module_container__MpmKP {\n  display: flex;\n  overflow: auto;\n}\n\n  .DiscreteLegend-module_container__MpmKP.DiscreteLegend-module_horizontal__3Mt5B {\n    align-items: center;\n    flex-direction: row;\n  }\n\n  .DiscreteLegend-module_container__MpmKP.DiscreteLegend-module_vertical__M1d-S {\n    flex-direction: column;\n  }\n";
  var css$q = {"container":"DiscreteLegend-module_container__MpmKP","horizontal":"DiscreteLegend-module_horizontal__3Mt5B","vertical":"DiscreteLegend-module_vertical__M1d-S"};
  styleInject(css_248z$q);

  class DiscreteLegend extends React.Component {
      render() {
          const { entries, orientation, style } = this.props;
          const className = classNames__default['default'](css$q.container, this.props.className, {
              [css$q.horizontal]: orientation === 'horizontal',
              [css$q.vertical]: orientation === 'vertical'
          });
          return (React__default['default'].createElement("div", { className: className, style: style }, entries.map((entry, index) => (React__default['default'].createElement(rdk.CloneElement, { element: entry, key: `dle-${index}` })))));
      }
  }
  DiscreteLegend.defaultProps = {
      orientation: 'vertical'
  };

  var css_248z$p = ".DiscreteLegendSymbol-module_symbol__1n4Gb {\n  width: 15px;\n  height: 3px;\n}\n";
  var css$p = {"symbol":"DiscreteLegendSymbol-module_symbol__1n4Gb"};
  styleInject(css_248z$p);

  class DiscreteLegendSymbol extends React.PureComponent {
      render() {
          const { className, color } = this.props;
          return (React__default['default'].createElement("div", { className: classNames__default['default'](css$p.symbol, className), style: { background: color } }));
      }
  }
  DiscreteLegendSymbol.defaultProps = {};

  var css_248z$o = ".DiscreteLegendEntry-module_entry__2kjdn {\n  display: flex;\n  color: var(--color-on-primary);\n  padding: 8px;\n  will-change: transparency;\n  transition: opacity 150ms ease-in;\n}\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ {\n    flex-direction: column;\n    text-align: center;\n  }\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ:first-child {\n      padding-top: 0;\n    }\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ:last-child {\n      padding-bottom: 0;\n    }\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_vertical__2LxhZ svg {\n      display: block;\n      margin: 0 auto;\n    }\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv {\n    align-items: center;\n    flex-direction: row;\n  }\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv:first-child {\n      padding-left: 0;\n    }\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv:last-child {\n      padding-right: 0;\n    }\n\n  .DiscreteLegendEntry-module_entry__2kjdn.DiscreteLegendEntry-module_horizontal__37dGv .DiscreteLegendEntry-module_label__2e4-v {\n      margin-left: 8px;\n    }\n\n  .DiscreteLegendEntry-module_entry__2kjdn .DiscreteLegendEntry-module_label__2e4-v {\n    font-size: 12px;\n  }\n\n  .DiscreteLegendEntry-module_entry__2kjdn svg {\n    width: 15px;\n    height: 15px;\n  }\n";
  var css$o = {"entry":"DiscreteLegendEntry-module_entry__2kjdn","vertical":"DiscreteLegendEntry-module_vertical__2LxhZ","horizontal":"DiscreteLegendEntry-module_horizontal__37dGv","label":"DiscreteLegendEntry-module_label__2e4-v"};
  styleInject(css_248z$o);

  class DiscreteLegendEntry extends React.Component {
      render() {
          const { label, symbol, onMouseEnter, onMouseLeave, title, color, style, onClick, orientation } = this.props;
          const className = classNames__default['default'](css$o.entry, this.props.className, {
              [css$o.vertical]: orientation === 'vertical',
              [css$o.horizontal]: orientation === 'horizontal'
          });
          return (React__default['default'].createElement("div", { title: title, className: className, onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, style: style },
              React__default['default'].createElement(rdk.CloneElement, { element: symbol, color: color }),
              React__default['default'].createElement("span", { className: css$o.label }, label)));
      }
  }
  DiscreteLegendEntry.defaultProps = {
      symbol: React__default['default'].createElement(DiscreteLegendSymbol, null),
      orientation: 'horizontal',
      onMouseEnter: () => undefined,
      onMouseLeave: () => undefined,
      onClick: () => undefined
  };

  var css_248z$n = ".SequentialLegend-module_container__2EkZd {\n  display: flex;\n  height: 100%;\n}\n\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP {\n    flex-direction: column;\n    max-width: 55px;\n  }\n\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP .SequentialLegend-module_start__1Pb9A,\n    .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP .SequentialLegend-module_end__3RWw0 {\n      text-align: center;\n      padding: 5px 0;\n      width: 100%;\n    }\n\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_vertical__1DXNP .SequentialLegend-module_gradient__3aF0r {\n      width: 25px;\n      margin: 0 auto;\n    }\n\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA {\n    flex-direction: row-reverse;\n  }\n\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_start__1Pb9A,\n    .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_end__3RWw0 {\n      max-width: 20%;\n    }\n\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_start__1Pb9A {\n      text-align: right;\n      padding-left: 5px;\n    }\n\n  .SequentialLegend-module_container__2EkZd.SequentialLegend-module_horizontal__2Q9EA .SequentialLegend-module_end__3RWw0 {\n      text-align: left;\n      padding-right: 5px;\n    }\n\n  .SequentialLegend-module_container__2EkZd .SequentialLegend-module_gradient__3aF0r {\n    flex: 1;\n    width: 100%;\n    border-radius: 2px;\n  }\n\n  .SequentialLegend-module_container__2EkZd .SequentialLegend-module_start__1Pb9A,\n  .SequentialLegend-module_container__2EkZd .SequentialLegend-module_end__3RWw0 {\n    color: var(--color-on-primary);\n    font-size: 12px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n[dir=\"ltr\"] :export {\n  start-top: SequentialLegend-module_start__1Pb9A;\n  start-left: SequentialLegend-module_start__1Pb9A;\n}\n\n[dir=\"rtl\"] :export {\n  start-top: SequentialLegend-module_start__1Pb9A;\n  start-right: SequentialLegend-module_start__1Pb9A;\n}\n\n[dir=\"ltr\"] :export {\n  end-bottom: SequentialLegend-module_end__3RWw0;\n  end-right: SequentialLegend-module_end__3RWw0;\n}\n\n[dir=\"rtl\"] :export {\n  end-bottom: SequentialLegend-module_end__3RWw0;\n  end-left: SequentialLegend-module_end__3RWw0;\n}\n";
  var css$n = {"container":"SequentialLegend-module_container__2EkZd","vertical":"SequentialLegend-module_vertical__1DXNP","gradient":"SequentialLegend-module_gradient__3aF0r","horizontal":"SequentialLegend-module_horizontal__2Q9EA"};
  styleInject(css_248z$n);

  class SequentialLegend extends React.PureComponent {
      render() {
          const { orientation, className, style, colorScheme, data } = this.props;
          // Generate the color gradient
          const color = chroma__default['default']
              .scale(colorScheme)
              .colors(10)
              .reverse()
              .map((c, i) => `${c} ${i * 10}%`)
              .join(',');
          // Get the extent from the data passed
          const [end, start] = d3Array.extent(uniqueBy(data, (d) => d.data, (d) => d.data));
          // Get direction
          const gradientDir = orientation === 'vertical' ? '' : 'to left,';
          return (React__default['default'].createElement("div", { style: style, className: classNames__default['default'](css$n.container, className, {
                  [css$n.vertical]: orientation === 'vertical',
                  [css$n.horizontal]: orientation === 'horizontal'
              }) },
              React__default['default'].createElement("div", { className: css$n.start }, formatValue(start)),
              React__default['default'].createElement("div", { className: css$n.gradient, style: {
                      background: `linear-gradient(${gradientDir}${color})`
                  } }),
              React__default['default'].createElement("div", { className: css$n.end }, formatValue(end))));
      }
  }
  SequentialLegend.defaultProps = {
      colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],
      orientation: 'vertical'
  };

  var css_248z$m = ".Gridline-module_gridLine__1K6sy {\n  stroke-dasharray: 2 5;\n  shape-rendering: crispEdges;\n  pointer-events: none;\n}\n";
  var css$m = {"gridLine":"Gridline-module_gridLine__1K6sy"};
  styleInject(css_248z$m);

  const Gridline = ({ strokeWidth = 1, direction = 'all', strokeColor = 'rgba(153, 153, 153, 0.5)', data, height, width, scale, strokeDasharray }) => {
      const coords = React.useMemo(() => {
          const pos = scale(data);
          if (direction === 'x') {
              return {
                  x1: pos,
                  x2: pos,
                  y1: 0,
                  y2: height
              };
          }
          else {
              return {
                  y1: pos,
                  y2: pos,
                  x1: 0,
                  x2: width
              };
          }
      }, [direction, data, height, width, scale]);
      return (React__default['default'].createElement("line", Object.assign({}, coords, { className: css$m.gridLine, strokeDasharray: strokeDasharray, strokeWidth: strokeWidth, stroke: strokeColor, fill: "none" })));
  };

  class GridlineSeries extends React.Component {
      getGridlines() {
          const { yScale, xScale, yAxis, xAxis, height, width } = this.props;
          return {
              yAxisGrid: getTicks(yScale, yAxis.tickSeries.props.tickValues, yAxis.type, getMaxTicks(yAxis.tickSeries.props.tickSize, height), yAxis.tickSeries.props.interval),
              xAxisGrid: getTicks(xScale, xAxis.tickSeries.props.tickValues, xAxis.type, getMaxTicks(xAxis.tickSeries.props.tickSize, width), xAxis.tickSeries.props.interval)
          };
      }
      renderSeries(yAxisGrid, xAxisGrid, element, type) {
          const { xScale, yScale } = this.props;
          return (React__default['default'].createElement(React.Fragment, null,
              this.shouldRenderY(element.props.direction) &&
                  this.renderGroup(element, yAxisGrid, yScale, 'y', type),
              this.shouldRenderX(element.props.direction) &&
                  this.renderGroup(element, xAxisGrid, xScale, 'x', type)));
      }
      shouldRenderY(direction) {
          return direction === 'all' || direction === 'y';
      }
      shouldRenderX(direction) {
          return direction === 'all' || direction === 'x';
      }
      getSkipIndex(direction) {
          const { yAxis, xAxis } = this.props;
          if ((direction === 'x' &&
              yAxis.axisLine !== null &&
              yAxis.position === 'start') ||
              (direction === 'y' && xAxis.axisLine !== null && xAxis.position === 'end')) {
              return 0;
          }
          return null;
      }
      renderGroup(element, grid, scale, direction, type) {
          const { height, width } = this.props;
          const skipIdx = this.getSkipIndex(direction);
          return grid.map((point, index) => (React__default['default'].createElement(React.Fragment, { key: `${type}-${direction}-${index}` }, index !== skipIdx && (React__default['default'].createElement(rdk.CloneElement, { element: element, index: index, scale: scale, data: point, height: height, width: width, direction: direction })))));
      }
      render() {
          const { line, stripe } = this.props;
          const { yAxisGrid, xAxisGrid } = this.getGridlines();
          return (React__default['default'].createElement("g", { style: { pointerEvents: 'none' } },
              line && this.renderSeries(yAxisGrid, xAxisGrid, line, 'line'),
              stripe && this.renderSeries(yAxisGrid, xAxisGrid, stripe, 'stripe')));
      }
  }
  GridlineSeries.defaultProps = {
      line: React__default['default'].createElement(Gridline, { direction: "all" }),
      stripe: null
  };

  var css_248z$l = ".GridStripe-module_gridStripe__1UttV {\n  pointer-events: none;\n}\n";
  var css$l = {"gridStripe":"GridStripe-module_gridStripe__1UttV"};
  styleInject(css_248z$l);

  const GridStripe = ({ fill = '#393c3e', position, data, height, width, scale, index }) => {
      const coords = React.useMemo(() => {
          const pos = scale(data);
          const stripeFill = index % 2 ? 'none' : fill;
          const dim = scale.bandwidth();
          if (position === 'vertical') {
              return {
                  y: 0,
                  x: pos,
                  height: height,
                  width: dim,
                  fill: stripeFill
              };
          }
          else {
              return {
                  y: pos,
                  x: 0,
                  height: dim,
                  width,
                  fill: stripeFill
              };
          }
      }, [scale, data, index, height, width, fill, position]);
      return React__default['default'].createElement("rect", Object.assign({ className: css$l.gridStripe }, coords));
  };

  var css_248z$k = ".MarkLine-module_markLine__2002U {\n  pointer-events: none;\n  stroke-dasharray: 4, 4;\n  stroke-linecap: round;\n}\n";
  var css$k = {"markLine":"MarkLine-module_markLine__2002U"};
  styleInject(css_248z$k);

  const MarkLine = ({ pointX, height, strokeWidth = 1, strokeColor = '#eee' }) => (React__default['default'].createElement("line", { stroke: strokeColor, strokeWidth: strokeWidth, y1: "0", vectorEffect: "non-scaling-stroke", y2: height, x1: pointX, x2: pointX, className: css$k.markLine }));

  const GradientStop = ({ color, offset, stopOpacity = 1 }) => React__default['default'].createElement("stop", { offset: offset, stopOpacity: stopOpacity, stopColor: color });

  const Gradient = ({ id, color, direction = 'vertical', stops = [
      React__default['default'].createElement(GradientStop, { offset: "0%", stopOpacity: 0.3, key: "start" }),
      React__default['default'].createElement(GradientStop, { offset: "80%", stopOpacity: 1, key: "stop" })
  ] }) => {
      const pos = direction === 'vertical'
          ? {
              x1: '10%',
              x2: '10%',
              y1: '100%',
              y2: '0%'
          }
          : {
              y1: '0%',
              y2: '0%',
              x1: '0%',
              x2: '100%'
          };
      return (React__default['default'].createElement("linearGradient", Object.assign({ spreadMethod: "pad", id: id }, pos), stops.map((stop, index) => (React__default['default'].createElement(rdk.CloneElement, { element: stop, key: `gradient-${index}`, color: stop.props.color || color })))));
  };

  const RadialGradient = ({ id, color, radius = '30%', stops = [
      React__default['default'].createElement(GradientStop, { offset: "0%", stopOpacity: 0.2, key: "start" }),
      React__default['default'].createElement(GradientStop, { offset: "80%", stopOpacity: 0.7, key: "stop" })
  ] }) => (React__default['default'].createElement("radialGradient", { id: id, cx: 0, cy: 0, r: radius, gradientUnits: "userSpaceOnUse" }, stops.map((stop, index) => (React__default['default'].createElement(rdk.CloneElement, { element: stop, key: `gradient-${index}`, color: color })))));

  class Mask extends React.PureComponent {
      render() {
          const { id, fill } = this.props;
          return (React__default['default'].createElement("mask", { id: id },
              React__default['default'].createElement("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: fill })));
      }
  }

  class Stripes extends React.PureComponent {
      render() {
          const { id, fill } = this.props;
          return (React__default['default'].createElement("pattern", { id: id, width: "4", height: "4", patternUnits: "userSpaceOnUse", patternTransform: "rotate(45)" },
              React__default['default'].createElement("rect", { className: "area-stripe", width: "1", height: "4", fill: fill })));
      }
  }
  Stripes.defaultProps = {};

  var css_248z$j = ".TooltipTemplate-module_label__1-9Eq {\n  font-size: 16px;\n  margin-bottom: 3px;\n  color: var(--color-on-background);\n}\n\n.TooltipTemplate-module_value__3RhFW {\n  font-size: 13px;\n  color: var(--color-on-background);\n  opacity: 0.7;\n}\n\n.TooltipTemplate-module_subValue__2jKhI {\n  display: block;\n  text-align: left;\n  padding: 3px 5px;\n}\n\n.TooltipTemplate-module_subValue__2jKhI .TooltipTemplate-module_subValueColor__2Mkos {\n    width: 5px;\n    height: 15px;\n    margin-right: 8px;\n    display: inline-block;\n  }\n\n.TooltipTemplate-module_subValue__2jKhI .TooltipTemplate-module_subValueName__MtlOy {\n    margin-right: 5px;\n  }\n";
  var css$j = {"label":"TooltipTemplate-module_label__1-9Eq","value":"TooltipTemplate-module_value__3RhFW","subValue":"TooltipTemplate-module_subValue__2jKhI","subValueColor":"TooltipTemplate-module_subValueColor__2Mkos","subValueName":"TooltipTemplate-module_subValueName__MtlOy"};
  styleInject(css_248z$j);

  const TooltipTemplate = ({ value, color, className }) => {
      if (!value) {
          return null;
      }
      const renderValues = (data, index) => {
          const fill = color(data, index);
          return (React__default['default'].createElement("span", { className: css$j.subValue },
              React__default['default'].createElement("span", { className: css$j.subValueColor, style: { backgroundColor: fill } }),
              React__default['default'].createElement("span", { className: css$j.subValueName },
                  formatValue(data.key || data.x),
                  ":"),
              React__default['default'].createElement("span", null, formatValue(data.value || data.y))));
      };
      const renderMultiple = (value) => {
          const excessCount = value.data.length - 15;
          const pagedValues = value.data.slice(0, 15);
          return (React__default['default'].createElement(React.Fragment, null,
              pagedValues.map((point, i) => (React__default['default'].createElement(React.Fragment, { key: i }, renderValues(point, i)))),
              excessCount > 0 && React__default['default'].createElement("div", null,
                  "...",
                  excessCount,
                  " more...")));
      };
      const isMultiple = Array.isArray(value.data);
      return (React__default['default'].createElement("div", { className: className, role: "tooltip" },
          React__default['default'].createElement("div", { className: css$j.label }, formatValue(value.x)),
          React__default['default'].createElement("div", { className: css$j.value },
              isMultiple && renderMultiple(value),
              !isMultiple && (React__default['default'].createElement(React.Fragment, null, formatValue(value.value ||
                  value.y))))));
  };

  const ChartTooltip = (_a) => {
      var { content = React__default['default'].createElement(TooltipTemplate, null), value, data, color } = _a, rest = __rest(_a, ["content", "value", "data", "color"]);
      return (React__default['default'].createElement(realayers.Tooltip, Object.assign({}, rest, { content: () => {
              if (!value && !data) {
                  return null;
              }
              return typeof content === 'function'
                  ? content(data || value, color)
                  : React.cloneElement(content, Object.assign(Object.assign({}, content.props), { value,
                      color }));
          } })));
  };

  class TooltipArea extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {};
          this.ref = React.createRef();
          this.transformData = memoize__default['default']((series) => {
              const { inverse, isHorizontal } = this.props;
              const result = [];
              if (inverse) {
                  for (const point of series) {
                      const seriesPoint = point;
                      if (Array.isArray(seriesPoint.data)) {
                          for (const nestedPoint of seriesPoint.data) {
                              const right = nestedPoint.x;
                              let idx = result.findIndex((r) => {
                                  const left = r.x;
                                  if (left instanceof Date && right instanceof Date) {
                                      return left.getTime() === right.getTime();
                                  }
                                  return left === right;
                              });
                              if (idx === -1) {
                                  result.push({
                                      x: nestedPoint.x,
                                      data: []
                                  });
                                  idx = result.length - 1;
                              }
                              const data = result[idx].data;
                              if (Array.isArray(data)) {
                                  data.push(nestedPoint);
                              }
                          }
                      }
                      else {
                          result.push(point);
                      }
                  }
              }
              else {
                  for (const point of series) {
                      const nestedPoint = point;
                      if (Array.isArray(nestedPoint.data)) {
                          result.push(Object.assign(Object.assign({}, nestedPoint), { x: nestedPoint.key, data: nestedPoint.data.map((d) => (Object.assign(Object.assign({}, d), { key: !isHorizontal ? d.x : d.y, value: !isHorizontal ? d.y : d.x }))) }));
                      }
                      else {
                          const shallowPoint = point;
                          result.push(Object.assign(Object.assign({}, shallowPoint), { 
                              // Histograms special logic...
                              x: shallowPoint.key === undefined ? shallowPoint.x0 : point.key, y: shallowPoint.value === undefined
                                  ? shallowPoint.y
                                  : shallowPoint.value }));
                      }
                  }
              }
              return result;
          });
      }
      getXCoord(x, y) {
          const { isRadial, width, height } = this.props;
          // If the shape is radial, we need to convert the X coords to a radial format.
          if (isRadial) {
              const outerRadius = Math.min(width, height) / 2;
              let rad = Math.atan2(y - outerRadius, x - outerRadius) + Math.PI / 2;
              // TODO: Figure out what the 'correct' way to do this is...
              if (rad < 0) {
                  rad += Math.PI * 2;
              }
              return rad;
          }
          return x;
      }
      onMouseMove(event) {
          const { xScale, yScale, onValueEnter, height, width, data, isRadial, isHorizontal, placement } = this.props;
          const { value } = this.state;
          const transformed = this.transformData(data);
          // Get our default placement
          let newPlacement = placement;
          if (!placement) {
              if (isHorizontal) {
                  newPlacement = 'right';
              }
              else {
                  newPlacement = 'top';
              }
          }
          // Get the path container element
          let target = this.ref.current;
          const { y, x } = getPositionForTarget({
              target: target,
              // Manually pass the x/y from the event
              clientX: event.clientX,
              clientY: event.clientY
          });
          // Need to flip scales/coords if we are a horz layout
          let keyScale;
          let valueScale;
          let coord;
          if (isHorizontal) {
              keyScale = yScale;
              valueScale = xScale;
              coord = y;
          }
          else {
              coord = this.getXCoord(x, y);
              keyScale = xScale;
              valueScale = yScale;
          }
          const newValue = getClosestPoint(coord, keyScale, transformed);
          if (!isEqual__default['default'](newValue, value) && newValue) {
              const pointX = keyScale(newValue.x);
              let pointY = valueScale(newValue.y);
              let marginX = 0;
              let marginY = 0;
              if (isNaN(pointY)) {
                  pointY = height / 2;
                  marginX = 10;
                  if (!placement) {
                      newPlacement = 'right';
                  }
              }
              else {
                  marginY = -10;
              }
              // If the points didn't change, don't trigger an update
              if (pointX === this.prevX && pointY === this.prevY) {
                  return;
              }
              this.prevY = pointY;
              this.prevX = pointX;
              const target = event.target;
              const { top, left } = target.getBoundingClientRect();
              let offsetX = 0;
              let offsetY = 0;
              if (isRadial) {
                  // If its radial, we need to convert the coords to radial format
                  const outerRadius = Math.min(width, height) / 2;
                  offsetX = pointY * Math.cos(pointX - Math.PI / 2) + outerRadius;
                  offsetY = pointY * Math.sin(pointX - Math.PI / 2) + outerRadius;
              }
              else {
                  offsetX = pointX;
                  offsetY = pointY;
              }
              offsetX += left + marginX;
              offsetY += top + marginY;
              this.setState({
                  placement: newPlacement,
                  visible: true,
                  value: newValue,
                  offsetX,
                  offsetY
              });
              onValueEnter({
                  visible: true,
                  value: newValue,
                  pointY,
                  pointX,
                  offsetX,
                  offsetY,
                  nativeEvent: event
              });
          }
      }
      onMouseLeave() {
          this.prevX = undefined;
          this.prevY = undefined;
          this.setState({
              value: undefined,
              visible: false
          });
          this.props.onValueLeave();
      }
      getTooltipReference() {
          const { offsetX, offsetY } = this.state;
          return {
              width: 4,
              height: 4,
              top: offsetY,
              left: offsetX
          };
      }
      renderRadial() {
          let { height, width, innerRadius, outerRadius } = this.props;
          innerRadius = innerRadius || 0;
          outerRadius = outerRadius || Math.min(width, height) / 2;
          const d = d3Shape.arc()({
              innerRadius,
              outerRadius,
              startAngle: 180,
              endAngle: Math.PI / 2
          });
          return (React__default['default'].createElement("path", { d: d, opacity: "0", cursor: "auto", ref: this.ref, onMouseMove: bind__default['default'](this.onMouseMove, this) }));
      }
      renderLinear() {
          const { height, width } = this.props;
          return (React__default['default'].createElement("rect", { height: height, ref: this.ref, width: width, opacity: 0, cursor: "auto", onMouseMove: bind__default['default'](this.onMouseMove, this) }));
      }
      render() {
          const { isRadial, children, tooltip, disabled, color } = this.props;
          const { visible, placement, value } = this.state;
          return (React__default['default'].createElement(React.Fragment, null,
              disabled && children,
              !disabled && (React__default['default'].createElement("g", { onMouseLeave: bind__default['default'](this.onMouseLeave, this) },
                  isRadial && this.renderRadial(),
                  !isRadial && this.renderLinear(),
                  React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: visible, placement: placement, modifiers: {
                          offset: {
                              offset: '0, 15px'
                          }
                      }, reference: this.getTooltipReference(), color: color, value: value }),
                  children))));
      }
  }
  TooltipArea.defaultProps = {
      isRadial: false,
      tooltip: React__default['default'].createElement(ChartTooltip, null),
      inverse: true,
      onValueEnter: () => undefined,
      onValueLeave: () => undefined
  };

  /**
   * Gets the min/max values handling nested arrays.
   */
  function extent(data, attr) {
      const accessor = (val, fn) => {
          if (Array.isArray(val.data)) {
              return fn(val.data, (vv) => vv[attr]);
          }
          return val[attr];
      };
      const minVal = d3Array.min(data, (d) => accessor(d, d3Array.min));
      const maxVal = d3Array.max(data, (d) => accessor(d, d3Array.max));
      return [minVal, maxVal];
  }
  /**
   * Get the domain for the Y Axis.
   */
  function getYDomain({ data, scaled = false, isDiverging = false }) {
      const [startY, endY] = extent(data, 'y');
      const [startY1, endY1] = extent(data, 'y1');
      // If dealing w/ negative numbers, we should
      // normalize the top and bottom values
      if (startY < 0 || isDiverging) {
          const posStart = -startY;
          const maxNum = Math.max(posStart, endY);
          return [-maxNum, maxNum];
      }
      // Scaled start scale at non-zero
      if (scaled) {
          return [startY1, endY1];
      }
      // Start at 0 based
      return [0, endY1];
  }
  /**
   * Get the domain for the X Axis.
   */
  function getXDomain({ data, scaled = false, isDiverging = false }) {
      const startX0 = extent(data, 'x0')[0];
      const endX1 = extent(data, 'x1')[1];
      // Histograms use dates for start/end
      if (typeof startX0 === 'number' && typeof endX1 === 'number') {
          // If dealing w/ negative numbers, we should
          // normalize the top and bottom values
          if (startX0 < 0 || isDiverging) {
              const posStart = -startX0;
              const maxNum = Math.max(posStart, endX1);
              return [-maxNum, maxNum];
          }
          // If not scaled, return 0/max domains
          if (!scaled) {
              return [0, endX1];
          }
      }
      // Scaled start scale at non-zero
      return [startX0, endX1];
  }

  /**
   * Helper function for interpolation.
   */
  function interpolate(type) {
      if (type === 'smooth') {
          return d3Shape.curveMonotoneX;
      }
      else if (type === 'step') {
          return d3Shape.curveStep;
      }
      else {
          return d3Shape.curveLinear;
      }
  }

  /**
   * Calculates whether the stroke should be shown.
   */
  function calculateShowStroke(current, data) {
      const i = data.indexOf(current);
      let showLine = false;
      const prev = data[i - 1];
      if (i > 0 && prev.y) {
          showLine = true;
      }
      const cur = data[i];
      if (cur.y) {
          showLine = true;
      }
      const next = data[i + 1];
      if (i < data.length - 1 && next.y) {
          showLine = true;
      }
      return showLine;
  }

  /**
   * Get the angle from a radian.
   */
  const getDegrees = (radians) => (radians / Math.PI) * 180 - 90;

  const functionProps = (prop, val, data) => {
      if (typeof val === 'function') {
          return val(data);
      }
      else if (prop === 'className') {
          return classNames__default['default'](val);
      }
      else if (val !== undefined || val !== null) {
          return val;
      }
      return {};
  };
  const constructFunctionProps = (props, data) => ({
      className: functionProps('className', props.className, data),
      style: functionProps('style', props.style, data)
  });

  function wrapText({ key, x = 0, width, fontFamily, fontSize }) {
      const size = calculateDimensions(key, fontFamily, fontSize);
      if (size.width > width) {
          const words = key.split(/\s+/);
          const rows = [];
          let sum = 0;
          let curText = '';
          let lineNum = 0;
          for (const word of words) {
              const wordSize = calculateDimensions(word, fontFamily, fontSize);
              const wordWidth = wordSize.width;
              lineNum++;
              if (sum + wordWidth < width) {
                  sum += wordWidth;
                  curText = `${curText} ${word}`;
              }
              else {
                  rows.push(curText);
                  sum = 0;
                  curText = word;
              }
              if (words.length === lineNum) {
                  rows.push(curText);
              }
          }
          return rows.map((r, i) => (React__default['default'].createElement("tspan", { key: i, dominantBaseline: "alphabetic", style: { baselineShift: '0%' }, dy: i > 0 ? size.height : -size.height / 2, x: x }, r)));
      }
      return key;
  }

  class ZoomPan extends React.Component {
      constructor() {
          super(...arguments);
          this.zoomRef = React.createRef();
          this.panRef = React.createRef();
          this.state = {
              isZooming: false,
              isPanning: false,
              matrix: transformationMatrix.identity()
          };
      }
      static getDerivedStateFromProps(props, state) {
          // TODO: the types in the library don't seem to be correct...
          const matrix = transformationMatrix.transform(transformationMatrix.fromDefinition([
              { type: 'translate', tx: props.x, ty: props.y },
              { type: 'scale', sx: props.scale, sy: props.scale }
          ]));
          if (!isEqual__default['default'](matrix, state.matrix)) {
              return {
                  matrix
              };
          }
          return null;
      }
      onPanStart(event) {
          this.setState({
              isPanning: true
          });
          this.props.onPanStart(event);
      }
      onPanMove(event) {
          this.props.onZoomPan({
              scale: this.props.scale,
              x: event.x,
              y: event.y,
              type: 'pan',
              nativeEvent: event.nativeEvent
          });
          this.props.onPanMove(event);
      }
      onPanEnd(event) {
          this.setState({ isPanning: false });
          this.props.onPanEnd(event);
      }
      onZoom(event) {
          this.props.onZoomPan({
              x: event.x,
              y: event.y,
              scale: event.scale,
              nativeEvent: event.nativeEvent,
              type: 'zoom'
          });
          this.props.onZoom(event);
      }
      onZoomEnd() {
          this.setState({
              isZooming: false
          });
          this.props.onZoomEnd();
      }
      render() {
          const { height, width, children, disabled, pannable, maxZoom, minZoom, zoomable, scale, x, y, disableMouseWheel, constrain, zoomStep, onPanCancel, requireZoomModifier, globalPanning } = this.props;
          const { isZooming, isPanning } = this.state;
          const cursor = pannable ? 'move' : 'auto';
          const selection = isZooming || isPanning ? 'none' : 'auto';
          const matrix = transformationMatrix.fromObject(this.state.matrix);
          return (React__default['default'].createElement(Pan, { x: x, y: y, scale: scale, matrix: matrix, constrain: constrain, height: height, width: width, disabled: !pannable || disabled, ref: this.panRef, globalPanning: globalPanning, onPanStart: bind__default['default'](this.onPanStart, this), onPanMove: bind__default['default'](this.onPanMove, this), onPanEnd: bind__default['default'](this.onPanEnd, this), onPanCancel: onPanCancel },
              React__default['default'].createElement(Zoom, { ref: this.zoomRef, disabled: !zoomable || disabled, scaleFactor: zoomStep, disableMouseWheel: disableMouseWheel, maxZoom: maxZoom, minZoom: minZoom, scale: scale, x: x, y: y, style: { cursor }, requireZoomModifier: requireZoomModifier, matrix: matrix, onZoom: bind__default['default'](this.onZoom, this), onZoomEnd: bind__default['default'](this.onZoomEnd, this) },
                  !disabled && (React__default['default'].createElement("rect", { height: height, width: width, opacity: 0, className: "pan-container" })),
                  React__default['default'].createElement("g", { style: {
                          pointerEvents: selection,
                          userSelect: selection
                      } }, children))));
      }
  }
  ZoomPan.defaultProps = {
      maxZoom: 10,
      minZoom: 0,
      zoomStep: 0.1,
      pannable: true,
      zoomable: true,
      constrain: true,
      height: 0,
      width: 0,
      x: 0,
      y: 0,
      scale: 1,
      globalPanning: true,
      onPanStart: () => undefined,
      onPanMove: () => undefined,
      onPanEnd: () => undefined,
      onPanCancel: () => undefined,
      onZoom: () => undefined,
      onZoomEnd: () => undefined
  };

  /**
   * Gets the X Scale function.
   */
  function getXScale({ type, roundDomains, data, width, domain, padding, scaled, isMultiSeries = false, isDiverging = false }) {
      let scale;
      if (type === 'time' || type === 'duration' || type === 'value') {
          if (type === 'time') {
              scale = d3Scale.scaleTime().rangeRound([0, width]);
          }
          else {
              scale = d3Scale.scaleLinear().rangeRound([0, width]);
          }
          scale = scale.domain(domain || getXDomain({ data, scaled, isDiverging }));
      }
      else {
          if (!domain) {
              if (isMultiSeries) {
                  domain = uniqueBy(data, (d) => d.key);
              }
              else {
                  domain = uniqueBy(data, (d) => d.x);
              }
          }
          scale = d3Scale.scaleBand()
              .rangeRound([0, width])
              .padding(padding || 0)
              .domain(domain);
      }
      return roundDomains ? scale.nice() : scale;
  }
  /**
   * Gets the Y Scale function.
   */
  function getYScale({ type, height, data, domain, roundDomains = false, scaled = false, padding = 0, isMultiSeries = false, isDiverging = false }) {
      let scale;
      if (type === 'time' || type === 'value' || type === 'duration') {
          scale = d3Scale.scaleLinear()
              .range([height, 0])
              .domain(domain || getYDomain({ data, scaled, isDiverging }));
      }
      else {
          if (!domain) {
              if (isMultiSeries) {
                  domain = uniqueBy(data, (d) => d.key);
              }
              else {
                  domain = uniqueBy(data, (d) => d.y);
              }
          }
          scale = d3Scale.scaleBand()
              .rangeRound([height, 0])
              .padding(padding)
              .domain(domain);
      }
      return roundDomains ? scale.nice() : scale;
  }

  /**
   * Get a linear scale for the mariemko chart.
   */
  const getMarimekkoScale = (width, roundDomains) => {
      const scale = d3Scale.scaleLinear().rangeRound([0, width]);
      return roundDomains ? scale.nice() : scale;
  };
  /**
   * Builds a fake scale function to get a group scale for a marimekko value scale.
   */
  const getMarimekkoGroupScale = ({ data, width, valueScale, padding }) => {
      const domain = uniqueBy(data, (d) => d.key);
      const barCount = data.length;
      const widthMinusPadding = width - padding * (barCount - 1);
      const xMultiplier = widthMinusPadding / width;
      // Given a data series, find the x0/x1 for it.
      const getXRange = (series) => {
          const [val] = series.data;
          const x0 = valueScale(val.x0);
          const x1 = valueScale(val.x1);
          return { x0, x1 };
      };
      const scale = (arg) => {
          let result = 0;
          const index = data.findIndex((d) => d.key === arg);
          const series = data[index];
          if (series && series.data && series.data.length) {
              const { x1, x0 } = getXRange(series);
              result = (x1 - x0) / 2 + x0;
              if (padding) {
                  result = result * xMultiplier + index * padding;
              }
          }
          return result;
      };
      scale.range = () => [0, width];
      scale.domain = () => domain;
      // Special invert function for marimekko
      scale.mariemkoInvert = (offset) => {
          let found;
          for (let i = 0; i < domain.length; i++) {
              const attr = domain[i];
              const series = data[i];
              const { x1, x0 } = getXRange(series);
              if (offset >= x0 - padding / 2 && offset <= x1 - padding / 2) {
                  found = attr;
                  break;
              }
          }
          return found;
      };
      return scale;
  };

  /**
   * Get the group scale aka x0.
   */
  function getGroupScale({ dimension, padding, data, direction = 'vertical' }) {
      const domain = uniqueBy(data, (d) => d.key);
      const spacing = domain.length / (dimension / padding + 1);
      const range = direction === 'vertical' ? [0, dimension] : [dimension, 0];
      return d3Scale.scaleBand()
          .rangeRound(range)
          .paddingInner(spacing)
          .paddingOuter(spacing / 2)
          .domain(domain);
  }
  /**
   * Get the inner scale aka x1.
   */
  function getInnerScale({ groupScale, padding, data, prop = 'x' }) {
      const dimension = groupScale.bandwidth();
      const domain = uniqueBy(data, (d) => d.data, (d) => d[prop]);
      const spacing = domain.length / (dimension / padding + 1);
      return d3Scale.scaleBand()
          .rangeRound([0, dimension])
          .paddingInner(spacing)
          .domain(domain);
  }

  /**
   * Get the Y Scale for a given set of radiuses.
   * Reference: https://github.com/d3/d3-scale/issues/90
   */
  const getRadialYScale = (innerRadius, outerRadius, domain) => {
      if (domain[0] === 0 && domain[1] === 0) {
          // If all values are 0, set the domain to [0, 1], so the zero values are
          // all at the bottom of the chart, not the middle.
          domain = [0, 1];
      }
      const y = d3Scale.scaleLinear()
          .range([innerRadius * innerRadius, outerRadius * outerRadius])
          .domain(domain);
      const yScale = Object.assign((d) => Math.sqrt(y(d)), y);
      return yScale;
  };

  class ChartZoomPan extends React.Component {
      onZoomPan(event) {
          const { width, data, axisType, roundDomains, onZoomPan } = this.props;
          const can = event.type === 'zoom' || (event.type === 'pan' && event.scale > 1);
          if (can) {
              const scale = getXScale({
                  width: width,
                  type: axisType,
                  roundDomains,
                  data
              });
              const newScale = scale.copy().domain(scale
                  .range()
                  .map((x) => (x - event.x) / event.scale)
                  .map(scale.clamp(true).invert, event.x));
              onZoomPan({
                  domain: newScale.domain(),
                  isZoomed: event.scale !== 1
              });
          }
      }
      getOffset() {
          let zoomOffset = {
              scale: undefined,
              x: undefined
          };
          const { disabled, domain, width, data, axisType, roundDomains } = this.props;
          if (!disabled && domain) {
              const xScale = getXScale({
                  width,
                  type: axisType,
                  roundDomains,
                  data
              });
              let offset = xScale(domain[0]);
              const endOffset = xScale(domain[1]);
              const scale = width / (endOffset - offset);
              // Apply the new scale to the offset so its scaled correctly
              offset = offset * scale;
              zoomOffset = {
                  scale: scale,
                  x: -offset
              };
          }
          return zoomOffset;
      }
      render() {
          const _a = this.props, { data, height, children, width, onZoomPan } = _a, rest = __rest(_a, ["data", "height", "children", "width", "onZoomPan"]);
          const { scale, x } = this.getOffset();
          return (React__default['default'].createElement(ZoomPan, Object.assign({}, rest, { scale: scale, x: x, height: height, width: width, pannable: scale > 1, onZoomPan: bind__default['default'](this.onZoomPan, this) }), children));
      }
  }
  ChartZoomPan.defaultProps = {
      onZoomPan: () => undefined
  };

  const DEFAULT_TRANSITION = {
      type: 'spring',
      velocity: 5,
      damping: 20
  };

  const MotionPath = (_a) => {
      var { custom, transition } = _a, rest = __rest(_a, ["custom", "transition"]);
      const d = framerMotion.useMotionValue(custom.exit.d);
      const prevPath = framerMotion.useMotionValue(custom.exit.d);
      const spring = framerMotion.useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), { from: 0, to: 1 }));
      React.useEffect(() => {
          const interpolator = d3Interpolate.interpolate(prevPath.get(), custom.enter.d);
          const unsub = spring.onChange((v) => d.set(interpolator(v)));
          prevPath.set(custom.enter.d);
          return unsub;
      });
      const _b = custom.enter, { d: enterD } = _b, enterRest = __rest(_b, ["d"]);
      const _c = custom.exit, exitRest = __rest(_c, ["d"]);
      return (React__default['default'].createElement(framerMotion.motion.path, Object.assign({}, rest, { initial: exitRest, exit: exitRest, animate: enterRest, transition: transition, d: transition.type !== false ? d : enterD })));
  };

  /**
   * Color Schemes
   * Credits: https://gka.github.io/chroma.js/#chroma-brewer
   */
  const schemes = Object.assign({ cybertron: chroma__default['default'].scale(['#2d60e8', '#26efb5']).correctLightness().colors(8) }, chroma__default['default'].brewer);

  /**
   * Given a point, get the key attributes for it.
   */
  const rangeHelper = (point, attribute) => point.map((r, i) => {
      if (r) {
          if (r[attribute] !== undefined) {
              return r[attribute];
          }
          else if (r.data && r.data[attribute] !== undefined) {
              return r.data[attribute];
          }
      }
      return i;
  });
  /**
   * Get a color given a range.
   */
  const getColor = (props) => {
      let { point, colorScheme, attribute, index, data, active, isMultiSeries, domain, key, scale } = Object.assign({ attribute: 'key', isMultiSeries: false, scale: d3Scale.scaleOrdinal }, props);
      if (typeof colorScheme === 'string' && schemes[colorScheme]) {
          colorScheme = schemes[colorScheme];
      }
      if (Array.isArray(colorScheme)) {
          if (!domain) {
              if (isMultiSeries && Array.isArray(data)) {
                  const maxIdx = d3Array.maxIndex(data, (d) => d.data.length);
                  const maxVal = data[maxIdx];
                  data = maxVal.data;
              }
              domain = rangeHelper(data, attribute);
          }
          key = key !== undefined ? key : point[attribute];
          return scale(colorScheme).domain(domain)(key);
      }
      else if (typeof colorScheme === 'function') {
          return colorScheme(point, index, active);
      }
      else {
          return colorScheme;
      }
  };

  var css_248z$i = ".ScatterPoint-module_inactive__3ahvT {\n  opacity: 0.2;\n}\n";
  var css$i = {"inactive":"ScatterPoint-module_inactive__3ahvT"};
  styleInject(css_248z$i);

  const ScatterPoint = (_a) => {
      var { symbol, index, id, data, xScale, yScale, active = true, tooltip = React__default['default'].createElement(ChartTooltip, null), cursor = 'pointer', size = 4, color = schemes.cybertron[0], animated = true, onClick = () => undefined, onMouseEnter = () => undefined, onMouseLeave = () => undefined } = _a, rest = __rest(_a, ["symbol", "index", "id", "data", "xScale", "yScale", "active", "tooltip", "cursor", "size", "color", "animated", "onClick", "onMouseEnter", "onMouseLeave"]);
      const rectRef = React.useRef(null);
      const [tooltipVisible, setTooltipVisible] = React.useState(false);
      const extras = React.useMemo(() => constructFunctionProps(rest, data), [
          rest,
          data
      ]);
      const r = React.useMemo(() => (typeof size === 'function' ? size(data) : size), [
          size,
          data
      ]);
      const renderedSymbol = React.useMemo(() => (symbol ? symbol(data) : null), [
          data,
          symbol
      ]);
      const transitionProps = React.useMemo(() => animated
          ? Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: index * 0.005 }) : {
          type: false,
          delay: 0
      }, [index, animated]);
      const enterProps = React.useMemo(() => {
          let cy = yScale(data.y1);
          if (yScale.bandwidth) {
              const width = yScale.bandwidth();
              cy = cy + width / 2;
          }
          return {
              x: xScale(data.x),
              y: cy
          };
      }, [data, yScale]);
      const exitProps = React.useMemo(() => {
          const [yStartDomain] = yScale.domain();
          return {
              y: yScale(yStartDomain),
              x: xScale(data.x)
          };
      }, [data, yScale]);
      const fill = React.useMemo(() => getColor({
          colorScheme: color,
          index,
          point: data
      }), [data, color, index]);
      return (React__default['default'].createElement(React.Fragment, null,
          React__default['default'].createElement("g", { ref: rectRef, onMouseEnter: () => {
                  setTooltipVisible(true);
                  onMouseEnter(data);
              }, onMouseLeave: () => {
                  setTooltipVisible(false);
                  onMouseLeave(data);
              }, onClick: () => onClick(data), className: classNames__default['default']({
                  [css$i.inactive]: !active
              }) }, symbol ? (React__default['default'].createElement(framerMotion.motion.g, Object.assign({ key: `symbol-${id}-${data.id}` }, extras, { initial: {
                  translateX: exitProps.x,
                  translateY: exitProps.y,
                  opacity: 0
              }, animate: {
                  translateX: enterProps.x,
                  translateY: enterProps.y,
                  opacity: 1
              }, exit: {
                  translateX: exitProps.x,
                  translateY: exitProps.y,
                  opacity: 0
              }, transition: transitionProps }), renderedSymbol)) : (React__default['default'].createElement(framerMotion.motion.circle, { key: `symbol-${id}-${data.id}`, className: extras.className, style: Object.assign(Object.assign({}, extras.style), { cursor }), initial: {
                  cx: exitProps.x,
                  cy: exitProps.y,
                  fill,
                  r,
                  opacity: 0
              }, animate: {
                  cx: enterProps.x,
                  cy: enterProps.y,
                  opacity: 1,
                  fill,
                  r
              }, exit: {
                  cx: exitProps.x,
                  cy: exitProps.y,
                  fill,
                  r,
                  opacity: 0
              }, transition: transitionProps }))),
          tooltip && !tooltip.props.disabled && (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: tooltipVisible, reference: rectRef, value: data }))));
  };

  // For bubble charts, often symbols exceed the area
  // and we want to add a little bit of padding to prevent clipping
  const PADDING$1 = 25;
  const HALF_PADDING$1 = PADDING$1 / 2;
  const ScatterSeries = (_a) => {
      var { data, height, width, id, isZoomed, activeIds, point = React__default['default'].createElement(ScatterPoint, null) } = _a, rest = __rest(_a, ["data", "height", "width", "id", "isZoomed", "activeIds", "point"]);
      const renderPoint = React.useCallback((pointData, index) => {
          let pointId;
          if (pointData.id) {
              pointId = pointData.id;
          }
          const key = pointId || index;
          const active = !(activeIds && activeIds.length) || activeIds.includes(pointId);
          const visible = point.props.visible;
          if (visible && !visible(pointData, index)) {
              return React__default['default'].createElement(React.Fragment, { key: key });
          }
          return (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: point, key: key }, rest, { id: id, data: pointData, index: index, active: active })));
      }, [point, id, rest, activeIds]);
      return (React__default['default'].createElement(React.Fragment, null,
          React__default['default'].createElement("defs", null,
              React__default['default'].createElement("clipPath", { id: `${id}-path` },
                  React__default['default'].createElement("rect", { width: isZoomed ? width : width + PADDING$1, height: height + PADDING$1, x: isZoomed ? 0 : -HALF_PADDING$1, y: -HALF_PADDING$1 }))),
          React__default['default'].createElement("g", { clipPath: `url(#${id}-path)` }, data.map(renderPoint))));
  };

  var css_248z$h = ".ScatterPlot-module_scatterPlot__1gWRV {\n  overflow: visible;\n}\n";
  var css$h = {"scatterPlot":"ScatterPlot-module_scatterPlot__1gWRV"};
  styleInject(css_248z$h);

  class ScatterPlot extends React.Component {
      constructor(props) {
          super(props);
          this.getData = memoize__default['default']((data) => {
              return buildShallowChartData(data);
          });
          const zoom = props.zoomPan ? props.zoomPan.props : { domain: undefined };
          // eslint-disable-next-line no-prototype-builtins
          const zoomControlled = !zoom.hasOwnProperty('domain');
          this.state = {
              isZoomed: !!zoom.domain,
              zoomDomain: zoom.domain,
              zoomControlled
          };
      }
      static getDerivedStateFromProps(props, state) {
          if (props.zoomPan) {
              const zoom = props.zoomPan.props;
              if (!state.zoomControlled && zoom.domain !== state.zoomDomain) {
                  return {
                      zoomDomain: zoom.domain,
                      isZoomed: !!zoom.domain
                  };
              }
          }
          return null;
      }
      getScales(data, chartHeight, chartWidth) {
          const { xAxis, yAxis } = this.props;
          const { zoomDomain } = this.state;
          const yScale = getYScale({
              roundDomains: yAxis.props.roundDomains,
              type: yAxis.props.type,
              height: chartHeight,
              data,
              domain: yAxis.props.domain
          });
          const xScale = getXScale({
              width: chartWidth,
              type: xAxis.props.type,
              roundDomains: xAxis.props.roundDomains,
              data,
              domain: zoomDomain || xAxis.props.domain
          });
          return {
              data,
              yScale,
              xScale
          };
      }
      onZoomPan(event) {
          if (this.state.zoomControlled) {
              this.setState({
                  zoomDomain: event.domain,
                  isZoomed: event.isZoomed,
                  preventAnimation: true
              });
              clearTimeout(this.timeout);
              this.timeout = setTimeout(() => this.setState({ preventAnimation: false }), 500);
          }
      }
      renderChart(containerProps) {
          const { chartHeight, chartWidth, id, updateAxes } = containerProps;
          const { series, xAxis, yAxis, gridlines, brush, zoomPan, secondaryAxis } = this.props;
          const { isZoomed, zoomDomain, preventAnimation } = this.state;
          const data = this.getData(this.props.data);
          const { yScale, xScale } = this.getScales(data, chartHeight, chartWidth);
          const animated = preventAnimation === true ? false : series.props.animated;
          return (React__default['default'].createElement(React.Fragment, null,
              containerProps.chartSized && gridlines && (React__default['default'].createElement(rdk.CloneElement, { element: gridlines, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, yAxis: yAxis.props, xAxis: xAxis.props })),
              React__default['default'].createElement(rdk.CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: bind__default['default'](updateAxes, this, 'horizontal') }),
              React__default['default'].createElement(rdk.CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: bind__default['default'](updateAxes, this, 'vertical') }),
              secondaryAxis &&
                  secondaryAxis.map((axis, i) => (React__default['default'].createElement(rdk.CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: bind__default['default'](updateAxes, this, 'horizontal') }))),
              containerProps.chartSized && (React__default['default'].createElement(rdk.CloneElement, { element: brush, height: chartHeight, width: chartWidth, scale: xScale },
                  React__default['default'].createElement(rdk.CloneElement, { element: zoomPan, onZoomPan: bind__default['default'](this.onZoomPan, this), height: chartHeight, width: chartWidth, axisType: xAxis.props.type, roundDomains: xAxis.props.roundDomains, data: data, domain: zoomDomain },
                      React__default['default'].createElement(rdk.CloneElement, { element: series, id: `area-series-${id}`, data: data, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, isZoomed: isZoomed, animated: animated }))))));
      }
      render() {
          const { xAxis, yAxis, id, width, height, margins, className } = this.props;
          return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: classNames__default['default'](css$h.scatterPlot, className) }, (props) => this.renderChart(props)));
      }
  }
  ScatterPlot.defaultProps = {
      data: [],
      xAxis: React__default['default'].createElement(LinearXAxis, { type: "time" }),
      yAxis: React__default['default'].createElement(LinearYAxis, { type: "value" }),
      series: React__default['default'].createElement(ScatterSeries, null),
      gridlines: React__default['default'].createElement(GridlineSeries, null),
      brush: null,
      zoomPan: null
  };

  var css_248z$g = ".PointSeries-module_point__3cXpV {\n  stroke: rgba(255, 255, 255, 0.5);\n  stroke-width: 1px;\n}\n";
  var css$g = {"point":"PointSeries-module_point__3cXpV"};
  styleInject(css_248z$g);

  class PointSeries extends React.Component {
      isVisible(point, index) {
          const { show, activeValues, data } = this.props;
          const isActive = activeValues && point && isEqual__default['default'](activeValues.x, point.x);
          if (show === 'hover') {
              return isActive;
          }
          else if (show === 'first') {
              if (activeValues) {
                  return isActive;
              }
              else {
                  return index === 0;
              }
          }
          else if (show === 'last') {
              if (activeValues) {
                  return isActive;
              }
              else {
                  return index === data.length - 1;
              }
          }
          return show;
      }
      render() {
          const { data, xScale, yScale, animated, point, color, height, width, id } = this.props;
          return (React__default['default'].createElement(ScatterSeries, { height: height, width: width, id: id, animated: animated, data: data, xScale: xScale, yScale: yScale, point: React__default['default'].createElement(rdk.CloneElement, { element: point, color: color, className: css$g.point, size: 4, tooltip: null, visible: this.isVisible.bind(this) }) }));
      }
  }
  PointSeries.defaultProps = {
      show: 'hover',
      point: React__default['default'].createElement(ScatterPoint, null)
  };

  class Area extends React.Component {
      getAreaPath(data) {
          const { interpolation } = this.props;
          const fn = d3Shape.area()
              .x((d) => d.x)
              .y0((d) => d.y0)
              .y1((d) => d.y1)
              .curve(interpolate(interpolation));
          return fn(data);
      }
      getCoords() {
          const { data, xScale, yScale } = this.props;
          return data.map((item) => ({
              x: xScale(item.x),
              x1: xScale(item.x) - xScale(item.x1),
              y: yScale(item.y),
              y0: yScale(item.y0),
              y1: yScale(item.y1)
          }));
      }
      getAreaEnter(coords) {
          const areaPath = this.getAreaPath(coords);
          return {
              d: areaPath === null ? undefined : areaPath
          };
      }
      getAreaExit() {
          const { yScale, data, xScale } = this.props;
          const maxY = Math.max(...yScale.range());
          const coords = data.map((item) => ({
              x: xScale(item.x),
              x1: 0,
              y: 0,
              y1: maxY,
              y0: maxY
          }));
          const areaPath = this.getAreaPath(coords);
          return {
              d: areaPath === null ? undefined : areaPath
          };
      }
      getFill() {
          const { mask, id, gradient } = this.props;
          if (mask) {
              return `url(#mask-pattern-${id})`;
          }
          else {
              if (gradient) {
                  return `url(#gradient-${id})`;
              }
              return '';
          }
      }
      getTransition() {
          const { animated, index } = this.props;
          if (animated) {
              return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: index * 0.05 });
          }
          else {
              return {
                  type: false,
                  delay: 0
              };
          }
      }
      renderArea(coords) {
          const { mask, id, data } = this.props;
          const fill = this.getFill();
          const maskPath = mask ? `url(#mask-${id})` : '';
          const enter = this.getAreaEnter(coords);
          const exit = this.getAreaExit();
          const extras = constructFunctionProps(this.props, data);
          const transition = this.getTransition();
          return (React__default['default'].createElement(MotionPath, Object.assign({}, extras, { pointerEvents: "none", mask: maskPath, fill: fill, transition: transition, custom: {
                  enter,
                  exit
              } })));
      }
      render() {
          const { id, gradient, mask, data, color, index } = this.props;
          const coords = this.getCoords();
          const stroke = color(data, index);
          return (React__default['default'].createElement(React.Fragment, null,
              this.renderArea(coords),
              mask && (React__default['default'].createElement(React.Fragment, null,
                  React__default['default'].createElement(Mask, { id: `mask-${id}`, fill: `url(#gradient-${id})` }),
                  React__default['default'].createElement(rdk.CloneElement, { element: mask, id: `mask-pattern-${id}`, fill: stroke }))),
              gradient && (React__default['default'].createElement(rdk.CloneElement, { element: gradient, id: `gradient-${id}`, color: stroke }))));
      }
  }
  Area.defaultProps = {
      gradient: React__default['default'].createElement(Gradient, null),
      interpolation: 'linear'
  };

  class Line extends React.PureComponent {
      constructor() {
          super(...arguments);
          this.state = {};
          this.ghostPathRef = React.createRef();
      }
      componentDidMount() {
          if (this.ghostPathRef.current) {
              this.setState({
                  pathLength: this.ghostPathRef.current.getTotalLength()
              });
          }
      }
      componentDidUpdate(prevProps) {
          if (this.ghostPathRef.current &&
              (prevProps.data !== this.props.data ||
                  prevProps.width !== this.props.width ||
                  prevProps.xScale !== this.props.xScale ||
                  prevProps.yScale !== this.props.yScale)) {
              this.setState({
                  pathLength: this.ghostPathRef.current.getTotalLength()
              });
          }
      }
      getLinePath(data) {
          const { showZeroStroke, interpolation } = this.props;
          const fn = d3Shape.line()
              .x((d) => d.x)
              .y((d) => d.y1)
              .defined((d) => showZeroStroke || calculateShowStroke(d, data))
              .curve(interpolate(interpolation));
          return fn(data);
      }
      getCoords() {
          const { data, xScale, yScale } = this.props;
          return data.map((item) => ({
              x: xScale(item.x),
              x1: xScale(item.x) - xScale(item.x1),
              y: yScale(item.y),
              y0: yScale(item.y0),
              y1: yScale(item.y1)
          }));
      }
      getLineEnter(coords) {
          const { hasArea } = this.props;
          const { pathLength } = this.state;
          const linePath = this.getLinePath(coords);
          let strokeDasharray = '';
          if (!hasArea && pathLength !== undefined) {
              strokeDasharray = `${pathLength} ${pathLength}`;
          }
          return {
              d: linePath === null ? undefined : linePath,
              strokeDashoffset: 0,
              strokeDasharray: strokeDasharray
          };
      }
      getLineExit() {
          const { hasArea, yScale, xScale, data } = this.props;
          const { pathLength } = this.state;
          let coords;
          if (hasArea) {
              const maxY = Math.max(...yScale.range());
              coords = data.map((item) => ({
                  x: xScale(item.x),
                  x1: 0,
                  y: maxY,
                  y1: maxY,
                  y0: maxY
              }));
          }
          else {
              coords = this.getCoords();
          }
          const linePath = this.getLinePath(coords);
          let strokeDasharray = '';
          let strokeDashoffset = 0;
          if (!hasArea && pathLength !== undefined) {
              strokeDasharray = `${pathLength} ${pathLength}`;
              strokeDashoffset = pathLength;
          }
          return {
              d: linePath === null ? undefined : linePath,
              strokeDasharray,
              strokeDashoffset
          };
      }
      getTransition() {
          const { animated, index, hasArea } = this.props;
          if (animated) {
              return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: hasArea ? 0 : index * 0.05 });
          }
          else {
              return {
                  type: false,
                  delay: 0
              };
          }
      }
      render() {
          const { data, color, index, strokeWidth, hasArea } = this.props;
          const { pathLength } = this.state;
          const coords = this.getCoords();
          const stroke = color(data, index);
          const enter = this.getLineEnter(coords);
          const exit = this.getLineExit();
          const extras = constructFunctionProps(this.props, data);
          const transition = this.getTransition();
          const showLine = hasArea || pathLength !== undefined;
          return (React__default['default'].createElement(React.Fragment, null,
              showLine && (React__default['default'].createElement(MotionPath, Object.assign({}, extras, { pointerEvents: "none", stroke: stroke, strokeWidth: strokeWidth, fill: "none", transition: transition, custom: {
                      enter,
                      exit
                  } }))),
              !hasArea && (React__default['default'].createElement("path", { opacity: "0", d: enter.d, ref: this.ghostPathRef, pointerEvents: "none" }))));
      }
  }
  Line.defaultProps = {
      showZeroStroke: true,
      strokeWidth: 3
  };

  // For area charts, often symbols exceed the area
  // and we want to add a little bit of padding to prevent clipping
  const PADDING = 25;
  const HALF_PADDING = PADDING / 2;
  class AreaSeries extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {};
      }
      getColor(point, index) {
          const { colorScheme, data } = this.props;
          const { activeValues } = this.state;
          const key = Array.isArray(point) ? point[0].key : point === null || point === void 0 ? void 0 : point.key;
          return getColor({
              data,
              colorScheme,
              active: activeValues,
              point,
              index,
              key
          });
      }
      onValueEnter(event) {
          this.setState({
              activePoint: event.pointX,
              activeValues: event.value
          });
      }
      onValueLeave() {
          this.setState({
              activePoint: undefined,
              activeValues: undefined
          });
      }
      renderArea(data, index = 0) {
          const { id, width, xScale, yScale, area, line, interpolation, animated } = this.props;
          return (React__default['default'].createElement(React.Fragment, null,
              line && (React__default['default'].createElement(rdk.CloneElement, { element: line, xScale: xScale, yScale: yScale, data: data, width: width, index: index, hasArea: area !== null, animated: animated, interpolation: interpolation, color: this.getColor.bind(this) })),
              area && (React__default['default'].createElement(rdk.CloneElement, { element: area, id: `${id}-area-${index}`, xScale: xScale, yScale: yScale, data: data, index: index, animated: animated, interpolation: interpolation, color: this.getColor.bind(this) }))));
      }
      renderSymbols(data, index = 0) {
          const { xScale, yScale, symbols, id, height, width, animated, area } = this.props;
          const { activeValues } = this.state;
          const visible = symbols !== null;
          const activeSymbols = (symbols && symbols.props.activeValues) || activeValues;
          // Animations are only valid for Area
          const isAnimated = area !== undefined && animated && !activeSymbols;
          return (React__default['default'].createElement(React.Fragment, null, visible && (React__default['default'].createElement(rdk.CloneElement, { element: symbols, key: `point-series-${id}`, id: id, height: height, width: width, activeValues: activeSymbols, xScale: xScale, yScale: yScale, index: index, data: data, animated: isAnimated, color: () => this.getColor(data, index) }))));
      }
      renderMarkLine() {
          const { height, markLine } = this.props;
          const { activePoint, activeValues } = this.state;
          return (React__default['default'].createElement(React.Fragment, null, activeValues && markLine && (React__default['default'].createElement(rdk.CloneElement, { element: markLine, height: height, pointX: activePoint }))));
      }
      renderSingleSeries(data) {
          return (React__default['default'].createElement(React.Fragment, null,
              this.renderArea(data),
              this.renderMarkLine(),
              this.renderSymbols(data)));
      }
      renderMultiSeries(data) {
          return (React__default['default'].createElement(React.Fragment, null,
              data
                  .map((point, index) => (React__default['default'].createElement(React.Fragment, { key: `${point.key.toString()}` }, this.renderArea(point.data, index))))
                  .reverse(),
              this.renderMarkLine(),
              data
                  .map((point, index) => (React__default['default'].createElement(React.Fragment, { key: `${point.key.toString()}` }, this.renderSymbols(point.data, index))))
                  .reverse()));
      }
      render() {
          const { data, height, id, width, isZoomed, tooltip, xScale, yScale, type } = this.props;
          const isMulti = type === 'grouped' || type === 'stacked' || type === 'stackedNormalized';
          return (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement("defs", null,
                  React__default['default'].createElement("clipPath", { id: `${id}-path` },
                      React__default['default'].createElement("rect", { width: isZoomed ? width : width + PADDING, height: height + PADDING, x: isZoomed ? 0 : -HALF_PADDING, y: -HALF_PADDING }))),
              React__default['default'].createElement(rdk.CloneElement, { element: tooltip, xScale: xScale, yScale: yScale, data: data, height: height, width: width, color: this.getColor.bind(this), onValueEnter: bind__default['default'](this.onValueEnter, this), onValueLeave: bind__default['default'](this.onValueLeave, this) },
                  React__default['default'].createElement("g", { clipPath: `url(#${id}-path)` },
                      isMulti &&
                          this.renderMultiSeries(data),
                      !isMulti &&
                          this.renderSingleSeries(data)))));
      }
  }
  AreaSeries.defaultProps = {
      colorScheme: 'cybertron',
      animated: true,
      interpolation: 'linear',
      type: 'standard',
      line: React__default['default'].createElement(Line, null),
      area: React__default['default'].createElement(Area, null),
      markLine: React__default['default'].createElement(MarkLine, null),
      tooltip: React__default['default'].createElement(TooltipArea, null),
      symbols: React__default['default'].createElement(PointSeries, null)
  };

  class StackedNormalizedAreaSeries extends React.Component {
      render() {
          const _a = this.props, { type, symbols } = _a, rest = __rest(_a, ["type", "symbols"]);
          return (React__default['default'].createElement(AreaSeries, Object.assign({}, rest, { type: "stackedNormalized", symbols: symbols && (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: symbols }, symbols.props, { point: React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: symbols.props.point }, symbols.props.point.props, { tooltip: null })) }))) })));
      }
  }
  StackedNormalizedAreaSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), { type: 'stackedNormalized', tooltip: (React__default['default'].createElement(TooltipArea, { tooltip: React__default['default'].createElement(ChartTooltip, { content: (series, color) => {
                  if (!series) {
                      return null;
                  }
                  const value = Object.assign(Object.assign({}, series), { data: series.data.map((d) => (Object.assign(Object.assign({}, d), { value: `${formatValue(d.value)} ∙ ${formatValue(Math.floor((d.y1 - d.y0) * 100))}%` }))) });
                  return React__default['default'].createElement(TooltipTemplate, { color: color, value: value });
              } }) })) });

  class StackedAreaSeries extends React.Component {
      render() {
          const _a = this.props, { type, symbols } = _a, rest = __rest(_a, ["type", "symbols"]);
          return (React__default['default'].createElement(AreaSeries, Object.assign({}, rest, { type: "stacked", symbols: symbols && (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: symbols }, symbols.props, { point: React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: symbols.props.point }, symbols.props.point.props, { tooltip: null })) }))) })));
      }
  }
  StackedAreaSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), { type: 'stacked' });

  var css_248z$f = ".AreaChart-module_areaChart__1BikF {\n  overflow: visible;\n}\n";
  var css$f = {"areaChart":"AreaChart-module_areaChart__1BikF"};
  styleInject(css_248z$f);

  class AreaChart extends React.Component {
      constructor(props) {
          super(props);
          this.getData = memoize__default['default']((data, type) => {
              if (type === 'stacked' || type === 'stackedNormalized') {
                  return buildStackData(data, type === 'stackedNormalized');
              }
              else if (type === 'grouped') {
                  return buildNestedChartData(data, true);
              }
              else {
                  return buildShallowChartData(data);
              }
          });
          const zoom = props.zoomPan ? props.zoomPan.props : {};
          // eslint-disable-next-line no-prototype-builtins
          const zoomControlled = !zoom.hasOwnProperty('domain');
          this.state = {
              zoomDomain: zoom.domain,
              isZoomed: !!zoom.domain,
              zoomControlled
          };
      }
      static getDerivedStateFromProps(props, state) {
          if (props.zoomPan) {
              const zoom = props.zoomPan.props;
              if (!state.zoomControlled && zoom.domain !== state.zoomDomain) {
                  return {
                      zoomDomain: zoom.domain,
                      isZoomed: !!zoom.domain
                  };
              }
          }
          return null;
      }
      getScales(data, chartWidth, chartHeight, isMultiSeries) {
          const { zoomDomain } = this.state;
          const { yAxis, xAxis } = this.props;
          const xScale = getXScale({
              width: chartWidth,
              type: xAxis.props.type,
              roundDomains: xAxis.props.roundDomains,
              data,
              domain: zoomDomain || xAxis.props.domain,
              isMultiSeries
          });
          const yScale = getYScale({
              roundDomains: yAxis.props.roundDomains,
              type: yAxis.props.type,
              height: chartHeight,
              data,
              domain: yAxis.props.domain,
              isMultiSeries
          });
          return { xScale, yScale };
      }
      onZoomPan(event) {
          if (this.state.zoomControlled) {
              this.setState({
                  zoomDomain: event.domain,
                  isZoomed: event.isZoomed,
                  preventAnimation: true
              });
              clearTimeout(this.timeout);
              this.timeout = setTimeout(() => this.setState({ preventAnimation: false }), 500);
          }
      }
      renderChart(containerProps) {
          const { chartHeight, chartWidth, id, updateAxes } = containerProps;
          const { series, yAxis, xAxis, gridlines, brush, zoomPan, secondaryAxis } = this.props;
          const { zoomDomain, preventAnimation, isZoomed } = this.state;
          const seriesType = series.props.type;
          const isMultiSeries = seriesType === 'stacked' ||
              seriesType === 'stackedNormalized' ||
              seriesType === 'grouped';
          const data = this.getData(this.props.data, seriesType);
          const { xScale, yScale } = this.getScales(data, chartWidth, chartHeight, isMultiSeries);
          const animated = preventAnimation === true ? false : series.props.animated;
          return (React__default['default'].createElement(React.Fragment, null,
              containerProps.chartSized && gridlines && (React__default['default'].createElement(rdk.CloneElement, { element: gridlines, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, yAxis: yAxis.props, xAxis: xAxis.props })),
              React__default['default'].createElement(rdk.CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: bind__default['default'](updateAxes, this, 'horizontal') }),
              React__default['default'].createElement(rdk.CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: bind__default['default'](updateAxes, this, 'vertical') }),
              secondaryAxis &&
                  secondaryAxis.map((axis, i) => (React__default['default'].createElement(rdk.CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: bind__default['default'](updateAxes, this, 'horizontal') }))),
              containerProps.chartSized && (React__default['default'].createElement(rdk.CloneElement, { element: brush, height: chartHeight, width: chartWidth, scale: xScale },
                  React__default['default'].createElement(rdk.CloneElement, { element: zoomPan, onZoomPan: bind__default['default'](this.onZoomPan, this), height: chartHeight, width: chartWidth, axisType: xAxis.props.type, roundDomains: xAxis.props.roundDomains, data: data, domain: zoomDomain },
                      React__default['default'].createElement(rdk.CloneElement, { element: series, id: `area-series-${id}`, data: data, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, isZoomed: isZoomed, animated: animated }))))));
      }
      render() {
          const { xAxis, yAxis, id, width, height, margins, className, series } = this.props;
          return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: classNames__default['default'](css$f.areaChart, className, series.type) }, (props) => this.renderChart(props)));
      }
  }
  AreaChart.defaultProps = {
      data: [],
      xAxis: React__default['default'].createElement(LinearXAxis, { type: "time" }),
      yAxis: React__default['default'].createElement(LinearYAxis, { type: "value" }),
      series: React__default['default'].createElement(AreaSeries, null),
      gridlines: React__default['default'].createElement(GridlineSeries, null),
      brush: null,
      zoomPan: null
  };

  class StackedAreaChart extends React.Component {
      render() {
          return React__default['default'].createElement(AreaChart, Object.assign({}, this.props));
      }
  }
  StackedAreaChart.defaultProps = {
      series: React__default['default'].createElement(StackedAreaSeries, null)
  };

  class StackedNormalizedAreaChart extends React.Component {
      render() {
          return React__default['default'].createElement(AreaChart, Object.assign({}, this.props));
      }
  }
  StackedNormalizedAreaChart.defaultProps = {
      series: React__default['default'].createElement(StackedNormalizedAreaSeries, null),
      yAxis: (React__default['default'].createElement(LinearYAxis, { type: "value", tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { label: React__default['default'].createElement(LinearYAxisTickLabel, { rotation: false, format: (data) => `${data * 100}%` }) }) }))
  };

  class Bar extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {};
          this.rect = React.createRef();
      }
      getExit({ x, y, width, height }) {
          const { yScale, xScale, type } = this.props;
          const isVertical = this.getIsVertical();
          let newX = isVertical ? x : Math.min(...xScale.range());
          let newY = isVertical ? Math.max(...yScale.range()) : y;
          const newHeight = isVertical ? 0 : height;
          const newWidth = isVertical ? width : 0;
          if (type === 'stackedDiverging') {
              if (isVertical) {
                  newY = newY / 2;
              }
              else {
                  newX = newX / 2;
              }
          }
          return {
              x: newX,
              y: newY,
              height: newHeight,
              width: newWidth
          };
      }
      getKeyCoords(v, v0, v1, scale, sizeOverride, isCategorical, padding) {
          let offset;
          let size;
          if (isCategorical) {
              if (scale.bandwidth) {
                  offset = scale(v);
                  size = scale.bandwidth();
                  if (sizeOverride) {
                      if (offset) {
                          offset = offset + size / 2 - sizeOverride / 2;
                      }
                      else {
                          // Stacked bar charts don't have offsets...
                          offset = size / 2 - sizeOverride / 2;
                      }
                      size = sizeOverride;
                  }
              }
              else {
                  if (sizeOverride) {
                      throw new Error('Not a valid option for this scale type');
                  }
                  offset = scale(v0);
                  size = scale(v1 - v0);
                  if (padding) {
                      const calc = this.calculateLinearScalePadding(scale, offset, size);
                      offset = calc.offset;
                      size = calc.size;
                  }
              }
          }
          else {
              if (sizeOverride) {
                  throw new Error('Not a valid option for this scale type');
              }
              const c0 = scale(v0);
              const c1 = scale(v1);
              const delta = c1 - c0;
              offset = c0;
              size = Math.max(delta - 1, 0);
          }
          return { offset, size };
      }
      getValueCoords(v0, v1, scale) {
          const c0 = scale(v0);
          const c1 = scale(v1);
          const size = Math.abs(c0 - c1);
          const minSize = Math.max(this.props.minHeight || 0, size);
          return { offset: Math.min(c0, c1), size: minSize };
      }
      getIsVertical() {
          return this.props.layout === 'vertical';
      }
      getCoords(data) {
          const { isCategorical, width, padding, xScale1 } = this.props;
          const isVertical = this.getIsVertical();
          let yScale = this.props.yScale;
          let xScale = this.props.xScale;
          if (xScale1) {
              if (isVertical) {
                  xScale = xScale1;
              }
              else {
                  yScale = xScale1;
              }
          }
          if (isVertical) {
              const xCoords = this.getKeyCoords(data.x, data.x0, data.x1, xScale, width, isCategorical, padding);
              const yCoords = this.getValueCoords(data.y0, data.y1, yScale);
              return {
                  x: xCoords.offset,
                  width: xCoords.size,
                  y: yCoords.offset,
                  height: yCoords.size
              };
          }
          else {
              const yCoords = this.getKeyCoords(data.y, data.y0, data.y1, yScale, width, isCategorical, padding);
              const xCoords = this.getValueCoords(data.x0, data.x1, xScale);
              return {
                  x: xCoords.offset,
                  width: xCoords.size,
                  y: yCoords.offset,
                  height: yCoords.size
              };
          }
      }
      /**
       * This function calculates the padding on a linear scale used by the marimekko chart.
       */
      calculateLinearScalePadding(scale, offset, size) {
          const { barCount, groupIndex, padding } = this.props;
          const totalSize = scale.range()[1];
          const sizeMinusPadding = totalSize - padding * (barCount - 1);
          const multiplier = sizeMinusPadding / totalSize;
          offset = offset * multiplier + groupIndex * padding;
          size = size * multiplier;
          return { size, offset };
      }
      onMouseEnter(event) {
          const { onMouseEnter, data, tooltip } = this.props;
          // Only tooltip bars rely on this...
          if (tooltip) {
              this.setState({ active: true });
          }
          onMouseEnter({
              value: data,
              nativeEvent: event
          });
      }
      onMouseLeave(event) {
          const { onMouseLeave, data, tooltip } = this.props;
          // Only tooltip bars rely on this...
          if (tooltip) {
              this.setState({ active: false });
          }
          onMouseLeave({
              value: data,
              nativeEvent: event
          });
      }
      onMouseClick(event) {
          const { onClick, data } = this.props;
          onClick({
              value: data,
              nativeEvent: event
          });
      }
      getFill(color) {
          const { mask, id, gradient } = this.props;
          if (mask) {
              return `url(#mask-pattern-${id})`;
          }
          else {
              if (gradient) {
                  return `url(#gradient-${id})`;
              }
              return color;
          }
      }
      getTooltipData() {
          const { data, isCategorical } = this.props;
          const isVertical = this.getIsVertical();
          const xAttr = isCategorical ? 'x' : 'x0';
          let x = data[xAttr];
          // Stacked diverging negative numbers
          // in horizontal layouts need to pull x0
          if (data.x0 < 0) {
              x = data.x0;
          }
          const matches = isVertical
              ? data.key && data.key !== x
              : data.key && data.key !== data.y;
          if (matches) {
              x = `${data.key} ∙ ${x}`;
          }
          return {
              y: data.y,
              x
          };
      }
      getTransition(index) {
          const { animated, barCount, layout } = this.props;
          if (animated) {
              let delay = 0;
              if (layout === 'vertical') {
                  delay = (index / barCount) * 0.5;
              }
              else {
                  delay = ((barCount - index) / barCount) * 0.5;
              }
              return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: delay });
          }
          else {
              return {
                  type: false,
                  delay: 0
              };
          }
      }
      renderBar(currentColorShade, coords, index) {
          const { cursor, mask, id, data, rx, ry, onMouseMove } = this.props;
          const maskPath = mask ? `url(#mask-${id})` : '';
          const fill = this.getFill(currentColorShade);
          const initialExit = this.getExit(coords);
          this.getIsVertical();
          const extras = constructFunctionProps(this.props, data);
          const transition = this.getTransition(index);
          // UGH: https://github.com/framer/motion/issues/384
          const initial = Object.assign(Object.assign({}, initialExit), { attrX: initialExit.x, attrY: initialExit.y, fill });
          delete initial.x;
          delete initial.y;
          const animate = Object.assign(Object.assign({}, coords), { attrX: coords.x, attrY: coords.y, fill });
          delete animate.x;
          delete animate.y;
          return (React__default['default'].createElement("g", { ref: this.rect },
              React__default['default'].createElement(framerMotion.motion.rect, { className: classNames__default['default'](extras.className), style: Object.assign(Object.assign({}, extras.style), { cursor }), mask: maskPath, rx: rx, ry: ry, initial: initial, animate: animate, exit: initial, transition: transition, onMouseEnter: bind__default['default'](this.onMouseEnter, this), onMouseLeave: bind__default['default'](this.onMouseLeave, this), onClick: bind__default['default'](this.onMouseClick, this), onMouseMove: onMouseMove })));
      }
      renderGuideBar() {
          const { data, yScale, active, barIndex, type, guide, xScale } = this.props;
          if (!guide) {
              return null;
          }
          // If we are stacked, only render the first bar
          if (type === 'stacked' && barIndex !== 0) {
              return null;
          }
          // No reason to show them since they are always 100% tall
          if (type === 'stackedNormalized' || type === 'marimekko') {
              console.error('Guide bars are not supported for these chart types');
              return null;
          }
          const vertical = this.getIsVertical();
          const valueScale = vertical ? yScale : xScale;
          const [start, end] = valueScale.domain();
          const attr = vertical ? 'y' : 'x';
          // For stacked diverging we need to flip the points for positive / negative bars
          const attrStart = type === 'stackedDiverging' ? '0' : '1';
          const endPoint = type === 'stackedDiverging' ? start : end;
          const startPoint = type === 'stackedDiverging' && data[attr] > 0 ? end : endPoint;
          const coords = this.getCoords(Object.assign(Object.assign({}, data), { [attr]: endPoint, [`${attr}${attrStart}`]: startPoint }));
          return (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: guide }, coords, { active: active })));
      }
      render() {
          const { activeBrightness, id, gradient, data, barIndex, color, yScale, barCount, xScale, groupIndex, rangeLines, animated, type, tooltip, layout, mask, label } = this.props;
          const active = tooltip ? this.state.active : this.props.active;
          const stroke = color(data, barIndex);
          const coords = this.getCoords(data);
          const currentColorShade = active
              ? chroma__default['default'](stroke).brighten(activeBrightness).hex()
              : stroke;
          const rangeLineColor = (rangeLines && rangeLines.props.color) || stroke;
          const rangeLineColorShade = active
              ? chroma__default['default'](rangeLineColor).brighten(activeBrightness)
              : rangeLineColor;
          const index = groupIndex !== undefined ? groupIndex : barIndex;
          const isVertical = this.getIsVertical();
          const scale = isVertical ? yScale : xScale;
          const tooltipData = this.getTooltipData();
          const barLabel = isVertical ? tooltipData.y : tooltipData.x;
          const placement = layout === 'vertical' ? 'top' : 'right';
          return (React__default['default'].createElement(React.Fragment, null,
              this.renderGuideBar(),
              this.renderBar(currentColorShade, coords, index),
              rangeLines && (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: rangeLines }, coords, { index: index, data: data, scale: scale, color: rangeLineColorShade, barCount: barCount, animated: animated, layout: layout, type: type }))),
              mask && (React__default['default'].createElement(React.Fragment, null,
                  React__default['default'].createElement(Mask, { id: `mask-${id}`, fill: `url(#gradient-${id})` }),
                  React__default['default'].createElement(rdk.CloneElement, { element: mask, id: `mask-pattern-${id}`, fill: stroke }))),
              gradient && (React__default['default'].createElement(rdk.CloneElement, { element: gradient, id: `gradient-${id}`, direction: layout, color: currentColorShade })),
              label && (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: label }, coords, { text: formatValue(barLabel), index: index, data: data, scale: scale, fill: label.props.fill || currentColorShade, barCount: barCount, animated: animated, layout: layout, type: type }))),
              tooltip && (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: !!active, reference: this.rect, color: color, value: tooltipData, placement: tooltip.props.placement || placement, data: data }))));
      }
  }
  Bar.defaultProps = {
      activeBrightness: 0.5,
      rx: 0,
      ry: 0,
      cursor: 'auto',
      rangeLines: null,
      label: null,
      tooltip: null,
      layout: 'vertical',
      guide: null,
      gradient: React__default['default'].createElement(Gradient, null),
      onClick: () => undefined,
      onMouseEnter: () => undefined,
      onMouseLeave: () => undefined,
      onMouseMove: () => undefined
  };

  class BarSeries extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {};
          this.ref = React.createRef();
      }
      getIsMulti() {
          const { type } = this.props;
          return (type === 'grouped' ||
              type === 'stacked' ||
              type === 'marimekko' ||
              type === 'stackedNormalized' ||
              type === 'stackedDiverging');
      }
      /**
       * Get the translation for the bar group.
       */
      getTransform(data) {
          const { xScale, yScale, type, layout } = this.props;
          let xPos = 0;
          let yPos = 0;
          if (type !== 'marimekko') {
              if (layout === 'vertical') {
                  const val = xScale(data.key);
                  xPos = val;
              }
              else {
                  const val = yScale(data.key);
                  yPos = val;
              }
          }
          return `translate(${xPos}, ${yPos})`;
      }
      getColor(point, index) {
          const { colorScheme, data, layout } = this.props;
          const isMultiSeries = this.getIsMulti();
          let key = 'key';
          if (isMultiSeries) {
              if (layout === 'vertical') {
                  key = 'x';
              }
              else {
                  key = 'y';
              }
          }
          // histograms...
          if (point[key] === undefined) {
              key = 'x0';
          }
          return getColor({
              colorScheme,
              point,
              index,
              data,
              isMultiSeries,
              attribute: key
          });
      }
      onMouseMove(event) {
          var _a;
          // Manuallly call mouse move so we don't have to kill bar pointer events
          (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.onMouseMove(event);
      }
      renderBar(data, barIndex, barCount, groupIndex) {
          const { xScale1, bar, padding, animated, isCategorical, layout, type, id } = this.props;
          const { activeValues } = this.state;
          const active = activeValues && activeValues.x === data.key;
          const isVertical = layout === 'vertical';
          let yScale = this.props.yScale;
          let xScale = this.props.xScale;
          if (xScale1) {
              if (isVertical) {
                  xScale = xScale1;
              }
              else {
                  yScale = xScale1;
              }
          }
          // Histograms dont have keys
          let key = barIndex.toString();
          if (data.key) {
              key = `${data.key.toString()}-${groupIndex}`;
          }
          let barElements = Array.isArray(bar) ? bar[barIndex] : bar;
          if (!bar) {
              barElements = React__default['default'].createElement(Bar, null);
          }
          return (React__default['default'].createElement(React.Fragment, { key: key },
              React__default['default'].createElement(rdk.CloneElement, { element: barElements, id: `${id}-bar-${groupIndex}-${barIndex}`, animated: animated, active: active, xScale: xScale, xScale1: xScale1, yScale: yScale, padding: padding, barCount: barCount, groupIndex: groupIndex, barIndex: barIndex, data: data, isCategorical: isCategorical, color: this.getColor.bind(this), layout: layout, type: type, onMouseMove: this.onMouseMove.bind(this) })));
      }
      /**
       * Get the bar group.
       */
      renderBarGroup(data, barCount, groupIndex) {
          return (React__default['default'].createElement(React.Fragment, null, data.map((barData, barIndex) => this.renderBar(barData, barIndex, barCount, groupIndex))));
      }
      onValueEnter(event) {
          this.setState({
              activeValues: event.value
          });
      }
      onValueLeave() {
          this.setState({
              activeValues: undefined
          });
      }
      render() {
          const { data, tooltip, xScale, yScale, height, width, layout } = this.props;
          const isMulti = this.getIsMulti();
          return (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, childRef: this.ref, xScale: xScale, yScale: yScale, data: data, height: height, width: width, inverse: false, isHorizontal: layout === 'horizontal', color: this.getColor.bind(this), onValueEnter: this.onValueEnter.bind(this), onValueLeave: this.onValueLeave.bind(this) },
              isMulti &&
                  data.map((groupData, index) => (React__default['default'].createElement("g", { transform: this.getTransform(groupData), key: `bar-group-${index}` }, this.renderBarGroup(groupData.data, data.length, index)))),
              !isMulti &&
                  this.renderBarGroup(data, data.length)));
      }
  }
  BarSeries.defaultProps = {
      type: 'standard',
      padding: 0.1,
      groupPadding: 16,
      animated: true,
      tooltip: (React__default['default'].createElement(TooltipArea, { tooltip: React__default['default'].createElement(ChartTooltip, { followCursor: true, modifiers: {
                  offset: '5px, 5px'
              } }) })),
      colorScheme: 'cybertron',
      bar: React__default['default'].createElement(Bar, null),
      layout: 'vertical'
  };

  class RangeLines extends React.Component {
      getIsVertical() {
          return this.props.layout === 'vertical';
      }
      getEnter(rangeLineHeight) {
          const { x, y, height, position, width, data } = this.props;
          const isVertical = this.getIsVertical();
          let newY = y;
          let newX = x;
          // If its diverging and the value is negative, we
          // need to reverse the type...
          const isTop = position === 'top';
          const direction = isVertical
              ? data.y < 0 && isTop
                  ? 'bottom'
                  : position
              : data.x0 < 0 && isTop
                  ? 'bottom'
                  : position;
          if (isVertical) {
              if (direction === 'top') {
                  newY = y;
              }
              else {
                  newY = y + height - rangeLineHeight;
              }
          }
          else {
              if (direction === 'top') {
                  newX = x + width - rangeLineHeight;
              }
              else {
                  newX = x;
              }
          }
          return {
              x: newX,
              y: newY,
              opacity: 1
          };
      }
      getExit(rangeLineHeight) {
          const { x, scale, height, width, y, position, type } = this.props;
          const isVertical = this.getIsVertical();
          let newY = y;
          let newX = x;
          if (isVertical) {
              const maxY = Math.max(...scale.range());
              if (position === 'top') {
                  newY = maxY;
              }
              else {
                  newY = maxY + height - rangeLineHeight;
              }
          }
          else {
              const minX = Math.min(...scale.range());
              if (position === 'top') {
                  newX = minX;
              }
              else {
                  newX = minX + width - rangeLineHeight;
              }
          }
          if (type === 'stackedDiverging') {
              if (isVertical) {
                  newY = newY / 2;
              }
              else {
                  newX = newX / 2;
              }
          }
          return {
              y: newY,
              x: newX,
              opacity: 0
          };
      }
      getLineHeight() {
          const { height, width, strokeWidth } = this.props;
          const isVertical = this.getIsVertical();
          return Math.min(strokeWidth, isVertical ? height : width);
      }
      getHeightWidth(rangeLineHeight) {
          const { height, width } = this.props;
          const isVertical = this.getIsVertical();
          return {
              width: isVertical ? width : rangeLineHeight,
              height: isVertical ? rangeLineHeight : height
          };
      }
      getDelay() {
          const { animated, index, barCount, layout } = this.props;
          let delay = 0;
          if (animated) {
              if (layout === 'vertical') {
                  return (index / barCount) * 0.5;
              }
              else {
                  return ((barCount - index) / barCount) * 0.5;
              }
          }
          return delay;
      }
      render() {
          const { color } = this.props;
          const rangeLineHeight = this.getLineHeight();
          const enterProps = this.getEnter(rangeLineHeight);
          const exitProps = this.getExit(rangeLineHeight);
          const { height, width } = this.getHeightWidth(rangeLineHeight);
          const delay = this.getDelay();
          // UGH: https://github.com/framer/motion/issues/384
          const initial = Object.assign(Object.assign({}, exitProps), { attrX: exitProps.x, attrY: exitProps.y });
          delete initial.x;
          delete initial.y;
          const animate = Object.assign(Object.assign({}, enterProps), { attrX: enterProps.x, attrY: enterProps.y });
          delete animate.x;
          delete animate.y;
          return (React__default['default'].createElement(framerMotion.motion.rect, { pointerEvents: "none", fill: color, width: width, height: height, initial: initial, animate: animate, exit: initial, transition: Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay }) }));
      }
  }
  RangeLines.defaultProps = {
      position: 'top',
      strokeWidth: 1,
      layout: 'vertical'
  };

  class StackedBarSeries extends React.Component {
      render() {
          const _a = this.props, { type } = _a, rest = __rest(_a, ["type"]);
          return React__default['default'].createElement(BarSeries, Object.assign({ type: type }, rest));
      }
  }
  StackedBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { type: 'stacked', bar: (React__default['default'].createElement(Bar, { gradient: React__default['default'].createElement(Gradient, { stops: [
                  React__default['default'].createElement(GradientStop, { offset: "5%", stopOpacity: 0.1, key: "start" }),
                  React__default['default'].createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "stop" })
              ] }), rangeLines: React__default['default'].createElement(RangeLines, { position: "top", strokeWidth: 3 }) })) });

  class StackedNormalizedBarSeries extends React.Component {
      render() {
          const _a = this.props, rest = __rest(_a, ["type"]);
          return React__default['default'].createElement(BarSeries, Object.assign({ type: "stackedNormalized" }, rest));
      }
  }
  StackedNormalizedBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { type: 'stackedNormalized', tooltip: (React__default['default'].createElement(TooltipArea, { tooltip: React__default['default'].createElement(ChartTooltip, { followCursor: true, modifiers: {
                  offset: '5px, 5px'
              }, content: (point, color) => {
                  point.data = point.data.map((d) => {
                      // Handle horz case
                      const start = isNaN(d.y0) ? d.x0 : d.y0;
                      const end = isNaN(d.y1) ? d.x1 : d.y1;
                      return Object.assign(Object.assign({}, d), { value: `${formatValue(Math.floor((end - start) * 100))}%` });
                  });
                  return React__default['default'].createElement(TooltipTemplate, { value: point, color: color });
              } }) })), bar: (React__default['default'].createElement(Bar, { gradient: React__default['default'].createElement(Gradient, { stops: [
                  React__default['default'].createElement(GradientStop, { offset: "5%", stopOpacity: 0.1, key: "start" }),
                  React__default['default'].createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "stop" })
              ] }), rangeLines: React__default['default'].createElement(RangeLines, { position: "top", strokeWidth: 3 }) })) });

  class MarimekkoBarSeries extends React.Component {
      render() {
          const _a = this.props, rest = __rest(_a, ["type"]);
          return React__default['default'].createElement(BarSeries, Object.assign({ type: "marimekko" }, rest));
      }
  }
  MarimekkoBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { type: 'marimekko', padding: 10, tooltip: (React__default['default'].createElement(TooltipArea, { tooltip: React__default['default'].createElement(ChartTooltip, { followCursor: true, modifiers: {
                  offset: '5px, 5px'
              }, content: (point, color) => {
                  const data = Object.assign(Object.assign({}, point), { data: point.data.map((d) => (Object.assign(Object.assign({}, d), { value: `${formatValue(d.value)} ∙ ${formatValue(Math.floor((d.y1 - d.y0) * 100))}%` }))) });
                  return React__default['default'].createElement(TooltipTemplate, { value: data, color: color });
              } }) })), bar: (React__default['default'].createElement(Bar, { padding: 10, gradient: React__default['default'].createElement(Gradient, { stops: [
                  React__default['default'].createElement(GradientStop, { offset: "5%", stopOpacity: 0.1, key: "start" }),
                  React__default['default'].createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "stop" })
              ] }), rangeLines: React__default['default'].createElement(RangeLines, { position: "top", strokeWidth: 3 }) })) });

  class BarLabel extends React.PureComponent {
      getIsVertical() {
          return this.props.layout === 'vertical';
      }
      getEnter() {
          const { x, y, height, position, width, data, padding } = this.props;
          const isVertical = this.getIsVertical();
          let newY = y;
          let newX = x;
          // If its diverging and the value is negative, we
          // need to reverse the type...
          const isTop = position === 'top';
          const direction = isVertical
              ? data.y < 0 && isTop
                  ? 'bottom'
                  : position
              : data.x0 < 0 && isTop
                  ? 'bottom'
                  : position;
          if (isVertical) {
              if (direction === 'top') {
                  newY = y - padding;
              }
              else if (direction === 'center') {
                  newY = y + height / 2;
              }
              else if (direction === 'bottom') {
                  newY = y + height - padding;
              }
              newX = newX + width / 2;
          }
          else {
              if (direction === 'top') {
                  newX = x + width + padding;
              }
              else if (direction === 'center') {
                  newX = x + width / 2;
              }
              else if (direction === 'bottom') {
                  newX = x + padding;
              }
              newY = newY + height / 2;
          }
          return {
              translateX: newX,
              translateY: newY,
              opacity: 1
          };
      }
      getExit() {
          const { x, scale, height, width, y, position, type, padding } = this.props;
          const isVertical = this.getIsVertical();
          let newY = y;
          let newX = x;
          if (isVertical) {
              const maxY = Math.max(...scale.range());
              if (position === 'top') {
                  newY = maxY;
              }
              else {
                  newY = maxY + height + padding;
              }
              newX = newX + width / 2;
          }
          else {
              const minX = Math.min(...scale.range());
              if (position === 'top') {
                  newX = minX;
              }
              else {
                  newX = minX + width + padding;
              }
              newY = newY + height / 2;
          }
          if (type === 'stackedDiverging') {
              if (isVertical) {
                  newY = newY / 2;
              }
              else {
                  newX = newX / 2;
              }
          }
          return {
              translateY: newY,
              translateX: newX,
              opacity: 0
          };
      }
      getDelay() {
          const { animated, index, barCount, layout } = this.props;
          let delay = 0;
          if (animated) {
              if (layout === 'vertical') {
                  return (index / barCount) * 0.5;
              }
              else {
                  return ((barCount - index) / barCount) * 0.5;
              }
          }
          return delay;
      }
      render() {
          const { fontSize, fontFamily, fill, className, text } = this.props;
          const enterProps = this.getEnter();
          const exitProps = this.getExit();
          const delay = this.getDelay();
          const textAnchor = this.getIsVertical() ? 'middle' : 'start';
          return (React__default['default'].createElement(framerMotion.motion.g, { initial: exitProps, animate: enterProps, exit: exitProps, transition: Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay }), fontSize: fontSize, fontFamily: fontFamily },
              React__default['default'].createElement("text", { fill: fill, className: className, textAnchor: textAnchor }, text)));
      }
  }
  BarLabel.defaultProps = {
      position: 'top',
      layout: 'vertical',
      fontSize: 13,
      padding: 5,
      fontFamily: 'sans-serif',
      fill: '#000'
  };

  class HistogramBarSeries extends React.Component {
      render() {
          const _a = this.props, rest = __rest(_a, ["type"]);
          return React__default['default'].createElement(BarSeries, Object.assign({}, rest));
      }
  }
  HistogramBarSeries.defaultProps = Object.assign(Object.assign({}, BarSeries.defaultProps), { colorScheme: schemes.cybertron[0], tooltip: (React__default['default'].createElement(TooltipArea, { tooltip: React__default['default'].createElement(ChartTooltip, { followCursor: true, modifiers: {
                  offset: '5px, 5px'
              }, content: (point, color) => {
                  const data = Object.assign(Object.assign({}, point), { x: `${formatValue(point.x0)} - ${formatValue(point.x1)}`, value: point.y });
                  return React__default['default'].createElement(TooltipTemplate, { value: data, color: color });
              } }) })) });

  const GuideBar = (_a) => {
      var { active, fill = '#eee', opacity = 0.15 } = _a, rest = __rest(_a, ["active", "fill", "opacity"]);
      const { x, y } = rest, other = __rest(rest, ["x", "y"]);
      return (React__default['default'].createElement(framerMotion.motion.rect, Object.assign({}, other, { fill: fill, pointerEvents: "none", initial: "hidden", animate: active ? 'visible' : 'hidden', variants: {
              hidden: { opacity: 0, attrX: x, attrY: y },
              visible: { opacity, attrX: x, attrY: y }
          } })));
  };

  var css_248z$e = ".BarChart-module_barChart__36biH {\n  overflow: visible;\n}\n\n  .BarChart-module_barChart__36biH.BarChart-module_stackedNormalized__3l5Vx .bar, .BarChart-module_barChart__36biH.BarChart-module_stacked__12DMR .bar, .BarChart-module_barChart__36biH.BarChart-module_marimekko__33Uhg .bar {\n      stroke: var(--color-background);\n      stroke-width: 0.2;\n    }\n";
  var css$e = {"barChart":"BarChart-module_barChart__36biH","stackedNormalized":"BarChart-module_stackedNormalized__3l5Vx","stacked":"BarChart-module_stacked__12DMR","marimekko":"BarChart-module_marimekko__33Uhg"};
  styleInject(css_248z$e);

  class BarChart extends React.Component {
      getScalesAndData(chartHeight, chartWidth) {
          const { yAxis, xAxis, series } = this.props;
          const { type, layout } = series.props;
          const isVertical = this.getIsVertical();
          const isMarimekko = type === 'marimekko';
          const isGrouped = type === 'grouped';
          const isStacked = type === 'stacked' ||
              type === 'stackedNormalized' ||
              type === 'stackedDiverging';
          const isMultiSeries = isGrouped || isStacked;
          let data;
          if (isStacked) {
              let distroType = 'default';
              if (type === 'stackedNormalized') {
                  distroType = 'expand';
              }
              else if (type === 'stackedDiverging') {
                  distroType = 'diverging';
              }
              data = buildBarStackData(this.props.data, distroType, layout);
          }
          else if (type === 'waterfall') {
              data = buildWaterfall(this.props.data, layout, this.props.series.props.binSize);
          }
          else if (isMarimekko) {
              data = buildMarimekkoData(this.props.data);
          }
          else if (isGrouped) {
              data = buildNestedChartData(this.props.data, false, layout);
          }
          else {
              data = buildShallowChartData(this.props.data, layout, this.props.series.props.binSize);
          }
          let yScale;
          let xScale;
          let xScale1;
          if (isVertical) {
              if (isGrouped) {
                  const { keyScale, groupScale } = this.getMultiGroupScales(data, chartHeight, chartWidth);
                  xScale = groupScale;
                  xScale1 = keyScale;
              }
              else if (isMarimekko) {
                  const { keyScale, groupScale } = this.getMarimekkoGroupScales(data, xAxis, chartWidth);
                  xScale = groupScale;
                  xScale1 = keyScale;
              }
              else {
                  xScale = this.getKeyScale(data, xAxis, isMultiSeries, chartWidth);
              }
              yScale = this.getValueScale(data, yAxis, isMultiSeries, chartHeight);
          }
          else {
              if (isGrouped) {
                  const { keyScale, groupScale } = this.getMultiGroupScales(data, chartHeight, chartWidth);
                  yScale = groupScale;
                  xScale1 = keyScale;
                  xScale = this.getKeyScale(data, xAxis, isMultiSeries, chartWidth);
              }
              else if (isMarimekko) {
                  throw new Error('Marimekko is currently not supported for horizontal layouts');
              }
              else {
                  xScale = this.getKeyScale(data, xAxis, isMultiSeries, chartWidth);
                  yScale = this.getValueScale(data, yAxis, isMultiSeries, chartHeight);
              }
          }
          return { xScale, xScale1, yScale, data };
      }
      getKeyAxis() {
          const { yAxis, xAxis } = this.props;
          const isVertical = this.getIsVertical();
          return isVertical ? xAxis : yAxis;
      }
      getIsDiverging() {
          return this.props.series.props.type === 'stackedDiverging';
      }
      getIsVertical() {
          return this.props.series.props.layout === 'vertical';
      }
      getMarimekkoGroupScales(data, axis, width) {
          const { series } = this.props;
          const keyScale = getMarimekkoScale(width, axis.props.roundDomains);
          const groupScale = getMarimekkoGroupScale({
              width,
              padding: series.props.padding,
              data,
              valueScale: keyScale
          });
          return {
              keyScale,
              groupScale
          };
      }
      getMultiGroupScales(data, height, width) {
          const { series } = this.props;
          const isVertical = this.getIsVertical();
          const { groupPadding, layout } = series.props;
          const groupScale = getGroupScale({
              dimension: isVertical ? width : height,
              direction: layout,
              padding: groupPadding,
              data
          });
          const keyScale = getInnerScale({
              groupScale: groupScale,
              padding: series.props.padding,
              data,
              prop: isVertical ? 'x' : 'y'
          });
          return {
              groupScale,
              keyScale
          };
      }
      getKeyScale(data, axis, isMultiSeries, width) {
          const { series } = this.props;
          return getXScale({
              width,
              type: axis.props.type,
              roundDomains: axis.props.roundDomains,
              data,
              padding: series.props.padding,
              domain: axis.props.domain,
              isMultiSeries,
              isDiverging: this.getIsDiverging()
          });
      }
      getValueScale(data, axis, isMultiSeries, height) {
          const { series } = this.props;
          return getYScale({
              roundDomains: axis.props.roundDomains,
              padding: series.props.padding,
              type: axis.props.type,
              height,
              data,
              domain: axis.props.domain,
              isMultiSeries,
              isDiverging: this.getIsDiverging()
          });
      }
      renderChart(containerProps) {
          const { chartHeight, chartWidth, id, updateAxes } = containerProps;
          const { series, xAxis, yAxis, brush, gridlines, secondaryAxis } = this.props;
          const { xScale, xScale1, yScale, data } = this.getScalesAndData(chartHeight, chartWidth);
          const isVertical = this.getIsVertical();
          const keyAxis = this.getKeyAxis();
          const isCategorical = keyAxis.props.type === 'category';
          return (React__default['default'].createElement(React.Fragment, null,
              containerProps.chartSized && gridlines && (React__default['default'].createElement(rdk.CloneElement, { element: gridlines, height: chartHeight, width: chartWidth, yScale: yScale, xScale: xScale, yAxis: yAxis.props, xAxis: xAxis.props })),
              React__default['default'].createElement(rdk.CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: bind__default['default'](updateAxes, this, isVertical ? 'horizontal' : 'vertical') }),
              React__default['default'].createElement(rdk.CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: bind__default['default'](updateAxes, this, isVertical ? 'vertical' : 'horizontal') }),
              secondaryAxis &&
                  secondaryAxis.map((axis, i) => (React__default['default'].createElement(rdk.CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: bind__default['default'](updateAxes, this, 'horizontal') }))),
              containerProps.chartSized && (React__default['default'].createElement(rdk.CloneElement, { element: brush, height: chartHeight, width: chartWidth, scale: xScale },
                  React__default['default'].createElement(rdk.CloneElement, { element: series, id: `bar-series-${id}`, data: data, height: chartHeight, width: chartWidth, isCategorical: isCategorical, xScale: xScale, xScale1: xScale1, yScale: yScale })))));
      }
      render() {
          const { id, width, height, margins, className, series, xAxis, yAxis } = this.props;
          return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: classNames__default['default'](css$e.barChart, className, css$e[series.props.type]) }, (props) => this.renderChart(props)));
      }
  }
  BarChart.defaultProps = {
      data: [],
      xAxis: (React__default['default'].createElement(LinearXAxis, { type: "category", tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { tickSize: 20 }) })),
      yAxis: React__default['default'].createElement(LinearYAxis, { type: "value" }),
      series: React__default['default'].createElement(BarSeries, null),
      gridlines: React__default['default'].createElement(GridlineSeries, null),
      brush: null
  };

  const MarimekkoChart = (_a) => {
      var { series = React__default['default'].createElement(MarimekkoBarSeries, null), xAxis = (React__default['default'].createElement(LinearXAxis, { type: "category", tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { tickSize: 15 }) })), yAxis = (React__default['default'].createElement(LinearYAxis, { type: "value", tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { label: React__default['default'].createElement(LinearYAxisTickLabel, { rotation: false, format: (data) => `${data * 100}%` }) }) })) } = _a, rest = __rest(_a, ["series", "xAxis", "yAxis"]);
      return React__default['default'].createElement(BarChart, Object.assign({}, rest, { series: series, xAxis: xAxis, yAxis: yAxis }));
  };

  const StackedBarChart = (_a) => {
      var { series = React__default['default'].createElement(StackedBarSeries, null) } = _a, rest = __rest(_a, ["series"]);
      return React__default['default'].createElement(BarChart, Object.assign({}, rest, { series: series }));
  };

  const StackedNormalizedBarChart = (_a) => {
      var { series = React__default['default'].createElement(StackedNormalizedBarSeries, null), yAxis = (React__default['default'].createElement(LinearYAxis, { type: "value", tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { label: React__default['default'].createElement(LinearYAxisTickLabel, { rotation: false, format: (data) => `${data * 100}%` }) }) })) } = _a, rest = __rest(_a, ["series", "yAxis"]);
      return React__default['default'].createElement(BarChart, Object.assign({}, rest, { series: series, yAxis: yAxis }));
  };

  const HistogramBarChart = (_a) => {
      var { series = React__default['default'].createElement(HistogramBarSeries, null) } = _a, rest = __rest(_a, ["series"]);
      return React__default['default'].createElement(BarChart, Object.assign({}, rest, { series: series }));
  };

  var css_248z$d = ".HiveNode-module_node__3bcfx {\n  transition: opacity 100ms ease-in-out;\n  cursor: pointer;\n}\n\n.HiveNode-module_inactive__2bS6R {\n  opacity: 0.2;\n}\n";
  var css$d = {"node":"HiveNode-module_node__3bcfx","inactive":"HiveNode-module_inactive__2bS6R"};
  styleInject(css_248z$d);

  const HiveNode = ({ angle, radius, node, color, onClick, onMouseOver, onMouseOut, active, disabled }) => {
      // If the size exists on the node, use it to specify the node size.
      // Otherwise, calculate a relative size using the node count.
      let size = node.size;
      if (size === undefined) {
          size = node.count || 0;
      }
      return (React__default['default'].createElement("circle", { className: classNames__default['default'](css$d.node, {
              [css$d.inactive]: !active
          }), transform: `rotate(${getDegrees(angle(node.x))})`, cx: radius(node.y), r: size, style: { cursor: disabled ? 'initial' : 'cursor' }, fill: color(node.x), onClick: onClick, onMouseOver: onMouseOver, onMouseOut: onMouseOut }));
  };

  var css_248z$c = ".HiveAxis-module_axis__4FERZ {\n  stroke: #575f67;\n  stroke-width: 1.5px;\n}\n";
  var css$c = {"axis":"HiveAxis-module_axis__4FERZ"};
  styleInject(css_248z$c);

  const HiveAxis = ({ radius, index, angle, color }) => {
      const [axisStart, axisEnd] = radius.range();
      const axisLength = axisEnd - axisStart;
      return (React__default['default'].createElement(React.Fragment, null,
          React__default['default'].createElement("line", { className: css$c.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index))})`, x1: axisStart, x2: axisEnd }),
          React__default['default'].createElement("line", { className: css$c.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index)) + 90})`, x1: -axisLength / 20, x2: axisLength / 20, y1: -axisEnd, y2: -axisEnd }),
          React__default['default'].createElement("line", { className: css$c.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index)) + 90})`, x1: -axisStart / 3, x2: 0, y1: axisStart * -0.8, y2: axisStart * -1 }),
          React__default['default'].createElement("line", { className: css$c.axis, style: { stroke: color(index) }, transform: `rotate(${getDegrees(angle(index)) + 90})`, x1: 0, x2: axisStart / 3, y1: -axisStart, y2: axisStart * -0.8 })));
  };

  /**
   * Hive layout
   * Original: https://github.com/d3/d3-plugins/tree/master/hive
   */
  function hiveLayout() {
      let source = (d) => d.source;
      let target = (d) => d.target;
      let angle = (d) => d.angle;
      let startRadius = (d) => d.radius;
      let endRadius = startRadius;
      const arcOffset = -Math.PI / 2;
      const link = (d, i) => {
          let s = node(source, this, d, i);
          let t = node(target, this, d, i);
          let x;
          if (t.a < s.a) {
              x = t;
              t = s;
              s = x;
          }
          if (t.a - s.a > Math.PI) {
              s.a += 2 * Math.PI;
          }
          const a1 = s.a + (t.a - s.a) / 3;
          const a2 = t.a - (t.a - s.a) / 3;
          return s.r0 - s.r1 || t.r0 - t.r1
              ? 'M' +
                  Math.cos(s.a) * s.r0 +
                  ',' +
                  Math.sin(s.a) * s.r0 +
                  'L' +
                  Math.cos(s.a) * s.r1 +
                  ',' +
                  Math.sin(s.a) * s.r1 +
                  'C' +
                  Math.cos(a1) * s.r1 +
                  ',' +
                  Math.sin(a1) * s.r1 +
                  ' ' +
                  Math.cos(a2) * t.r1 +
                  ',' +
                  Math.sin(a2) * t.r1 +
                  ' ' +
                  Math.cos(t.a) * t.r1 +
                  ',' +
                  Math.sin(t.a) * t.r1 +
                  'L' +
                  Math.cos(t.a) * t.r0 +
                  ',' +
                  Math.sin(t.a) * t.r0 +
                  'C' +
                  Math.cos(a2) * t.r0 +
                  ',' +
                  Math.sin(a2) * t.r0 +
                  ' ' +
                  Math.cos(a1) * s.r0 +
                  ',' +
                  Math.sin(a1) * s.r0 +
                  ' ' +
                  Math.cos(s.a) * s.r0 +
                  ',' +
                  Math.sin(s.a) * s.r0
              : 'M' +
                  Math.cos(s.a) * s.r0 +
                  ',' +
                  Math.sin(s.a) * s.r0 +
                  'C' +
                  Math.cos(a1) * s.r1 +
                  ',' +
                  Math.sin(a1) * s.r1 +
                  ' ' +
                  Math.cos(a2) * t.r1 +
                  ',' +
                  Math.sin(a2) * t.r1 +
                  ' ' +
                  Math.cos(t.a) * t.r1 +
                  ',' +
                  Math.sin(t.a) * t.r1;
      };
      const node = (method, thiz, d, i) => {
          const n = method.call(thiz, d, i);
          const a = +(typeof angle === 'function' ? angle.call(thiz, n, i) : angle) +
              arcOffset;
          const r0 = +(typeof startRadius === 'function'
              ? startRadius.call(thiz, n, i)
              : startRadius);
          const r1 = startRadius === endRadius
              ? r0
              : +(typeof endRadius === 'function'
                  ? endRadius.call(thiz, n, i)
                  : endRadius);
          return { r0, r1, a };
      };
      link.source = (s) => {
          if (!s) {
              return source;
          }
          source = s;
          return link;
      };
      link.target = (t) => {
          if (!t) {
              return target;
          }
          target = t;
          return link;
      };
      link.angle = (a) => {
          if (!a) {
              return angle;
          }
          angle = a;
          return link;
      };
      link.radius = (r) => {
          if (!r) {
              return startRadius;
          }
          startRadius = endRadius = r;
          return link;
      };
      link.startRadius = (r) => {
          if (!r) {
              return startRadius;
          }
          startRadius = r;
          return link;
      };
      link.endRadius = (r) => {
          if (!r) {
              return endRadius;
          }
          endRadius = r;
          return link;
      };
      return link;
  }

  var css_248z$b = ".HiveLink-module_link__3WwlJ {\n  fill: none;\n  stroke-width: 1.5px;\n  stroke-opacity: 0.5;\n  transition: opacity 100ms ease-in-out;\n}\n\n.HiveLink-module_inactive__3KKt1 {\n  opacity: 0.7;\n}\n";
  var css$b = {"link":"HiveLink-module_link__3WwlJ","inactive":"HiveLink-module_inactive__3KKt1"};
  styleInject(css_248z$b);

  const HiveLink = ({ angle, radius, link, color, active, onMouseOver, onMouseOut }) => {
      const prepareData = () => {
          const hive = hiveLayout();
          return {
              hiveAngle: hive.angle((d) => angle(d.x)),
              hiveRadius: hive.radius((d) => radius(d.y))
          };
      };
      const { hiveAngle, hiveRadius } = React.useMemo(() => prepareData(), [
          angle,
          radius
      ]);
      const stroke = typeof color === 'string' ? color : color(link.source.x);
      return (React__default['default'].createElement("path", { className: classNames__default['default'](css$b.link, {
              [css$b.inactive]: !active
          }), d: `${hiveAngle(link)} ${hiveRadius(link)}`, stroke: stroke, onMouseOver: onMouseOver, onMouseOut: onMouseOut }));
  };

  var css_248z$a = ".HiveLabel-module_label__2I6Uz {\n  fill: rgba(255, 255, 255, 0.5);\n  font-size: 12px;\n  text-transform: uppercase;\n}\n";
  var css$a = {"label":"HiveLabel-module_label__2I6Uz"};
  styleInject(css_248z$a);

  const degrees = (radians) => {
      const res = (radians / Math.PI) * 180;
      return res > 90 ? res + 180 : res;
  };
  const translate = (d, outerRadius, padding) => d > 90 ? outerRadius + 8 + padding : -(outerRadius + padding);
  const HiveLabel = ({ index, text, angle, outerRadius, label }) => {
      const transform = React.useMemo(() => degrees(angle(index)), [angle, index]);
      return (React__default['default'].createElement("text", { dy: translate(transform, outerRadius, label.padding), className: css$a.label, strokeWidth: "0.01", textAnchor: "middle", transform: `rotate(${transform})` }, text));
  };

  var css_248z$9 = ".HiveTooltip-module_label__3PblP {\n  font-size: 16px;\n  margin-bottom: 3px;\n}\n\n.HiveTooltip-module_value__326K_ {\n  font-size: 13px;\n  color: rgba(255, 255, 255, 0.7);\n}\n";
  var css$9 = {"label":"HiveTooltip-module_label__3PblP","value":"HiveTooltip-module_value__326K_"};
  styleInject(css_248z$9);

  const HiveTooltip = ({ axis, nodes, node }) => {
      const { label } = axis[node.x];
      const count = nodes.filter((n) => n.value === node.value).length;
      return (React__default['default'].createElement(React__default['default'].Fragment, null,
          React__default['default'].createElement("div", { className: css$9.label },
              label,
              " - ",
              formatValue(node.value)),
          React__default['default'].createElement("div", { className: css$9.value },
              formatValue(count),
              " Total")));
  };

  const HivePlot = ({ axis = [], nodes = [], links = [], disabled = false, activeIds = [], label = {
      show: true,
      padding: 10
  }, width, height, innerRadius = 20, className, onNodeClick = () => undefined, onNodeMouseOver = () => undefined, onLinkMouseOver = () => undefined, onNodeMouseOut = () => undefined, onLinkMouseOut = () => undefined, tooltip = {
      show: true,
      placement: 'top',
      formatter: (attr) => attr.value
  }, colorScheme = {
      axis: ['#b1b2b6'],
      domain: ['#b1b2b6']
  } }) => {
      const [tooltipReference, setTooltipReference] = React.useState(null);
      const [nodeTooltipData, setNodeTooltipData] = React.useState(null);
      const [linkTooltipData, setLinkTooltipData] = React.useState(null);
      const [active, setActive] = React.useState(null);
      const onNodeMouseOverLocal = React.useCallback((node, event) => {
          if (!disabled) {
              const activeNodeIndex = nodes.indexOf(node);
              const activeNodes = {};
              for (const link of links) {
                  const { source, target } = link;
                  if (source.value === node.value || target.value === node.value) {
                      const next = target.value === node.value ? source : target;
                      const idx = nodes.indexOf(next);
                      activeNodes[`node-${idx}`] = true;
                  }
              }
              setTooltipReference(event.target);
              setNodeTooltipData(node);
              setActive(Object.assign(Object.assign({ [`node-${activeNodeIndex}`]: true }, activeNodes), links.reduce((accumulator, link, i) => {
                  if (link.source.value === node.value ||
                      link.target.value === node.value) {
                      accumulator[`link-${i}`] = true;
                  }
                  return accumulator;
              }, {})));
          }
          onNodeMouseOver({
              nativeEvent: event,
              node,
              links: getLinksForNode(node)
          });
      }, [links, nodes, onNodeMouseOver, disabled]);
      const activateAdjacentLinks = React.useCallback((links, target, accumulator) => {
          const activeLinks = [];
          links.forEach((childLink, index) => {
              if (target === childLink.source) {
                  if (!accumulator[`link-${index}`]) {
                      accumulator[`link-${index}`] = true;
                      activeLinks.push(childLink, ...activateAdjacentLinks(links, childLink.target, accumulator));
                  }
              }
          });
          return activeLinks;
      }, []);
      const activateLink = React.useCallback((link) => {
          const activeLinkIndex = links.indexOf(link);
          const activeLinksMap = {
              [`link-${activeLinkIndex}`]: true
          };
          const activeLinks = [
              link,
              ...activateAdjacentLinks(links, link.target, activeLinksMap)
          ];
          setActive(Object.assign(Object.assign({}, activeLinksMap), nodes.reduce((accumulator, node, i) => {
              for (const activeLink of activeLinks) {
                  const { source, target } = activeLink;
                  if (node === source || node === target) {
                      accumulator[`node-${i}`] = true;
                  }
              }
              return accumulator;
          }, {})));
      }, [nodes, links]);
      const onLinkMouseOverLocal = React.useCallback((link, event) => {
          if (!disabled) {
              setTooltipReference(event.target);
              setLinkTooltipData(link);
              activateLink(link);
          }
          onLinkMouseOver({
              nativeEvent: event,
              link
          });
      }, [onLinkMouseOver, disabled]);
      const getLinksForNode = React.useCallback((node) => links.filter((link) => link.source.value === node.value || link.target.value === node.value), [links]);
      const resetActive = React.useCallback(() => {
          setActive(null);
          setLinkTooltipData(null);
          setNodeTooltipData(null);
          setTooltipReference(null);
      }, []);
      const onNodeMouseOutLocal = React.useCallback((node, event) => {
          resetActive();
          onNodeMouseOut({
              nativeEvent: event,
              node,
              links: getLinksForNode(node)
          });
      }, [onNodeMouseOut]);
      const onLinkMouseOutLocal = React.useCallback((link, event) => {
          resetActive();
          onLinkMouseOut({
              nativeEvent: event,
              link
          });
      }, [onLinkMouseOut]);
      const onNodeClickLocal = React.useCallback((node, event) => {
          if (!disabled) {
              onNodeClick({
                  nativeEvent: event,
                  node,
                  links: getLinksForNode(node)
              });
          }
      }, [disabled, onNodeClick]);
      const prepareData = React.useCallback(({ dimension, innerRadius, colorScheme, axis, label }) => {
          let outerRadius = dimension / 2;
          if (label.show) {
              outerRadius = outerRadius - (10 + label.padding);
          }
          return {
              angle: d3Scale.scalePoint()
                  .domain(d3Array.range(axis.length + 1))
                  .range([0, 2 * Math.PI]),
              radius: d3Scale.scaleLinear().range([innerRadius, outerRadius]),
              axisColor: d3Scale.scaleOrdinal(colorScheme.axis).domain(d3Array.range(20)),
              domainColor: d3Scale.scaleOrdinal(colorScheme.domain).domain(d3Array.range(20)),
              outerRadius
          };
      }, []);
      const renderAxis = React.useCallback(({ angle, radius, axisColor, outerRadius }) => (React__default['default'].createElement(React.Fragment, null, axis.map((a, i) => (React__default['default'].createElement("g", { key: `axis-${a.attribute}` },
          React__default['default'].createElement(HiveAxis, { angle: angle, index: i, color: axisColor, radius: radius }),
          label.show && (React__default['default'].createElement(HiveLabel, { index: i, text: a.label, label: label, outerRadius: outerRadius, angle: angle }))))))), [axis, label]);
      const isActive = React.useCallback((nodeOrLink, index, type) => {
          // If no there is nothing active, then everything is active.
          if (!active && !activeIds.length) {
              return true;
          }
          // If this node is active because it is being hovered
          if (active && active[`${type}-${index}`]) {
              return true;
          }
          // If the ID matches one of the active IDs passed in the props
          if (!!activeIds.length &&
              !!nodeOrLink.id &&
              activeIds.includes(nodeOrLink.id)) {
              return true;
          }
          return false;
      }, [activeIds, active]);
      const renderLinks = React.useCallback(({ angle, radius, domainColor }) => (React__default['default'].createElement(React.Fragment, null, links.map((link, i) => {
          return (React__default['default'].createElement(HiveLink, { key: `${link.value}-${i}`, color: link.color || domainColor, active: isActive(link, i, 'link'), angle: angle, radius: radius, link: link, onMouseOver: (event) => onLinkMouseOverLocal(link, event), onMouseOut: (event) => onLinkMouseOutLocal(link, event) }));
      }))), [links]);
      const renderNodes = React.useCallback(({ angle, radius, domainColor }) => (React__default['default'].createElement(React.Fragment, null, nodes.map((node, i) => (React__default['default'].createElement(HiveNode, { node: node, key: `${node.value}-${i}`, active: isActive(node, i, 'node'), color: domainColor, radius: radius, angle: angle, disabled: disabled, onMouseOver: (event) => onNodeMouseOverLocal(node, event), onMouseOut: (event) => onNodeMouseOutLocal(node, event), onClick: (event) => onNodeClickLocal(node, event) }))))), [nodes, disabled]);
      const renderTooltip = React.useCallback(() => {
          const { formatter, placement, show } = tooltip;
          return (React__default['default'].createElement(React.Fragment, null, !disabled && show && (React__default['default'].createElement(realayers.Tooltip, { visible: !!active, reference: tooltipReference, placement: placement, content: () => formatter(axis, nodes, linkTooltipData, nodeTooltipData) ||
                  (nodeTooltipData ? (React__default['default'].createElement(HiveTooltip, { node: nodeTooltipData, nodes: nodes, axis: axis })) : null) }))));
      }, [
          tooltip,
          disabled,
          axis,
          nodes,
          active,
          tooltipReference,
          linkTooltipData,
          nodeTooltipData
      ]);
      const renderChart = React.useCallback(({ height: containerHeight, width: containerWidth }) => {
          const data = prepareData({
              dimension: Math.min(containerHeight, containerWidth),
              innerRadius,
              colorScheme,
              axis,
              label
          });
          return (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement("svg", { width: containerWidth, height: containerHeight, className: classNames__default['default'](className) },
                  React__default['default'].createElement("g", { transform: `translate(${containerWidth / 2}, ${containerHeight / 2 + innerRadius})` },
                      renderAxis(data),
                      renderLinks(data),
                      renderNodes(data))),
              renderTooltip()));
      }, [innerRadius, axis, colorScheme, label, className]);
      return (React__default['default'].createElement(ChartContainer, { height: height, width: width }, renderChart));
  };

  class LineSeries extends React.Component {
      render() {
          return React__default['default'].createElement(AreaSeries, Object.assign({}, this.props));
      }
  }
  LineSeries.defaultProps = Object.assign(Object.assign({}, AreaSeries.defaultProps), { area: null, line: React__default['default'].createElement(Line, { strokeWidth: 3 }) });
  class LineChart extends React.Component {
      render() {
          return React__default['default'].createElement(AreaChart, Object.assign({}, this.props));
      }
  }
  LineChart.defaultProps = Object.assign(Object.assign({}, AreaChart.defaultProps), { series: React__default['default'].createElement(LineSeries, null) });

  const Map$1 = ({ id, width, height, margins, className, markers, data, fill = 'rgba(255, 255, 255, 0.3)' }) => {
      const getProjection = React.useCallback(({ chartWidth, chartHeight }) => d3Geo.geoMercator().fitSize([chartWidth, chartHeight], data).center([0, 35]), [data]);
      const renderMarker = React.useCallback((marker, index, projection) => {
          const position = projection(marker.props.coordinates);
          if (!position) {
              console.warn(`Position for ${marker.props.coordinates.toString()} not found.`);
              return null;
          }
          return (React__default['default'].createElement(rdk.CloneElement, { element: marker, cx: position[0], cy: position[1], index: index }));
      }, []);
      const renderCountry = React.useCallback((point, index, path) => {
          // Exclude ATA
          if (point.id === '010') {
              return null;
          }
          return React__default['default'].createElement("path", { key: `path-${index}`, d: path(point), fill: fill });
      }, [fill]);
      const renderChart = React.useCallback((containerProps) => {
          if (!data) {
              return null;
          }
          const projection = getProjection(containerProps);
          const path = d3Geo.geoPath().projection(projection);
          return (React__default['default'].createElement(framerMotion.motion.g, { initial: {
                  opacity: 0
              }, animate: {
                  opacity: 1
              } },
              data.features.map((point, index) => renderCountry(point, index, path)),
              markers &&
                  markers.map((marker, index) => (React__default['default'].createElement(React.Fragment, { key: `marker-${index}` }, renderMarker(marker, index, projection))))));
      }, [data, markers]);
      return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, className: className }, (props) => renderChart(props)));
  };

  var css_248z$8 = ".MapMarker-module_marker__3uyJu {\n  fill: var(--color-primary);\n  cursor: pointer;\n}\n";
  var css$8 = {"marker":"MapMarker-module_marker__3uyJu"};
  styleInject(css_248z$8);

  // Set padding modifier for the tooltips
  const modifiers$1 = {
      offset: {
          offset: '0, 3px'
      }
  };
  const MapMarker = ({ size = 3, index, tooltip, cx, cy, onClick = () => undefined }) => {
      const ref = React.useRef(null);
      const [active, setActive] = React.useState(false);
      return (React__default['default'].createElement(React.Fragment, null,
          React__default['default'].createElement(framerMotion.motion.circle, { initial: {
                  opacity: 0,
                  scale: 0.02
              }, animate: {
                  opacity: 1,
                  scale: 1
              }, transition: {
                  delay: index * 0.3
              }, ref: ref, className: css$8.marker, cx: cx, cy: cy, r: size, onMouseEnter: () => setActive(true), onMouseLeave: () => setActive(false), onClick: onClick }),
          tooltip && (React__default['default'].createElement(realayers.Tooltip, { visible: active, reference: ref, modifiers: modifiers$1, content: tooltip }))));
  };

  const useInterpolate$1 = ({ data, animated, arc }) => {
      const prevEnter = React.useRef(null);
      const exit = React.useMemo(() => {
          const startAngle = data.startAngle;
          const endAngle = animated ? startAngle : data.endAngle;
          return Object.assign(Object.assign({}, data), { startAngle,
              endAngle });
      }, [data, animated]);
      const transition = React.useMemo(() => animated
          ? Object.assign({}, DEFAULT_TRANSITION) : {
          delay: 0
      }, [animated]);
      // Cache the previous for transition use later
      const previousEnter = prevEnter.current
          ? Object.assign({}, prevEnter.current) : undefined;
      prevEnter.current = Object.assign({}, data);
      const d = framerMotion.useMotionValue('');
      const prevPath = framerMotion.useMotionValue(exit);
      const spring = framerMotion.useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), { from: 0, to: 1 }));
      React.useEffect(() => {
          const from = previousEnter || prevPath.get();
          const interpolator = d3Interpolate.interpolate(from, data);
          const unsub = spring.onChange((v) => d.set(arc(interpolator(v))));
          prevPath.set(data);
          return unsub;
      }, [arc, data]);
      return {
          d,
          transition
      };
  };

  const PieArc = ({ color, data, arc, cursor = 'initial', animated = true, disabled = false, onClick = () => undefined, onMouseEnter = () => undefined, onMouseLeave = () => undefined, tooltip = React__default['default'].createElement(ChartTooltip, null) }) => {
      const arcRef = React.useRef(null);
      const { transition, d } = useInterpolate$1({ animated, arc, data });
      const [active, setActive] = React.useState(false);
      const fill = React.useMemo(() => (active ? chroma__default['default'](color).brighten(0.5) : color), [
          color,
          active
      ]);
      return (React__default['default'].createElement("g", { ref: arcRef },
          React__default['default'].createElement(framerMotion.motion.path, { role: "graphics-symbol", transition: transition, d: d, style: { cursor }, fill: fill, onMouseEnter: (event) => {
                  if (!disabled) {
                      setActive(true);
                      onMouseEnter({
                          value: data.data,
                          nativeEvent: event
                      });
                  }
              }, onMouseLeave: (event) => {
                  if (!disabled) {
                      setActive(false);
                      onMouseLeave({
                          value: data.data,
                          nativeEvent: event
                      });
                  }
              }, onClick: (event) => {
                  if (!disabled) {
                      onClick({
                          value: data.data,
                          nativeEvent: event
                      });
                  }
              } }),
          tooltip && !tooltip.props.disabled && (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: !!active, reference: arcRef, value: { y: data.data.data, x: data.data.key } }))));
  };

  /**
   * Finds intermediate point between two points so that this three points
   * can be nicely connected by two lines. One of this lines must be horizontal
   */
  function findBreakPoint([startX, startY], [endX, endY]) {
      let breakPoint = [0, 0];
      // whether we should create breakpoint near pie or near label
      const breakPointCondition = (endY - startY) * Math.sign(startY) >= 0;
      if (breakPointCondition) {
          // extend the line starting from startY till the endY
          let scale = Math.abs(endY / startY) || 1;
          const minScale = 1;
          const maxScale = Math.abs(endX / startX) || 1;
          scale = Math.max(Math.min(maxScale, scale), minScale);
          breakPoint = [startX * scale, endY];
      }
      else {
          // some arbitrary scale to ensure that break point will be placed
          // at some horizontal distance from the end point
          let scale = 0.85;
          const minScale = Math.abs(startX / endX) || 1;
          const maxScale = 1;
          scale = Math.max(Math.min(maxScale, scale), minScale);
          breakPoint = [endX * scale, startY];
      }
      return breakPoint;
  }

  const getTextAnchor = ({ startAngle, endAngle }) => 
  // we could also use the sign of position[0]
  startAngle + (endAngle - startAngle) / 2 < Math.PI ? 'start' : 'end';
  class PieArcLabel extends React.PureComponent {
      render() {
          const { centroid, data, lineStroke, padding, fontSize, fontFill, format, fontFamily, position, outerRadius, width, height } = this.props;
          const textAnchor = getTextAnchor(data);
          const text = format
              ? format(Object.assign(Object.assign({}, data.data), { textAnchor }))
              : formatValue(data.data.key);
          const [posX, posY] = position;
          // we want to have at least some pixels of straight line (margin)
          // from pie section till we start to change line direction
          const minRadius = outerRadius + 4;
          const startPoint = centroid(data);
          const innerPoint = d3Shape.arc()
              .innerRadius(minRadius)
              .outerRadius(minRadius)
              .centroid(data);
          const breakPoint = findBreakPoint(innerPoint, position);
          return (React__default['default'].createElement(framerMotion.motion.g, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
                  duration: 0.1
              } },
              typeof text === 'string' ? (React__default['default'].createElement(React__default['default'].Fragment, null,
                  React__default['default'].createElement("title", null, text),
                  React__default['default'].createElement("text", { dy: padding, fill: fontFill, fontSize: fontSize, fontFamily: fontFamily, textAnchor: textAnchor, style: {
                          shapeRendering: 'crispEdges',
                          transform: `translate3d(${posX}px,${posY}px, 0)`
                      } }, text))) : (React__default['default'].createElement("foreignObject", { width: width, height: height, style: {
                      transform: `translate3d(${textAnchor === 'start' ? posX : posX - width}px,${posY - height / 2}px, 0)`,
                      color: fontFill,
                      fontFamily,
                      fontSize
                  } }, text)),
              React__default['default'].createElement("polyline", { fill: "none", stroke: lineStroke, points: `${startPoint},${innerPoint},${breakPoint},${position}` })));
      }
  }
  PieArcLabel.defaultProps = {
      format: undefined,
      lineStroke: 'rgba(127,127,127,0.5)',
      fontFill: '#8F979F',
      fontSize: 11,
      fontFamily: 'sans-serif',
      padding: '.35em',
      height: 11
  };

  const factor = 1.2;
  const midAngle = (d) => d.startAngle + (d.endAngle - d.startAngle) / 2;
  const labelVisible = (arc) => arc.endAngle - arc.startAngle > Math.PI / 30;
  class PieArcSeries extends React.Component {
      constructor() {
          super(...arguments);
          /**
           * @param data
           * @param outerRadius - an outerRadius of the pie
           * @param minDistance - minimal vertical distance between adjacent labels
           */
          this.calculateLabelPositions = memoize__default['default']((data, outerRadius, minDistance, cornerRadius, padAngle, padRadius) => {
              const outerArcRadius = outerRadius * factor;
              const outerArc = d3Shape.arc()
                  .innerRadius(outerArcRadius)
                  .outerRadius(outerArcRadius)
                  .cornerRadius(cornerRadius)
                  .padAngle(padAngle)
                  .padRadius(padRadius);
              const positions = data.map((d) => {
                  if (!this.shouldDisplayLabel(d)) {
                      return null;
                  }
                  const pos = outerArc.centroid(d);
                  // reposition the labels to the left/right from outerArc centroid
                  // so that all labels won't collide with pie
                  // when we will vertically reposition them
                  pos[0] = outerArcRadius * (midAngle(d) < Math.PI ? 1 : -1);
                  return pos;
              });
              for (let i = 0; i < data.length - 1; i++) {
                  if (!positions[i]) {
                      continue;
                  }
                  const [aPosX, aPosY] = positions[i];
                  for (let j = i + 1; j < data.length; j++) {
                      if (!positions[j]) {
                          continue;
                      }
                      const [bPosX, bPosY] = positions[j];
                      // if they're on the same side (both with - or + sign)
                      if (bPosX * aPosX > 0) {
                          // if they're overlapping
                          const overlap = minDistance - Math.abs(bPosY - aPosY);
                          if (overlap > 0) {
                              // push the second up or down
                              positions[j][1] += Math.sign(bPosX) * overlap;
                          }
                      }
                  }
              }
              return positions;
          });
      }
      calculateRadius() {
          const { doughnut, arcWidth, label, width, height } = this.props;
          const minDimension = Math.min(width, height);
          let outerRadius = minDimension / 2;
          let labelWidth = 0;
          if (label) {
              labelWidth = label.props.width;
              if (labelWidth) {
                  const outerArcRadius = width / 2 - labelWidth;
                  outerRadius = Math.min(outerArcRadius / factor, height / 2);
              }
              else {
                  outerRadius = minDimension / 3;
                  labelWidth = width / 2 - outerRadius * factor;
              }
          }
          const innerRadius = doughnut ? outerRadius * (1 - arcWidth) : 0;
          return {
              outerRadius,
              innerRadius,
              labelWidth
          };
      }
      shouldDisplayLabel(arcData) {
          const { displayAllLabels } = this.props;
          return displayAllLabels || labelVisible(arcData);
      }
      innerArc(innerRadius, outerRadius, cornerRadius, padAngle, padRadius) {
          return (point) => {
              const newOuter = this.calculateOuterRadius(outerRadius, point);
              return d3Shape.arc()
                  .innerRadius(innerRadius)
                  .outerRadius(newOuter)
                  .cornerRadius(cornerRadius)
                  .padRadius(padRadius)
                  .padAngle(padAngle)(point);
          };
      }
      calculateOuterRadius(outerRadius, point) {
          const { explode, data } = this.props;
          if (!explode || data === undefined) {
              return outerRadius;
          }
          const maxVal = d3Array.max(data, (d) => d.value);
          return (outerRadius * point.value) / maxVal;
      }
      centroid(innerRadius, outerRadius) {
          return (data) => {
              const newOuter = this.calculateOuterRadius(outerRadius, data);
              return d3Shape.arc()
                  .innerRadius(innerRadius)
                  .outerRadius(newOuter)
                  .centroid(data);
          };
      }
      render() {
          const { animated, cornerRadius, padAngle, padRadius, label, arc, data } = this.props;
          const { outerRadius, innerRadius, labelWidth } = this.calculateRadius();
          const innerArc = this.innerArc(innerRadius, outerRadius, cornerRadius, padAngle, padRadius);
          const positions = label
              ? this.calculateLabelPositions(data, outerRadius, 
              // 4 is for vertical margins between labels
              label.props.height + 4, cornerRadius, padAngle, padRadius)
              : [];
          const centroid = this.centroid(innerRadius, outerRadius);
          return (React__default['default'].createElement(React.Fragment, null, data.map((arcData, index) => (React__default['default'].createElement(React.Fragment, { key: arcData.data.key.toString() },
              positions[index] && (React__default['default'].createElement(rdk.CloneElement, { element: label, data: arcData, centroid: centroid, outerRadius: outerRadius, width: labelWidth, position: positions[index] })),
              React__default['default'].createElement(rdk.CloneElement, { element: arc, data: arcData, animated: animated, arc: innerArc, color: getColor({
                      data: this.props.data,
                      colorScheme: this.props.colorScheme,
                      point: arcData.data,
                      index
                  }) }))))));
      }
  }
  PieArcSeries.defaultProps = {
      animated: true,
      colorScheme: 'cybertron',
      innerRadius: 0,
      cornerRadius: 0,
      padAngle: 0,
      padRadius: 0,
      explode: false,
      displayAllLabels: false,
      arcWidth: 0.25,
      label: React__default['default'].createElement(PieArcLabel, null),
      arc: React__default['default'].createElement(PieArc, null)
  };

  const PieChart = ({ id, width, height, className, displayAllLabels = false, data = [], margins = 10, series = React__default['default'].createElement(PieArcSeries, null) }) => {
      const getData = React.useMemo(() => {
          const pieLayout = d3Shape.pie().value((d) => Number(d.data));
          // Explode sort doesn't work right...
          if (!series.props.explode) {
              pieLayout.sort(null);
          }
          return pieLayout(data);
      }, [data, series]);
      return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: classNames__default['default'](className) }, ({ chartWidth, chartHeight }) => (React__default['default'].createElement(rdk.CloneElement, { element: series, data: getData, height: chartHeight, width: chartWidth, displayAllLabels: displayAllLabels }))));
  };

  const JUSTIFICATION = {
      justify: d3Sankey.sankeyJustify,
      center: d3Sankey.sankeyCenter,
      left: d3Sankey.sankeyLeft,
      right: d3Sankey.sankeyRight
  };
  class Sankey extends React.Component {
      constructor() {
          super(...arguments);
          this.state = { activeNodes: [], activeLinks: [] };
      }
      getNodeColor(node, index) {
          const { colorScheme, nodes } = this.props;
          if (colorScheme) {
              return getColor({
                  data: nodes,
                  colorScheme,
                  point: nodes[index],
                  index
              });
          }
          else {
              return node.props.color;
          }
      }
      onNodeActive(node) {
          const activeNodes = [node];
          const activeLinks = [];
          if (node.sourceLinks) {
              activeLinks.push(...node.sourceLinks);
              node.sourceLinks.forEach((sourceLink) => {
                  const sourceLinkTarget = sourceLink.target;
                  if (sourceLinkTarget.index !== node.index) {
                      activeNodes.push(sourceLinkTarget);
                  }
              });
          }
          if (node.targetLinks) {
              activeLinks.push(...node.targetLinks);
              node.targetLinks.forEach((targetLink) => {
                  const targetLinkSource = targetLink.source;
                  if (targetLinkSource.index !== node.index) {
                      activeNodes.push(targetLinkSource);
                  }
              });
          }
          this.setState({ activeNodes, activeLinks });
      }
      onLinkActive(link) {
          const activeNodes = [link.source, link.target];
          const activeLinks = [link];
          this.setState({ activeNodes, activeLinks });
      }
      onInactive() {
          this.setState({ activeNodes: [], activeLinks: [] });
      }
      renderNode(computedNode, index, chartWidth, node) {
          const { animated } = this.props;
          const { activeNodes } = this.state;
          const active = activeNodes.some((node) => node.index === computedNode.index);
          const disabled = activeNodes.length > 0 && !active;
          return (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: node, key: `node-${index}`, active: active, animated: animated, disabled: disabled, chartWidth: chartWidth, onMouseEnter: bind__default['default'](this.onNodeActive, this, computedNode), onMouseLeave: bind__default['default'](this.onInactive, this, computedNode) }, computedNode)));
      }
      renderNodes(nodes, chartWidth) {
          const nodeMap = new Map();
          this.props.nodes.forEach((node) => node && nodeMap.set(node.props.title, node));
          nodes.sort((a, b) => {
              const aX0 = a && a.x0 ? a.x0 : 0;
              const aY0 = a && a.y0 ? a.y0 : 0;
              const bX0 = b && b.x0 ? b.x0 : 0;
              const bY0 = b && b.y0 ? b.y0 : 0;
              return aX0 - bX0 || aY0 - bY0;
          });
          return (React__default['default'].createElement(React.Fragment, null, nodes.map((node, index) => this.renderNode(node, index, chartWidth, nodeMap.get(node.title)))));
      }
      renderLink(computedLink, index, chartId) {
          const { animated, links } = this.props;
          const { activeLinks } = this.state;
          const active = activeLinks.some((link) => link.index === computedLink.index);
          const disabled = activeLinks.length > 0 && !active;
          return (React__default['default'].createElement(rdk.CloneElement, Object.assign({ element: links[index], active: active, animated: animated, key: `link-${index}`, chartId: chartId, disabled: disabled }, computedLink, { onMouseEnter: bind__default['default'](this.onLinkActive, this, computedLink), onMouseLeave: bind__default['default'](this.onInactive, this, computedLink) })));
      }
      renderChart(containerProps) {
          const { id, chartWidth, chartHeight } = containerProps;
          const { justification, nodeWidth, nodePadding } = this.props;
          const nodesCopy = this.props.nodes.map((node, index) => ({
              id: node.props.id,
              title: node.props.title,
              color: this.getNodeColor(node, index)
          }));
          const linksCopy = this.props.links.map((link) => ({
              source: link.props.source,
              target: link.props.target,
              value: link.props.value
          }));
          const sankeyChart = d3Sankey.sankey()
              .extent([
              [1, 1],
              [chartWidth, chartHeight]
          ])
              .nodeWidth(nodeWidth)
              .nodePadding(nodePadding)
              .nodeAlign(JUSTIFICATION[justification])
              .nodeId((node) => node.id || node.index);
          const { nodes, links } = sankeyChart({
              nodes: nodesCopy,
              links: linksCopy
          });
          return (containerProps.chartSized && (React__default['default'].createElement(React.Fragment, { key: "group" },
              links.map((link, index) => this.renderLink(link, index, `sankey-${id}`)),
              this.renderNodes(nodes, chartWidth))));
      }
      render() {
          const { id, width, height, margins, className } = this.props;
          return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, className: className }, (props) => this.renderChart(props)));
      }
  }
  Sankey.defaultProps = {
      animated: true,
      justification: 'justify',
      nodeWidth: 15,
      nodePadding: 10
  };

  var css_248z$7 = ".SankeyLabel-module_label__2_aSZ {\n  font-size: 12px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  pointer-events: none;\n}\n";
  var css$7 = {"label":"SankeyLabel-module_label__2_aSZ"};
  styleInject(css_248z$7);

  class SankeyLabel extends React.Component {
      render() {
          const { active, chartWidth, className, fill, node, opacity, padding, visible } = this.props;
          const nodePositions = {
              x0: node && node.x0 ? node.x0 : 0,
              y0: node && node.y0 ? node.y0 : 0,
              x1: node && node.x1 ? node.x1 : 0,
              y1: node && node.y1 ? node.y1 : 0
          };
          const width = chartWidth || 0;
          const showRightSide = nodePositions.x0 < width / 2;
          const textAnchor = showRightSide ? 'start' : 'end';
          return (visible &&
              node && (React__default['default'].createElement("text", { className: classNames__default['default'](css$7.label, className), x: showRightSide ? nodePositions.x1 + 6 : nodePositions.x0 - 6, y: (nodePositions.y1 + nodePositions.y0) / 2, dy: "0.35em", textAnchor: textAnchor, fill: fill, opacity: opacity(active), style: { padding } }, node.title)));
      }
  }
  SankeyLabel.defaultProps = {
      active: false,
      fill: '#fff',
      location: 'outside',
      opacity: (active) => (active ? 1 : 0.5),
      visible: true
  };

  const DEFAULT_COLOR = 'rgba(255, 255, 255, 0.2)';

  var css_248z$6 = ".SankeyLink-module_link__hzYa8 {\n  fill: none;\n  transition: stroke-opacity 100ms ease-in-out, stroke 100ms ease-in-out;\n  mix-blend-mode: screen;\n}\n\n.SankeyLink-module_tooltip__28O9b {\n  text-align: center;\n  pointer-events: none;\n}\n\n.SankeyLink-module_tooltip__28O9b .SankeyLink-module_tooltipLabel__odxY7 {\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: rgba(255, 255, 255, 1);\n    text-align: center;\n  }\n\n.SankeyLink-module_tooltip__28O9b .SankeyLink-module_tooltipValue__cTGcv {\n    font-size: 13px;\n    color: rgba(255, 255, 255, 0.7);\n    text-align: center;\n  }\n";
  var css$6 = {"link":"SankeyLink-module_link__hzYa8","tooltip":"SankeyLink-module_tooltip__28O9b","tooltipLabel":"SankeyLink-module_tooltipLabel__odxY7","tooltipValue":"SankeyLink-module_tooltipValue__cTGcv"};
  styleInject(css_248z$6);

  class SankeyLink extends React.Component {
      constructor() {
          super(...arguments);
          this.link = React.createRef();
          this.state = {};
      }
      getEnter() {
          const path = d3Sankey.sankeyLinkHorizontal();
          const d = path(this.getLink());
          const strokeWidth = Math.max(1, this.props.width);
          return { d, strokeWidth };
      }
      getExit() {
          const path = d3Sankey.sankeyLinkHorizontal();
          const d = path(Object.assign(Object.assign({}, this.getLink()), { width: 0 }));
          return { d, strokeWidth: 0 };
      }
      getLink() {
          const { index, value, y0, y1, source, target, width } = this.props;
          return { index, y0, y1, value, width, source, target };
      }
      getStroke() {
          const { color, index, gradient, chartId } = this.props;
          return gradient ? `url(#${chartId}-gradient-${index})` : color;
      }
      onMouseEnter(event) {
          this.setState({ hovered: true });
          this.props.onMouseEnter(event);
      }
      onMouseLeave(event) {
          this.setState({ hovered: false });
          this.props.onMouseLeave(event);
      }
      renderLink() {
          const { active, className, disabled, index, opacity, style, onClick } = this.props;
          const enterProps = this.getEnter();
          const exitProps = this.getExit();
          return (React__default['default'].createElement("g", { ref: this.link },
              React__default['default'].createElement(framerMotion.motion.path, { key: `sankey-link-${enterProps.d}-${index}`, className: classNames__default['default'](css$6.link, className), style: style, initial: exitProps, animate: enterProps, exit: exitProps, transition: {
                      duration: 0.5
                  }, stroke: this.getStroke(), strokeOpacity: opacity(active, disabled), onClick: onClick, onMouseEnter: bind__default['default'](this.onMouseEnter, this), onMouseLeave: bind__default['default'](this.onMouseLeave, this) })));
      }
      renderTooltipContent() {
          const { source, target, value } = this.props;
          return (React__default['default'].createElement("div", { className: css$6.tooltip },
              React__default['default'].createElement("div", { className: css$6.tooltipLabel }, `${source.title} → ${target.title}`),
              React__default['default'].createElement("div", { className: css$6.tooltipValue }, formatValue(value))));
      }
      render() {
          const { gradient, index, source, target, tooltip, chartId } = this.props;
          const linkSource = source;
          const linkTarget = target;
          return (React__default['default'].createElement(React.Fragment, null,
              gradient && (React__default['default'].createElement("linearGradient", { id: `${chartId}-gradient-${index}`, gradientUnits: "userSpaceOnUse", x1: linkSource.x1, x2: linkTarget.x0 },
                  React__default['default'].createElement("stop", { offset: "0%", stopColor: linkSource.color }),
                  React__default['default'].createElement("stop", { offset: "100%", stopColor: linkTarget.color }))),
              this.renderLink(),
              !tooltip.props.disabled && (React__default['default'].createElement(rdk.CloneElement, { content: this.renderTooltipContent.bind(this), element: tooltip, visible: this.state.hovered, reference: this.link }))));
      }
  }
  SankeyLink.defaultProps = {
      active: false,
      animated: true,
      color: DEFAULT_COLOR,
      disabled: false,
      gradient: true,
      opacity: (active, disabled) => (active ? 0.5 : disabled ? 0.1 : 0.35),
      tooltip: (React__default['default'].createElement(realayers.Tooltip, { followCursor: true, modifiers: {
              offset: {
                  offset: '0, 5px'
              }
          } })),
      width: 0,
      onClick: () => undefined,
      onMouseEnter: () => undefined,
      onMouseLeave: () => undefined
  };

  var css_248z$5 = ".SankeyNode-module_node__1rkj0 {\n  transition: opacity 100ms ease-in-out, fill-opacity 100ms ease-in-out;\n}\n\n.SankeyNode-module_tooltip__1SZ4e {\n  text-align: center;\n  padding: 0 8px;\n  pointer-events: none;\n}\n\n.SankeyNode-module_tooltip__1SZ4e .SankeyNode-module_tooltipLabel__HfJ93 {\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: rgba(255, 255, 255, 1);\n    text-align: center;\n  }\n\n.SankeyNode-module_tooltip__1SZ4e .SankeyNode-module_tooltipValue__lnd_m {\n    font-size: 13px;\n    color: rgba(255, 255, 255, 0.7);\n    text-align: center;\n  }\n";
  var css$5 = {"node":"SankeyNode-module_node__1rkj0","tooltip":"SankeyNode-module_tooltip__1SZ4e","tooltipLabel":"SankeyNode-module_tooltipLabel__HfJ93","tooltipValue":"SankeyNode-module_tooltipValue__lnd_m"};
  styleInject(css_248z$5);

  class SankeyNode extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {};
          this.rect = React.createRef();
      }
      getNode() {
          const { id, title, color, sourceLinks, targetLinks, value, index, x0, x1, y0, y1 } = this.props;
          return {
              id,
              title,
              color,
              sourceLinks,
              targetLinks,
              value,
              index,
              x0,
              x1,
              y0,
              y1
          };
      }
      onMouseEnter(event) {
          this.setState({ hovered: true });
          this.props.onMouseEnter(event);
      }
      onMouseLeave(event) {
          this.setState({ hovered: false });
          this.props.onMouseLeave(event);
      }
      renderNode() {
          const { active, className, color, disabled, index, opacity, style, width, x0, x1, y0, y1, onClick } = this.props;
          const nodeWidth = width || (x1 && x0 && x1 - x0 > 0 ? x1 - x0 : 0);
          const nodeHeight = y1 && y0 && y1 - y0 > 0 ? y1 - y0 : 0;
          return (React__default['default'].createElement(framerMotion.motion.g, { ref: this.rect },
              React__default['default'].createElement(framerMotion.motion.rect, { key: `sankey-node-${x0}-${x1}-${y0}-${y1}-${index}`, className: classNames__default['default'](css$5.node, className), fillOpacity: opacity(active, disabled), style: style, width: nodeWidth, height: nodeHeight, fill: color, initial: {
                      opacity: 0,
                      attrX: x0,
                      attrY: y0
                  }, animate: {
                      opacity: 1,
                      attrX: x0,
                      attrY: y0
                  }, exit: {
                      opacity: 0,
                      attrX: x0,
                      attrY: y0
                  }, transition: {
                      duration: 0.1
                  }, onClick: onClick, onMouseEnter: bind__default['default'](this.onMouseEnter, this), onMouseLeave: bind__default['default'](this.onMouseLeave, this) })));
      }
      renderTooltipContent() {
          const { title, value } = this.props;
          return (React__default['default'].createElement("div", { className: css$5.tooltip },
              React__default['default'].createElement("div", { className: css$5.tooltipLabel }, title),
              React__default['default'].createElement("div", { className: css$5.tooltipValue }, formatValue(value))));
      }
      render() {
          const { active, chartWidth, label, tooltip, showLabel } = this.props;
          return (React__default['default'].createElement(React.Fragment, null,
              this.renderNode(),
              showLabel && (React__default['default'].createElement(rdk.CloneElement, { active: active, element: label, chartWidth: chartWidth, node: this.getNode() })),
              !tooltip.props.disabled && (React__default['default'].createElement(rdk.CloneElement, { content: this.renderTooltipContent.bind(this), element: tooltip, visible: this.state.hovered, reference: this.rect }))));
      }
  }
  SankeyNode.defaultProps = {
      active: false,
      animated: true,
      color: DEFAULT_COLOR,
      disabled: false,
      label: React__default['default'].createElement(SankeyLabel, null),
      opacity: (active, disabled) => (active ? 1 : disabled ? 0.2 : 0.9),
      showLabel: true,
      tooltip: (React__default['default'].createElement(realayers.Tooltip, { followCursor: true, modifiers: {
              offset: {
                  offset: '0, 5px'
              }
          } })),
      onClick: () => undefined,
      onMouseEnter: () => undefined,
      onMouseLeave: () => undefined
  };

  class SparklineChart extends React.Component {
      render() {
          return React__default['default'].createElement(LineChart, Object.assign({}, this.props));
      }
  }
  SparklineChart.defaultProps = {
      gridlines: null,
      series: (React__default['default'].createElement(AreaSeries, { symbols: React__default['default'].createElement(PointSeries, { show: "hover" }), interpolation: "smooth", markLine: null, area: null, line: React__default['default'].createElement(Line, { strokeWidth: 2 }) })),
      yAxis: (React__default['default'].createElement(LinearYAxis, { scaled: true, type: "value", axisLine: null, tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { line: null, label: null }) })),
      xAxis: (React__default['default'].createElement(LinearXAxis, { type: "time", scaled: true, axisLine: null, tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { line: null, label: null }) }))
  };

  class AreaSparklineChart extends React.Component {
      render() {
          return React__default['default'].createElement(AreaChart, Object.assign({}, this.props));
      }
  }
  AreaSparklineChart.defaultProps = {
      gridlines: null,
      series: (React__default['default'].createElement(AreaSeries, { symbols: React__default['default'].createElement(PointSeries, { show: "hover" }), interpolation: "smooth", markLine: null, area: React__default['default'].createElement(Area, { mask: React__default['default'].createElement(Stripes, null), gradient: React__default['default'].createElement(Gradient, { stops: [
                      React__default['default'].createElement(GradientStop, { offset: "10%", stopOpacity: 0, key: "start" }),
                      React__default['default'].createElement(GradientStop, { offset: "80%", stopOpacity: 1, key: "stop" })
                  ] }) }), line: React__default['default'].createElement(Line, { strokeWidth: 3 }) })),
      yAxis: (React__default['default'].createElement(LinearYAxis, { type: "value", scaled: true, axisLine: null, tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { line: null, label: null }) })),
      xAxis: (React__default['default'].createElement(LinearXAxis, { type: "time", scaled: true, axisLine: null, tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { line: null, label: null }) }))
  };

  class BarSparklineChart extends React.Component {
      render() {
          return React__default['default'].createElement(BarChart, Object.assign({}, this.props));
      }
  }
  BarSparklineChart.defaultProps = {
      gridlines: null,
      series: React__default['default'].createElement(BarSeries, { colorScheme: schemes.cybertron[0] }),
      yAxis: (React__default['default'].createElement(LinearYAxis, { type: "value", axisLine: null, tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { line: null, label: null }) })),
      xAxis: (React__default['default'].createElement(LinearXAxis, { type: "category", axisLine: null, tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { line: null, label: null }) }))
  };

  const SonarChart = (props) => (React__default['default'].createElement(StackedBarChart, Object.assign({}, props, { margins: 0, gridlines: null, series: React__default['default'].createElement(StackedBarSeries, { type: "stackedDiverging", colorScheme: "rgb(17, 207, 247)", tooltip: React__default['default'].createElement(TooltipArea, { tooltip: React__default['default'].createElement(ChartTooltip, { followCursor: true, modifiers: {
                      offset: '5px, 5px'
                  }, content: (data, color) => (React__default['default'].createElement(TooltipTemplate, { color: color, value: {
                          x: formatValue(data.x),
                          y: `${formatValue(Math.abs(data.data[0].y))}`
                      } })) }) }), bar: [
              React__default['default'].createElement(Bar, { key: "first", width: 1, rangeLines: null, minHeight: 1, gradient: React__default['default'].createElement(Gradient, { stops: [
                          React__default['default'].createElement(GradientStop, { offset: "5%", stopOpacity: 0.7, key: "start" }),
                          React__default['default'].createElement(GradientStop, { offset: "90%", stopOpacity: 1, key: "stop" })
                      ] }) }),
              React__default['default'].createElement(Bar, { key: "second", width: 1, rangeLines: null, minHeight: 1, gradient: React__default['default'].createElement(Gradient, { stops: [
                          React__default['default'].createElement(GradientStop, { offset: "5%", stopOpacity: 1, key: "stop" }),
                          React__default['default'].createElement(GradientStop, { offset: "90%", stopOpacity: 0.7, key: "start" })
                      ] }) })
          ] }), yAxis: React__default['default'].createElement(LinearYAxis, { type: "value", axisLine: null, tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { line: null, label: null }) }), xAxis: React__default['default'].createElement(LinearXAxis, { type: "category", axisLine: null, tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { line: null, label: null }) }) })));

  const RadialArea = ({ id, data, className, yScale, color, animated, outerRadius, xScale, innerRadius, interpolation, gradient = React__default['default'].createElement(RadialGradient, null) }) => {
      const transition = React.useMemo(() => animated
          ? Object.assign({}, DEFAULT_TRANSITION) : {
          type: false,
          delay: 0
      }, [animated]);
      const getFill = React.useCallback((c) => {
          if (!gradient) {
              return c;
          }
          return `url(#${id}-gradient)`;
      }, [id, gradient]);
      const getPath = React.useCallback((d) => {
          const curve = interpolation === 'smooth' ? d3Shape.curveCardinalClosed : d3Shape.curveLinearClosed;
          const radialFn = d3Shape.radialArea()
              .angle((dd) => xScale(dd.x))
              .innerRadius((_) => innerRadius)
              .outerRadius((d) => yScale(d.y))
              .curve(curve);
          return radialFn(d);
      }, [xScale, yScale, interpolation, innerRadius]);
      const enter = React.useMemo(() => ({
          d: getPath(data),
          opacity: 1
      }), [data, getPath]);
      const exit = React.useMemo(() => {
          const [yStart] = yScale.domain();
          return {
              d: getPath(data.map((d) => (Object.assign(Object.assign({}, d), { y: yStart })))),
              opacity: 0
          };
      }, [data, getPath, yScale]);
      const fill = color(data, 0);
      return (React__default['default'].createElement(React.Fragment, null,
          React__default['default'].createElement(MotionPath, { custom: {
                  enter,
                  exit
              }, transition: transition, pointerEvents: "none", className: className, fill: getFill(color) }),
          gradient && (React__default['default'].createElement(rdk.CloneElement, { element: gradient, id: `${id}-gradient`, radius: outerRadius, color: fill }))));
  };

  const RadialLine = ({ xScale, yScale, className, color, data, interpolation, strokeWidth = 2, animated = true }) => {
      const getPath = React.useCallback((preData) => {
          const curve = interpolation === 'smooth' ? d3Shape.curveCardinalClosed : d3Shape.curveLinearClosed;
          const radialFn = d3Shape.radialLine()
              .angle((d) => xScale(d.x))
              .radius((d) => yScale(d.y))
              .curve(curve);
          return radialFn(preData);
      }, [xScale, yScale, interpolation]);
      const transition = React.useMemo(() => animated
          ? Object.assign({}, DEFAULT_TRANSITION) : {
          type: false,
          delay: 0
      }, [animated]);
      const fill = color(data, 0);
      const enter = React.useMemo(() => ({
          d: getPath(data),
          opacity: 1
      }), [data, getPath]);
      const exit = React.useMemo(() => {
          const [yStart] = yScale.domain();
          return {
              d: getPath(data.map((d) => (Object.assign(Object.assign({}, d), { y: yStart })))),
              opacity: 0
          };
      }, [data, yScale, getPath]);
      return (React__default['default'].createElement(MotionPath, { custom: {
              enter,
              exit
          }, transition: transition, className: className, pointerEvents: "none", stroke: fill, fill: "none", strokeWidth: strokeWidth }));
  };

  var css_248z$4 = ".RadialScatterPoint-module_inactive__1RkCR {\n  opacity: 0.4;\n  transition: opacity 200ms ease-in-out;\n}\n";
  var css$4 = {"inactive":"RadialScatterPoint-module_inactive__1RkCR"};
  styleInject(css_248z$4);

  class RadialScatterPoint extends React.Component {
      constructor() {
          super(...arguments);
          this.ref = React.createRef();
          this.state = {
              hovered: false
          };
      }
      onMouseEnter(event) {
          this.setState({ hovered: true });
          const { onMouseEnter, data } = this.props;
          onMouseEnter({
              value: data,
              nativeEvent: event
          });
      }
      onMouseLeave(event) {
          this.setState({ hovered: false });
          const { onMouseLeave, data } = this.props;
          onMouseLeave({
              value: data,
              nativeEvent: event
          });
      }
      onClick(event) {
          const { onClick, data } = this.props;
          onClick({
              value: data,
              nativeEvent: event
          });
      }
      getTranslate(data) {
          const { xScale, yScale } = this.props;
          const fn = d3Shape.radialLine()
              .radius((d) => yScale(d.y))
              .angle((d) => xScale(d.x));
          // Parse the generated path to get point coordinates
          // Ref: https://bit.ly/2CnZcPl
          const path = fn([data]);
          if (path) {
              const [translateX, translateY] = path.slice(1).slice(0, -1).split(',');
              return {
                  translateX: parseFloat(translateX),
                  translateY: parseFloat(translateY)
              };
          }
      }
      getTransition() {
          const { animated, index } = this.props;
          if (animated) {
              return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: index * 0.005 });
          }
          else {
              return {
                  type: false,
                  delay: 0
              };
          }
      }
      render() {
          const { size, data, color, index, symbol, active, tooltip, yScale, className } = this.props;
          const { hovered } = this.state;
          const fill = typeof color === 'function' ? color(data, index) : color;
          const transform = this.getTranslate(data);
          const sizeVal = typeof size === 'function' ? size(data) : size;
          const transition = this.getTransition();
          const [yStart] = yScale.domain();
          const exitTransform = this.getTranslate(Object.assign(Object.assign({}, data), { y: yStart }));
          return (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement(framerMotion.motion.g, { initial: Object.assign(Object.assign({}, exitTransform), { opacity: 0 }), animate: Object.assign(Object.assign({}, transform), { opacity: 1 }), exit: Object.assign(Object.assign({}, exitTransform), { opacity: 0 }), transition: transition, ref: this.ref, onMouseEnter: bind__default['default'](this.onMouseEnter, this), onMouseLeave: bind__default['default'](this.onMouseLeave, this), onClick: bind__default['default'](this.onClick, this), className: classNames__default['default'](className, {
                      [css$4.inactive]: !active
                  }) },
                  symbol && symbol(data),
                  !symbol && React__default['default'].createElement("circle", { r: sizeVal, fill: fill })),
              tooltip && (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: hovered, reference: this.ref, value: data }))));
      }
  }
  RadialScatterPoint.defaultProps = {
      size: 3,
      color: schemes.cybertron[0],
      tooltip: React__default['default'].createElement(ChartTooltip, null),
      active: true,
      onClick: () => undefined,
      onMouseEnter: () => undefined,
      onMouseLeave: () => undefined
  };

  class RadialScatterSeries extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {
              activeIds: []
          };
      }
      onMouseEnter({ value }) {
          // Only perform this on unmanaged activations
          if (!this.props.activeIds) {
              this.setState({
                  activeIds: [value.id]
              });
          }
      }
      onMouseLeave() {
          // Only perform this on unmanaged activations
          if (!this.props.activeIds) {
              this.setState({
                  activeIds: []
              });
          }
      }
      renderPoint(data, index) {
          const { point, xScale, yScale, animated } = this.props;
          let dataId;
          if (data.id) {
              dataId = data.id;
          }
          else {
              console.warn('No \'id\' property provided for scatter point; provide one via \'id\'.');
          }
          const key = dataId || index;
          const activeIds = this.props.activeIds || this.state.activeIds;
          const active = !(activeIds && activeIds.length) || activeIds.includes(dataId);
          const visible = point.props.visible;
          if (visible && !visible(data, index)) {
              return React__default['default'].createElement(React.Fragment, { key: key });
          }
          return (React__default['default'].createElement(rdk.CloneElement, { element: point, key: key, data: data, index: index, active: active, xScale: xScale, yScale: yScale, animated: animated, onMouseEnter: bind__default['default'](this.onMouseEnter, this), onMouseLeave: bind__default['default'](this.onMouseLeave, this) }));
      }
      render() {
          const { data } = this.props;
          return React__default['default'].createElement(React.Fragment, null, data.map((d, i) => this.renderPoint(d, i)));
      }
  }
  RadialScatterSeries.defaultProps = {
      point: React__default['default'].createElement(RadialScatterPoint, null),
      animated: true
  };

  class RadialScatterPlot extends React.Component {
      constructor() {
          super(...arguments);
          this.getScales = memoize__default['default']((preData, outerRadius, innerRadius) => {
              const data = buildShallowChartData(preData);
              const yDomain = getYDomain({ data, scaled: false });
              const xDomain = getXDomain({ data });
              const xScale = d3Scale.scaleTime()
                  .range([0, 2 * Math.PI])
                  .domain(xDomain);
              const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);
              return {
                  yScale,
                  xScale,
                  data
              };
          });
      }
      renderChart(containerProps) {
          const { chartWidth, chartHeight, id } = containerProps;
          const { innerRadius, series, axis } = this.props;
          const outerRadius = Math.min(chartWidth, chartHeight) / 2;
          const { yScale, xScale, data } = this.getScales(this.props.data, outerRadius, innerRadius);
          return (React__default['default'].createElement(React.Fragment, null,
              axis && (React__default['default'].createElement(rdk.CloneElement, { element: axis, xScale: xScale, height: chartHeight, width: chartWidth, innerRadius: innerRadius })),
              React__default['default'].createElement(rdk.CloneElement, { element: series, id: id, data: data, xScale: xScale, yScale: yScale })));
      }
      render() {
          const { id, width, height, margins, className } = this.props;
          return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: className }, this.renderChart.bind(this)));
      }
  }
  RadialScatterPlot.defaultProps = {
      innerRadius: 80,
      margins: 75,
      axis: React__default['default'].createElement(RadialAxis, null),
      series: React__default['default'].createElement(RadialScatterSeries, null)
  };

  const RadialPointSeries = ({ data, xScale, yScale, animated, color, activeValues, show = 'hover', point = React__default['default'].createElement(RadialScatterPoint, null) }) => {
      const isVisible = React.useCallback((point, index) => {
          const isActive = activeValues && point && isEqual__default['default'](activeValues.x, point.x);
          if (show === 'hover') {
              return isActive;
          }
          else if (show === 'first') {
              if (activeValues) {
                  return isActive;
              }
              else {
                  return index === 0;
              }
          }
          else if (show === 'last') {
              if (activeValues) {
                  return isActive;
              }
              else {
                  return index === data.length - 1;
              }
          }
          return show;
      }, [data, activeValues, point, show]);
      return (React__default['default'].createElement(RadialScatterSeries, { animated: animated, data: data, xScale: xScale, yScale: yScale, point: React__default['default'].createElement(rdk.CloneElement, { element: point, color: color, tooltip: null, visible: isVisible }) }));
  };

  class RadialAreaSeries extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {};
      }
      getColor(point, index) {
          const { colorScheme, data } = this.props;
          return getColor({
              colorScheme,
              data,
              index,
              point
          });
      }
      onValueEnter(event) {
          this.setState({
              activeValues: event.value
          });
      }
      onValueLeave() {
          this.setState({
              activeValues: undefined
          });
      }
      renderArea() {
          const { area, id, xScale, yScale, data, interpolation, animated, innerRadius, outerRadius } = this.props;
          return (React__default['default'].createElement(rdk.CloneElement, { element: area, id: `${id}-radial-area`, xScale: xScale, yScale: yScale, animated: animated, color: this.getColor.bind(this), data: data, interpolation: interpolation, outerRadius: outerRadius, innerRadius: innerRadius }));
      }
      renderLine() {
          const { line, xScale, yScale, data, animated, interpolation } = this.props;
          return (React__default['default'].createElement(rdk.CloneElement, { element: line, xScale: xScale, yScale: yScale, animated: animated, interpolation: interpolation, color: this.getColor.bind(this), data: data }));
      }
      renderSymbols() {
          const { xScale, yScale, animated, area, symbols, data } = this.props;
          const { activeValues } = this.state;
          // Animations are only valid for Area
          const activeSymbols = (symbols && symbols.props.activeValues) || activeValues;
          const isAnimated = area !== undefined && animated && !activeSymbols;
          return (React__default['default'].createElement(rdk.CloneElement, { element: symbols, activeValues: activeValues, xScale: xScale, yScale: yScale, data: data, animated: isAnimated, color: this.getColor.bind(this) }));
      }
      render() {
          const { area, line, symbols, tooltip, xScale, yScale, data, id, width, height, innerRadius, outerRadius } = this.props;
          return (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, xScale: xScale, yScale: yScale, data: data, height: height, width: width, isRadial: true, innerRadius: innerRadius, outerRadius: outerRadius, color: this.getColor.bind(this), onValueEnter: bind__default['default'](this.onValueEnter, this), onValueLeave: bind__default['default'](this.onValueLeave, this) },
              React__default['default'].createElement("g", { clipPath: `url(#${id}-path)` },
                  area && this.renderArea(),
                  line && this.renderLine(),
                  symbols && this.renderSymbols())));
      }
  }
  RadialAreaSeries.defaultProps = {
      colorScheme: schemes.cybertron[0],
      interpolation: 'smooth',
      animated: true,
      area: React__default['default'].createElement(RadialArea, null),
      line: React__default['default'].createElement(RadialLine, null),
      symbols: React__default['default'].createElement(RadialPointSeries, null),
      tooltip: React__default['default'].createElement(TooltipArea, null)
  };

  const RadialAreaChart = ({ id, width, height, className, data, innerRadius = 0.1, series = React__default['default'].createElement(RadialAreaSeries, null), axis = React__default['default'].createElement(RadialAxis, null), margins = 75 }) => {
      const getScales = React.useCallback((preData, outerRadius, innerRadius) => {
          const d = buildShallowChartData(preData);
          const yDomain = getYDomain({ data: d, scaled: false });
          let xScale;
          if ((axis === null || axis === void 0 ? void 0 : axis.props.type) === 'category') {
              const xDomain = uniqueBy(d, (dd) => dd.x);
              xScale = d3Scale.scaleBand()
                  .range([0, 2 * Math.PI])
                  .domain(xDomain);
          }
          else {
              const xDomain = getXDomain({ data: d });
              xScale = d3Scale.scaleTime()
                  .range([0, 2 * Math.PI])
                  .domain(xDomain);
          }
          const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);
          return {
              yScale,
              xScale,
              result: d
          };
      }, []);
      const renderChart = React.useCallback((containerProps) => {
          const { chartWidth, chartHeight, id } = containerProps;
          const outerRadius = Math.min(chartWidth, chartHeight) / 2;
          const { yScale, xScale, result } = getScales(data, outerRadius, innerRadius);
          return (React__default['default'].createElement(React.Fragment, null,
              axis && (React__default['default'].createElement(rdk.CloneElement, { element: axis, xScale: xScale, height: chartHeight, width: chartWidth, innerRadius: innerRadius })),
              React__default['default'].createElement(rdk.CloneElement, { element: series, id: id, data: result, xScale: xScale, yScale: yScale, height: chartHeight, width: chartWidth, outerRadius: outerRadius, innerRadius: innerRadius })));
      }, [data, series, id, innerRadius, axis]);
      return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: className }, renderChart));
  };

  const pi = Math.PI,
      tau = 2 * pi,
      epsilon = 1e-6,
      tauEpsilon = tau - epsilon;

  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }

  function path() {
    return new Path;
  }

  Path.prototype = path.prototype = {
    constructor: Path,
    moveTo: function(x, y) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x, y) {
      this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
      this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
      x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
      var x0 = this._x1,
          y0 = this._y1,
          x21 = x2 - x1,
          y21 = y2 - y1,
          x01 = x0 - x1,
          y01 = y0 - y1,
          l01_2 = x01 * x01 + y01 * y01;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x1,y1).
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
      else if (!(l01_2 > epsilon));

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
        this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
      }

      // Otherwise, draw an arc!
      else {
        var x20 = x2 - x0,
            y20 = y2 - y0,
            l21_2 = x21 * x21 + y21 * y21,
            l20_2 = x20 * x20 + y20 * y20,
            l21 = Math.sqrt(l21_2),
            l01 = Math.sqrt(l01_2),
            l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
            t01 = l / l01,
            t21 = l / l21;

        // If the start tangent is not coincident with (x0,y0), line to.
        if (Math.abs(t01 - 1) > epsilon) {
          this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
        }

        this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
      }
    },
    arc: function(x, y, r, a0, a1, ccw) {
      x = +x, y = +y, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0),
          dy = r * Math.sin(a0),
          x0 = x + dx,
          y0 = y + dy,
          cw = 1 ^ ccw,
          da = ccw ? a0 - a1 : a1 - a0;

      // Is the radius negative? Error.
      if (r < 0) throw new Error("negative radius: " + r);

      // Is this path empty? Move to (x0,y0).
      if (this._x1 === null) {
        this._ += "M" + x0 + "," + y0;
      }

      // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
      else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._ += "L" + x0 + "," + y0;
      }

      // Is this arc empty? We’re done.
      if (!r) return;

      // Does the angle go the wrong way? Flip the direction.
      if (da < 0) da = da % tau + tau;

      // Is this a complete circle? Draw two arcs to complete the circle.
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
      }

      // Is this arc non-empty? Draw an arc!
      else if (da > epsilon) {
        this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
    },
    rect: function(x, y, w, h) {
      this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
    },
    toString: function() {
      return this._;
    }
  };

  const MotionBar = (_a) => {
      var { custom, transition, arc } = _a, rest = __rest(_a, ["custom", "transition", "arc"]);
      const d = framerMotion.useMotionValue('');
      const prevPath = framerMotion.useMotionValue(custom.exit);
      const spring = framerMotion.useSpring(prevPath, Object.assign(Object.assign({}, DEFAULT_TRANSITION), { from: 0, to: 1 }));
      React.useEffect(() => {
          const from = custom.previousEnter
              ? custom.previousEnter.y
              : prevPath.get().y;
          const interpolator = d3Interpolate.interpolate(from, custom.enter.y);
          const unsub = spring.onChange((v) => d.set(arc(Object.assign(Object.assign({}, custom.enter), { y: interpolator(v) }))));
          prevPath.set(custom.enter);
          return unsub;
      });
      const _b = custom.enter, { d: enterD } = _b, enterRest = __rest(_b, ["d"]);
      const _c = custom.exit, exitRest = __rest(_c, ["d"]);
      return (React__default['default'].createElement(framerMotion.motion.path, Object.assign({}, rest, { initial: exitRest, exit: exitRest, animate: enterRest, transition: transition, d: transition.type !== false ? d : enterD })));
  };

  const RadialGuideBar = ({ active, path, fill = '#eee', opacity = 0.2 }) => (React__default['default'].createElement(framerMotion.motion.path, { d: path, fill: fill, pointerEvents: "none", initial: "hidden", animate: active ? 'visible' : 'hidden', variants: {
          hidden: { opacity: 0 },
          visible: { opacity }
      } }));

  class RadialBar extends React.Component {
      getFill(color) {
          const { id, gradient } = this.props;
          if (!gradient) {
              return color;
          }
          return `url(#${id}-gradient)`;
      }
      onMouseEnter(event) {
          const { onMouseEnter, data } = this.props;
          onMouseEnter({
              value: data,
              nativeEvent: event
          });
      }
      onMouseLeave(event) {
          const { onMouseLeave, data } = this.props;
          onMouseLeave({
              value: data,
              nativeEvent: event
          });
      }
      onMouseClick(event) {
          const { onClick, data } = this.props;
          onClick({
              value: data,
              nativeEvent: event
          });
      }
      getArc(data) {
          const { innerRadius, xScale, yScale, curved } = this.props;
          const outerRadius = yScale(data.y);
          if (curved) {
              const startAngle = xScale(data.x);
              const endAngle = startAngle + xScale.bandwidth();
              const arcFn = d3Shape.arc()
                  .innerRadius(innerRadius)
                  .outerRadius(outerRadius)
                  .startAngle(startAngle)
                  .endAngle(endAngle)
                  .padAngle(0.01)
                  .padRadius(innerRadius);
              return arcFn(data);
          }
          else {
              const startAngle = xScale(data.x) - Math.PI * 0.5;
              const endAngle = startAngle + xScale.bandwidth();
              const innerAngleDistance = endAngle - startAngle;
              const arcLength = innerRadius * innerAngleDistance;
              const outerAngleDistance = arcLength / outerRadius;
              const halfAngleDistanceDelta = (innerAngleDistance - outerAngleDistance) / 2;
              const pathFn = path();
              pathFn.arc(0, 0, innerRadius, startAngle, endAngle);
              pathFn.arc(0, 0, outerRadius, endAngle - halfAngleDistanceDelta, startAngle + halfAngleDistanceDelta, true);
              return pathFn.toString();
          }
      }
      getTransition() {
          const { animated, barCount, index } = this.props;
          if (animated) {
              return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: (index / barCount) * 0.5 });
          }
          else {
              return {
                  type: false,
                  delay: 0
              };
          }
      }
      renderBar(color) {
          const { className, data, yScale, active, guide } = this.props;
          const fill = this.getFill(color);
          const transition = this.getTransition();
          // Track previous props
          const previousEnter = this.previousEnter
              ? Object.assign({}, this.previousEnter) : undefined;
          this.previousEnter = Object.assign({}, data);
          const [yStart, yEnd] = yScale.domain();
          const exit = Object.assign(Object.assign({}, data), { y: yStart });
          const guidePath = this.getArc(Object.assign(Object.assign({}, data), { y: yEnd }));
          return (React__default['default'].createElement(React.Fragment, null,
              guide && (React__default['default'].createElement(rdk.CloneElement, { element: guide, active: active, path: guidePath })),
              React__default['default'].createElement(MotionBar, { arc: this.getArc.bind(this), custom: {
                      enter: data,
                      exit,
                      previousEnter
                  }, transition: transition, fill: fill, className: className, onMouseEnter: bind__default['default'](this.onMouseEnter, this), onMouseLeave: bind__default['default'](this.onMouseLeave, this), onClick: bind__default['default'](this.onMouseClick, this) })));
      }
      render() {
          const { data, index, color, gradient, id, active } = this.props;
          const fill = color(data, index);
          const currentColorShade = active ? chroma__default['default'](fill).brighten(0.5) : fill;
          return (React__default['default'].createElement(React.Fragment, null,
              this.renderBar(currentColorShade),
              gradient && (React__default['default'].createElement(Gradient, { id: `${id}-gradient`, color: currentColorShade }))));
      }
  }
  RadialBar.defaultProps = {
      gradient: true,
      curved: false,
      guide: React__default['default'].createElement(RadialGuideBar, null),
      onClick: () => undefined,
      onMouseEnter: () => undefined,
      onMouseLeave: () => undefined
  };

  class RadialBarSeries extends React.Component {
      constructor() {
          super(...arguments);
          this.state = {};
      }
      onValueEnter(event) {
          this.setState({
              activeValues: event.value
          });
      }
      onValueLeave() {
          this.setState({
              activeValues: undefined
          });
      }
      renderBar(point, index) {
          const { innerRadius, xScale, yScale, bar, id, data, animated, colorScheme } = this.props;
          const { activeValues } = this.state;
          const active = activeValues && data && isEqual__default['default'](activeValues.x, point.x);
          return (React__default['default'].createElement(React.Fragment, { key: index },
              React__default['default'].createElement(rdk.CloneElement, { element: bar, id: `radialbar-${id}-${index}`, index: index, data: point, xScale: xScale, active: active, yScale: yScale, innerRadius: innerRadius, color: (point) => getColor({ data, point, index: 0, colorScheme }), barCount: data.length, animated: animated })));
      }
      render() {
          const { data, id, innerRadius, outerRadius, xScale, yScale, height, width, tooltip, colorScheme } = this.props;
          return (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, xScale: xScale, yScale: yScale, data: data, height: height, width: width, isRadial: true, innerRadius: innerRadius, outerRadius: outerRadius, onValueEnter: this.onValueEnter.bind(this), onValueLeave: this.onValueLeave.bind(this), color: (point, index) => getColor({ data, point, index, colorScheme }) },
              React__default['default'].createElement("g", { clipPath: `url(#${id}-path)` }, data.map(this.renderBar.bind(this)))));
      }
  }
  RadialBarSeries.defaultProps = {
      colorScheme: schemes.cybertron[0],
      tooltip: React__default['default'].createElement(TooltipArea, { tooltip: React__default['default'].createElement(ChartTooltip, { followCursor: true }) }),
      bar: React__default['default'].createElement(RadialBar, null),
      animated: true
  };

  class RadialBarChart extends React.Component {
      constructor() {
          super(...arguments);
          this.getScales = memoize__default['default']((preData, innerRadius, outerRadius) => {
              const data = buildShallowChartData(preData);
              const xDomain = uniqueBy(data, (d) => d.x);
              const yDomain = getYDomain({ data, scaled: false });
              const xScale = d3Scale.scaleBand()
                  .range([0, 2 * Math.PI])
                  .domain(xDomain);
              const yScale = getRadialYScale(innerRadius, outerRadius, yDomain);
              return {
                  xScale,
                  yScale,
                  data
              };
          });
      }
      renderChart(containerProps) {
          const { chartWidth, chartHeight, id } = containerProps;
          const { innerRadius, series, axis } = this.props;
          const outerRadius = Math.min(chartWidth, chartHeight) / 2;
          const { yScale, xScale, data } = this.getScales(this.props.data, innerRadius, outerRadius);
          return (React__default['default'].createElement(React.Fragment, null,
              axis && (React__default['default'].createElement(rdk.CloneElement, { element: axis, xScale: xScale, height: chartHeight, width: chartWidth, innerRadius: innerRadius })),
              React__default['default'].createElement(rdk.CloneElement, { element: series, id: id, data: data, height: chartHeight, width: chartWidth, xScale: xScale, yScale: yScale, innerRadius: innerRadius, outerRadius: outerRadius })));
      }
      render() {
          const { id, width, height, margins, className } = this.props;
          return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: true, className: className }, (props) => this.renderChart(props)));
      }
  }
  RadialBarChart.defaultProps = {
      innerRadius: 0.1,
      margins: 75,
      axis: React__default['default'].createElement(RadialAxis, null),
      series: React__default['default'].createElement(RadialBarSeries, null)
  };

  const RadialGaugeArc = ({ data, startAngle, endAngle, innerRadius, outerRadius, cornerRadius = 0, padAngle = 0, padRadius = 0, color = '#353d44', animated = true, disabled = false, onClick = () => undefined, onMouseEnter = () => undefined, onMouseLeave = () => undefined, tooltip = React__default['default'].createElement(ChartTooltip, null) }) => {
      /**
       * This function will generate the arcs
       * https://github.com/d3/d3-shape#arcs
       */
      const arcGenerator = React.useMemo(() => {
          return d3Shape.arc()
              .innerRadius(innerRadius)
              .outerRadius(outerRadius)
              .cornerRadius(cornerRadius);
      }, [innerRadius, outerRadius, cornerRadius, padAngle, padRadius]);
      const arcData = {
          // @ts-ignore Data must be passed
          data: data || {},
          startAngle,
          endAngle,
          padAngle
      };
      return (React__default['default'].createElement(PieArc, { arc: arcGenerator, data: arcData, animated: animated, color: color, disabled: disabled, tooltip: tooltip, onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave }));
  };

  var css_248z$3 = ".RadialGaugeLabel-module_valueLabel__3I4QC {\n  font-size: 14px;\n  font-weight: 400;\n  fill: var(--color-on-background);\n  opacity: .6;\n}\n";
  var css$3 = {"valueLabel":"RadialGaugeLabel-module_valueLabel__3I4QC"};
  styleInject(css_248z$3);

  class RadialGaugeLabel extends React.PureComponent {
      render() {
          const { data, className, offset, onClick } = this.props;
          const label = formatValue(data.key);
          return (React__default['default'].createElement("text", { x: "0", y: offset, textAnchor: "middle", 
              // This is only valid when placed below the chart
              alignmentBaseline: 'text-after-edge', onClick: (nativeEvent) => onClick({ data, nativeEvent }), className: classNames__default['default'](className, css$3.valueLabel) }, label));
      }
  }
  RadialGaugeLabel.defaultProps = {
      onClick: () => undefined
  };

  var css_248z$2 = ".RadialGaugeValueLabel-module_valueLabel__vjqac {\n  font-size: 18px;\n  font-weight: 400;\n  fill: var(--color-on-background);\n}\n";
  var css$2 = {"valueLabel":"RadialGaugeValueLabel-module_valueLabel__vjqac"};
  styleInject(css_248z$2);

  class RadialGaugeValueLabel extends React.PureComponent {
      render() {
          const { data, className } = this.props;
          // TODO: Get seperator based on locale
          return (React__default['default'].createElement(CountUp__default['default'], { start: 0, end: data.data, delay: 0, duration: 1, separator: "," }, ({ countUpRef }) => (React__default['default'].createElement("text", { dy: "-0.5em", x: "0", y: "15", textAnchor: "middle", className: classNames__default['default'](className, css$2.valueLabel), ref: countUpRef }))));
      }
  }
  RadialGaugeValueLabel.defaultProps = {};

  const RadialGaugeSeries = (_a) => {
      var { data, scale, startAngle, endAngle, arcWidth = 10, outerArc = React__default['default'].createElement(RadialGaugeArc, { disabled: true }), innerArc = React__default['default'].createElement(RadialGaugeArc, { animated: true }), label = React__default['default'].createElement(RadialGaugeLabel, null), valueLabel = React__default['default'].createElement(RadialGaugeValueLabel, null), colorScheme = ['#00ECB1'], padding = 20, minGaugeWidth = 50 } = _a, props = __rest(_a, ["data", "scale", "startAngle", "endAngle", "arcWidth", "outerArc", "innerArc", "label", "valueLabel", "colorScheme", "padding", "minGaugeWidth"]);
      function getWidths() {
          let rows = 1;
          let columns = data.length;
          if (props.width / data.length < minGaugeWidth) {
              while (props.width / columns < minGaugeWidth) {
                  rows += 1;
                  columns = Math.ceil(data.length / rows);
              }
          }
          const xScale = d3Scale.scaleBand();
          xScale.domain(d3Array.range(columns));
          xScale.rangeRound([0, props.width], 0.1);
          const yScale = d3Scale.scaleBand();
          yScale.domain(d3Array.range(rows));
          yScale.rangeRound([0, props.height], 0.1);
          return {
              columns,
              xScale,
              yScale,
              width: xScale.bandwidth(),
              height: yScale.bandwidth()
          };
      }
      function renderGauge(point, index, columns, height, width, xScale, yScale) {
          const dataEndAngle = scale(point.data);
          const outerRadius = d3Array.min([width - padding * 2, height - padding * 2]) / 2;
          const innerRadius = outerRadius - arcWidth;
          const labelOffset = height / 2;
          const x = xScale(index % columns);
          const y = yScale(Math.floor(index / columns));
          const xOffset = x + (width - padding) / 2;
          const yOffset = y + height / 2;
          return (React__default['default'].createElement("g", { transform: `translate(${xOffset}, ${yOffset})`, key: point.key.toLocaleString() },
              outerArc &&
                  React.cloneElement(outerArc, {
                      outerRadius,
                      innerRadius,
                      startAngle,
                      endAngle
                  }),
              innerArc &&
                  React.cloneElement(innerArc, {
                      outerRadius,
                      innerRadius,
                      startAngle,
                      endAngle: dataEndAngle,
                      data: point,
                      color: getColor({
                          data,
                          colorScheme,
                          point,
                          index
                      })
                  }),
              valueLabel && React.cloneElement(valueLabel, { data: point }),
              label && React.cloneElement(label, { data: point, offset: labelOffset })));
      }
      const { columns, width, height, xScale, yScale } = getWidths();
      return (React__default['default'].createElement(React__default['default'].Fragment, null, data.map((d, i) => renderGauge(d, i, columns, height, width, xScale, yScale))));
  };

  var css_248z$1 = ".StackedRadialGaugeValueLabel-module_stackedValueLabel__1qplE {\n  font-size: 18px;\n  font-weight: 400;\n  fill: var(--color-on-background);\n}\n";
  var css$1 = {"stackedValueLabel":"StackedRadialGaugeValueLabel-module_stackedValueLabel__1qplE"};
  styleInject(css_248z$1);

  const StackedRadialGaugeLabel = ({ label, className, yOffset = 0 }) => (React__default['default'].createElement(React__default['default'].Fragment, null, label && (React__default['default'].createElement("text", { x: "0", y: yOffset, textAnchor: "middle", alignmentBaseline: "middle", className: classNames__default['default'](className, css$1.stackedValueLabel) }, label))));

  const StackedRadialGaugeSeries = ({ data, width, height, scale, startAngle, endAngle, outerArc = React__default['default'].createElement(RadialGaugeArc, { disabled: true }), innerArc = React__default['default'].createElement(RadialGaugeArc, { animated: true }), label = React__default['default'].createElement(StackedRadialGaugeLabel, null), colorScheme = ['#00ECB1'], fillFactor = 0.2, arcPadding = 0.15 }) => {
      const radius = Math.min(width, height) / 2;
      const innerRadius = radius * (1 - Math.min(fillFactor, 1));
      const rAxis = d3Scale.scaleBand();
      rAxis.domain(d3Array.range(data.length));
      rAxis.range([innerRadius, radius]);
      rAxis.paddingInner(arcPadding);
      function renderStackedGauges(point, index, rAxis) {
          const dataEndAngle = scale(point.data);
          const outerRadius = rAxis(index);
          const innerRadius = outerRadius - rAxis.bandwidth();
          return (React__default['default'].createElement("g", { key: point.key.toLocaleString() },
              outerArc &&
                  React.cloneElement(outerArc, {
                      outerRadius,
                      innerRadius,
                      startAngle,
                      endAngle
                  }),
              innerArc &&
                  React.cloneElement(innerArc, {
                      outerRadius,
                      innerRadius,
                      startAngle,
                      endAngle: dataEndAngle,
                      data: point,
                      color: getColor({
                          data,
                          colorScheme,
                          point,
                          index
                      })
                  })));
      }
      return (React__default['default'].createElement(React__default['default'].Fragment, null,
          React__default['default'].createElement("g", { transform: `translate(${width / 2}, ${height / 2})` },
              data.map((d, i) => renderStackedGauges(d, i, rAxis)),
              label)));
  };

  const RadialGauge = ({ id, width, height, margins, className, data, minValue = 0, maxValue = 100, startAngle = 0, endAngle = Math.PI * 2, series = React__default['default'].createElement(RadialGaugeSeries, null) }) => {
      const scale = d3Scale.scaleLinear()
          .domain([minValue, maxValue])
          .range([startAngle, endAngle]);
      return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, className: className }, (props) => React.cloneElement(series, {
          scale,
          data,
          startAngle,
          endAngle,
          width: props.width,
          height: props.height
      })));
  };

  var css_248z = ".HeatmapCell-module_cell__2iO3O {\n  transition: stroke 150ms ease-in-out;\n}\n";
  var css = {"cell":"HeatmapCell-module_cell__2iO3O"};
  styleInject(css_248z);

  // Set padding modifier for the tooltips
  const modifiers = {
      offset: {
          offset: '0, 3px'
      }
  };
  const HeatmapCell = (_a) => {
      var { rx = 2, ry = 2, cursor = 'auto', tooltip = React__default['default'].createElement(ChartTooltip, null), onClick = () => undefined, onMouseEnter = () => undefined, onMouseLeave = () => undefined, data, animated, cellIndex, cellCount, fill, x, y, style, className } = _a, rest = __rest(_a, ["rx", "ry", "cursor", "tooltip", "onClick", "onMouseEnter", "onMouseLeave", "data", "animated", "cellIndex", "cellCount", "fill", "x", "y", "style", "className"]);
      const [active, setActive] = React.useState(false);
      const rect = React.useRef(null);
      const onMouseEnterWrapper = (event) => {
          setActive(true);
          onMouseEnter({
              value: data,
              nativeEvent: event
          });
      };
      const onMouseLeaveWrapper = (event) => {
          setActive(false);
          onMouseLeave({
              value: data,
              nativeEvent: event
          });
      };
      const onMouseClick = (event) => {
          onClick({
              value: data,
              nativeEvent: event
          });
      };
      const tooltipData = React.useMemo(() => ({
          y: data.value,
          x: `${data.key} ∙ ${data.x}`,
          data
      }), [data]);
      const transition = React.useMemo(() => {
          if (animated) {
              return Object.assign(Object.assign({}, DEFAULT_TRANSITION), { delay: (cellIndex / cellCount) * 0.005 });
          }
          else {
              return {
                  type: false,
                  delay: 0
              };
          }
      }, [animated, cellIndex, cellCount]);
      const extras = constructFunctionProps({ style, className }, data);
      const isTransparent = fill === 'transparent';
      const stroke = active && !isTransparent ? chroma__default['default'](fill).brighten(1) : fill;
      return (React__default['default'].createElement(React.Fragment, null,
          React__default['default'].createElement("g", { ref: rect },
              React__default['default'].createElement(framerMotion.motion.rect, Object.assign({}, rest, { fill: fill, stroke: stroke, x: x, y: y, style: Object.assign(Object.assign({}, extras.style), { cursor }), className: classNames__default['default'](css.cell, extras.className), initial: {
                      opacity: 0
                  }, animate: {
                      opacity: 1
                  }, exit: {
                      opacity: 0
                  }, transition: transition, onMouseEnter: onMouseEnterWrapper, onMouseLeave: onMouseLeaveWrapper, onClick: onMouseClick }))),
          tooltip && !tooltip.props.disabled && !isTransparent && (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: active, modifiers: tooltip.props.modifiers || modifiers, reference: rect, value: tooltipData }))));
  };

  class HeatmapSeries extends React.Component {
      constructor() {
          super(...arguments);
          this.getValueScale = memoize__default['default']((data, colorScheme, emptyColor) => {
              const valueDomain = d3Array.extent(uniqueBy(data, (d) => d.data, (d) => d.value));
              return (point) => {
                  // For 0 values, lets show a placeholder fill
                  if (point === undefined || point === null) {
                      return emptyColor;
                  }
                  return getColor({
                      scale: d3Scale.scaleQuantile,
                      domain: valueDomain,
                      key: point,
                      colorScheme
                  });
              };
          });
      }
      renderCell({ row, cell, rowIndex, cellIndex, valueScale, width, height, cellCount }) {
          const { xScale, yScale, id, animated, cell: cellElement } = this.props;
          const x = xScale(row.key);
          const y = yScale(cell.x);
          const fill = valueScale(cell.value);
          return (React__default['default'].createElement(rdk.CloneElement, { key: `${id}-${rowIndex}-${cellIndex}`, element: cellElement, animated: animated, cellIndex: rowIndex + cellIndex, cellCount: cellCount, x: x, y: y, fill: fill, width: width, height: height, data: cell }));
      }
      render() {
          const { xScale, yScale, data, colorScheme, emptyColor } = this.props;
          const valueScale = this.getValueScale(data, colorScheme, emptyColor);
          const height = yScale.bandwidth();
          const width = xScale.bandwidth();
          const cellCount = d3Array.sum([...yScale.domain(), ...xScale.domain()]);
          return (React__default['default'].createElement(React.Fragment, null, data.map((row, rowIndex) => row.data.map((cell, cellIndex) => this.renderCell({
              height,
              width,
              valueScale,
              cellCount,
              row,
              cell,
              rowIndex,
              cellIndex
          })))));
      }
  }
  HeatmapSeries.defaultProps = {
      padding: 0.1,
      animated: true,
      emptyColor: 'rgba(200,200,200,0.08)',
      colorScheme: ['rgba(28, 107, 86, 0.5)', '#2da283'],
      cell: React__default['default'].createElement(HeatmapCell, null)
  };

  const Heatmap = ({ data = [], margins = 10, series = React__default['default'].createElement(HeatmapSeries, null), yAxis = (React__default['default'].createElement(LinearYAxis, { type: "category", axisLine: null, tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { line: null, label: React__default['default'].createElement(LinearYAxisTickLabel, { padding: 5 }) }) })), xAxis = (React__default['default'].createElement(LinearXAxis, { type: "category", axisLine: null, tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { line: null, label: React__default['default'].createElement(LinearXAxisTickLabel, { padding: 5 }) }) })), secondaryAxis, id, width, height, className }) => {
      const getScalesData = React.useCallback((chartHeight, chartWidth) => {
          const nestedData = buildNestedChartData(data);
          const xDomain = xAxis.props.domain || uniqueBy(nestedData, (d) => d.key);
          const xScale = d3Scale.scaleBand()
              .range([0, chartWidth])
              .domain(xDomain)
              .paddingInner(series.props.padding);
          const yDomain = yAxis.props.domain ||
              uniqueBy(nestedData, (d) => d.data, (d) => d.x);
          const yScale = d3Scale.scaleBand()
              .domain(yDomain)
              .range([chartHeight, 0])
              .paddingInner(series.props.padding);
          return {
              yScale,
              xScale,
              data: nestedData
          };
      }, [data, xAxis, yAxis, series]);
      const renderChart = (containerProps) => {
          const { chartWidth, chartHeight, updateAxes, id } = containerProps;
          const { xScale, yScale, data: scalesData } = getScalesData(chartHeight, chartWidth);
          return (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement(rdk.CloneElement, { element: xAxis, height: chartHeight, width: chartWidth, scale: xScale, onDimensionsChange: (event) => updateAxes('horizontal', event) }),
              React__default['default'].createElement(rdk.CloneElement, { element: yAxis, height: chartHeight, width: chartWidth, scale: yScale, onDimensionsChange: (event) => updateAxes('vertical', event) }),
              secondaryAxis &&
                  secondaryAxis.map((axis, i) => (React__default['default'].createElement(rdk.CloneElement, { key: i, element: axis, height: chartHeight, width: chartWidth, onDimensionsChange: (event) => updateAxes('horizontal', event) }))),
              React__default['default'].createElement(rdk.CloneElement, { element: series, id: `heat-series-${id}`, data: scalesData, xScale: xScale, yScale: yScale })));
      };
      return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: isAxisVisible(xAxis.props), yAxisVisible: isAxisVisible(yAxis.props), className: className }, renderChart));
  };

  const getFirstOfMonth = (date) => new Date(date.getFullYear(), date.getMonth(), 1);
  const addWeeksToDate = (date, weeks) => {
      const d = new Date(date.getTime());
      d.setDate(d.getDate() + weeks * 7);
      return d;
  };
  const getStartOfDay = (date) => {
      const d = new Date(date.getTime());
      d.setHours(0, 0, 0, 0);
      return d;
  };
  const getNewDayFromDay = (date, num) => {
      const d = new Date(date.getTime());
      d.setDate(d.getDate() + num);
      return d;
  };
  const weekDays = (() => {
      const base = new Date(Date.UTC(2017, 0, 2));
      return d3Array.range(7).map(() => {
          const name = base.toLocaleDateString('default', { weekday: 'short' });
          base.setDate(base.getDate() + 1);
          return name;
      });
  })();
  const buildDataScales = (rawData, view) => {
      var _a;
      // Get the most recent date to get the range from
      // From the end date, lets find the start year/month of that
      // From that start year/month, lets find the end year/month for our bounds
      const startDate = d3Array.min(rawData, (d) => d.key);
      const start = getFirstOfMonth(startDate);
      const endDomain = view === 'year' ? 53 : 5;
      const end = addWeeksToDate(start, endDomain);
      // Base on the view type, swap out some ranges
      const xDomainRange = view === 'year' ? 53 : 5;
      // Build our x/y domains for days of week + number of weeks in year
      const yDomain = d3Array.range(7).reverse();
      const xDomain = d3Array.range(xDomainRange);
      // Filter out dates that are not in the start/end ranges
      // and turn them into something our chart can read
      const dates = rawData
          .filter((d) => d.key.getTime() > start.getTime() ||
          d.key.getTime() < end.getTime())
          .map((d) => ({
          key: getStartOfDay(d.key),
          data: d.data
      }));
      // Find the first day of the duration and subtract the delta
      const firstDayOfStart = start.getDay();
      const curDate = getNewDayFromDay(start, -firstDayOfStart);
      const rows = [];
      // Build out the dataset for the n duration
      for (let week = 0; week < xDomainRange; week++) {
          const row = {
              key: week,
              data: []
          };
          for (let day = 0; day <= 6; day++) {
              const dayValue = dates.find((d) => d.key.getTime() === curDate.getTime());
              row.data.push({
                  key: day,
                  data: (_a = dayValue === null || dayValue === void 0 ? void 0 : dayValue.data) !== null && _a !== void 0 ? _a : undefined,
                  metadata: {
                      date: new Date(curDate.getTime()),
                      start: start,
                      end: end
                  }
              });
              curDate.setDate(curDate.getDate() + 1);
          }
          rows.push(row);
      }
      return {
          data: rows,
          yDomain,
          xDomain,
          start
      };
  };

  // Format the xAxis label for the start + n week
  const xAxisLabelFormat = (start) => (weeks) => addWeeksToDate(start, weeks).toLocaleString('default', { month: 'long' });
  const CalendarHeatmap = (_a) => {
      var { view = 'year', series = (React__default['default'].createElement(HeatmapSeries, { padding: 0.3, emptyColor: 'transparent', cell: React__default['default'].createElement(HeatmapCell, { tooltip: React__default['default'].createElement(ChartTooltip, { content: (d) => `${formatValue(d.data.metadata.date)} ∙ ${formatValue(d.data.value)}` }) }) })), data } = _a, rest = __rest(_a, ["view", "series", "data"]);
      const dataDomains = React.useMemo(() => buildDataScales(data, view), [data, view]);
      const { data: domainData, yDomain, xDomain, start } = dataDomains;
      // For month, only pass 1 tick value
      const xTickValues = view === 'year' ? undefined : [1];
      // Get the yAxis label formatting based on view type
      const yAxisLabelFormat = view === 'year' ? (d) => weekDays[d] : () => null;
      return (React__default['default'].createElement(Heatmap, Object.assign({}, rest, { data: domainData, yAxis: React__default['default'].createElement(LinearYAxis, { type: "category", axisLine: null, domain: yDomain, tickSeries: React__default['default'].createElement(LinearYAxisTickSeries, { tickSize: 20, line: null, label: React__default['default'].createElement(LinearYAxisTickLabel, { padding: 5, format: yAxisLabelFormat }) }) }), xAxis: React__default['default'].createElement(LinearXAxis, { type: "category", axisLine: null, domain: xDomain, tickSeries: React__default['default'].createElement(LinearXAxisTickSeries, { line: null, tickValues: xTickValues, label: React__default['default'].createElement(LinearXAxisTickLabel, { padding: 5, align: "end", format: xAxisLabelFormat(start) }) }) }) })));
  };

  const LinearGaugeBar = (props) => (React__default['default'].createElement(Bar, Object.assign({}, props, { tooltip: React__default['default'].createElement(ChartTooltip, { placement: "top", content: (data) => (React__default['default'].createElement(TooltipTemplate, { value: { y: data.value, x: data.y } })) }) })));

  const LinearGaugeOuterBar = (_a) => {
      var { height, width, fill } = _a, rest = __rest(_a, ["height", "width", "fill"]);
      return (React__default['default'].createElement("rect", Object.assign({}, rest, { fill: fill || '#484848', width: Math.max(width, 0), height: Math.max(height, 0) })));
  };

  const defaultProps = {
      outerBar: React__default['default'].createElement(LinearGaugeOuterBar, null),
      bar: React__default['default'].createElement(LinearGaugeBar, null)
  };
  const LinearGaugeSeries = (_a) => {
      var { height, width, bar, outerBar, isMultiSeries } = _a, rest = __rest(_a, ["height", "width", "bar", "outerBar", "isMultiSeries"]);
      return (React__default['default'].createElement(React.Fragment, null,
          !isMultiSeries && (React__default['default'].createElement(rdk.CloneElement, { element: outerBar || defaultProps.outerBar, height: height, width: width })),
          React__default['default'].createElement(BarSeries, Object.assign({}, rest, { layout: "horizontal", tooltip: null, bar: React__default['default'].createElement(rdk.CloneElement, { element: bar || defaultProps.bar }) }))));
  };

  class LinearGauge extends React.Component {
      getData(data) {
          if (Array.isArray(data)) {
              return buildBarStackData([
                  {
                      key: 'default',
                      data
                  }
              ], 'expand', 'horizontal');
          }
          else {
              return buildShallowChartData([data], 'horizontal');
          }
      }
      getScales(isMultiSeries, data, width, height, minValue, maxValue) {
          const domain = !isMultiSeries ? [minValue, maxValue] : undefined;
          const keyScale = getXScale({
              width,
              type: 'value',
              data,
              domain,
              isMultiSeries
          });
          const valueScale = getYScale({
              type: 'category',
              height,
              data,
              isMultiSeries
          });
          return {
              keyScale,
              valueScale
          };
      }
      renderChart({ chartHeight, chartWidth, id, chartSized }) {
          const { series, data, minValue, maxValue } = this.props;
          const isMultiSeries = Array.isArray(data);
          const type = isMultiSeries ? 'stackedNormalized' : 'standard';
          const transformedData = this.getData(data);
          const { keyScale, valueScale } = this.getScales(isMultiSeries, transformedData, chartWidth, chartHeight, minValue, maxValue);
          return (React__default['default'].createElement(React.Fragment, null, chartSized && (React__default['default'].createElement(rdk.CloneElement, { element: series, id: `linear-gauge-series-${id}`, data: transformedData, isCategorical: true, xScale: keyScale, yScale: valueScale, type: type, height: chartHeight, width: chartWidth, isMultiSeries: isMultiSeries }))));
      }
      render() {
          const { id, width, height, margins, className } = this.props;
          return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, className: className }, (props) => this.renderChart(props)));
      }
  }
  LinearGauge.defaultProps = {
      minValue: 0,
      maxValue: 100,
      series: React__default['default'].createElement(LinearGaugeSeries, null)
  };

  const useInterpolate = ({ data, animated }) => {
      const transition = animated
          ? Object.assign({}, DEFAULT_TRANSITION) : {
          delay: 0,
          type: false
      };
      const d = framerMotion.useMotionValue(data.path);
      const prevPath = framerMotion.useMotionValue(data.path);
      const spring = framerMotion.useSpring(prevPath, {
          from: 0,
          to: 1
      });
      React.useEffect(() => {
          const interpolator = d3Interpolate.interpolate(prevPath.get(), data.path);
          spring.onChange((v) => d.set(interpolator(v)));
          prevPath.set(data.path);
      });
      return { transition, d };
  };

  const VennArc = ({ data, fill, disabled, animated, stroke, mask, id, active = false, style, inactiveStyle = { opacity: 0.3 }, activeStyle = { opacity: 0.8 }, initialStyle = { opacity: 0.6 }, strokeWidth = 3, gradient = React__default['default'].createElement(Gradient, null), tooltip = React__default['default'].createElement(ChartTooltip, null), onClick = () => undefined, onMouseEnter = () => undefined, onMouseLeave = () => undefined }) => {
      var _a, _b;
      const [internalActive, setInternalActive] = React.useState(false);
      const arcRef = React.useRef(null);
      const { transition, d } = useInterpolate({ animated, data });
      const currentStyle = active
          ? activeStyle
          : active === null
              ? inactiveStyle
              : initialStyle;
      const arcFill = gradient && !mask
          ? `url(#gradient-${id})`
          : mask
              ? `url(#mask-pattern-${id})`
              : fill;
      return (React__default['default'].createElement("g", { title: data.data.key, onMouseEnter: (event) => {
              if (!disabled) {
                  setInternalActive(true);
                  onMouseEnter({
                      value: data.data,
                      nativeEvent: event
                  });
              }
          }, onMouseLeave: (event) => {
              if (!disabled) {
                  setInternalActive(false);
                  onMouseLeave({
                      value: data.data,
                      nativeEvent: event
                  });
              }
          }, onClick: (event) => {
              if (!disabled) {
                  onClick({
                      value: data.data,
                      nativeEvent: event
                  });
              }
          } },
          React__default['default'].createElement(framerMotion.motion.path, { ref: arcRef, fill: arcFill, id: `${id}-arc`, strokeWidth: strokeWidth, stroke: stroke, transition: transition, d: d, initial: initialStyle, animate: currentStyle, style: style }),
          mask && (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement(Mask, { id: `mask-${id}`, fill: `url(#gradient-${id})` }),
              React__default['default'].createElement(rdk.CloneElement, { element: mask, id: `mask-pattern-${id}`, fill: fill }))),
          gradient && (React__default['default'].createElement(rdk.CloneElement, { element: gradient, id: `gradient-${id}`, color: fill })),
          tooltip && !tooltip.props.disabled && (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: !!internalActive, reference: arcRef, value: { y: data.data.size, x: (_b = (_a = data.data) === null || _a === void 0 ? void 0 : _a.sets) === null || _b === void 0 ? void 0 : _b.join(' | ') } }))));
  };

  const VennLabel = ({ data, format, id, active, labelType = 'key', showAll = false, wrap = true, animated = true, fill = '#000', fontSize = 11, fontFamily = 'sans-serif' }) => {
      var _a, _b, _c, _d, _e;
      // If the text area is very large, then lets just skip showing the label
      if (!showAll && !((_a = data.arcs) === null || _a === void 0 ? void 0 : _a.filter((a) => a.large).length)) {
          return null;
      }
      const key = labelType === 'key' ? (_c = (_b = data.data) === null || _b === void 0 ? void 0 : _b.sets) === null || _c === void 0 ? void 0 : _c.join(' | ') : data.data.size;
      const transition = animated ? {} : { delay: 0, type: false };
      const text = wrap
          ? wrapText({
              key, x: data.text.x,
              fontFamily,
              fontSize,
              width: (_e = (_d = data === null || data === void 0 ? void 0 : data.circles) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.radius
          })
          : key;
      return (React__default['default'].createElement(framerMotion.motion.text, { id: `${id}-text`, style: { pointerEvents: 'none', fontFamily, fontSize }, fill: fill, initial: {
              attrX: data.text.x,
              attrY: data.text.y,
              opacity: 1
          }, animate: {
              attrX: data.text.x,
              attrY: data.text.y,
              opacity: active === null ? 0.3 : 1
          }, transition: transition, textAnchor: "middle" }, format ? format(data) : text));
  };

  const VennOuterLabel = ({ data, format, animated = true, fill = '#000', fontSize = 14, fontFamily = 'sans-serif' }) => {
      const transition = animated ? {} : { delay: 0, type: false };
      const text = data.set.data.key;
      const label = format ? format(data) : text;
      const isElement = React.isValidElement(label);
      const showIcon = isElement && data.set.icon;
      // TODO: framer-motion doesn't seem to like the translates on the g
      // initial={pos} animate={pos}
      const pos = {
          x: showIcon ? data.set.icon.x : data.set.text.x,
          y: showIcon ? data.set.icon.y : data.set.text.y
      };
      return (React__default['default'].createElement(React.Fragment, null, isElement ? (React__default['default'].createElement("g", { style: { transform: `translate(${pos.x}px, ${pos.y}px)` } }, label)) : (React__default['default'].createElement(framerMotion.motion.text, { fill: fill, style: { pointerEvents: 'none', fontFamily, fontSize }, textAnchor: data.set.align === 'middle' ? 'center' : data.set.align, alignmentBaseline: data.set.verticalAlign, initial: {
              attrX: pos.x,
              attrY: pos.y
          }, animate: {
              attrX: pos.x,
              attrY: pos.y
          }, transition: transition }, label))));
  };

  const getSafeKey = (d) => { var _a, _b; return (_b = (_a = d.data) === null || _a === void 0 ? void 0 : _a.key) === null || _b === void 0 ? void 0 : _b.replace(' ', ''); };
  const VennSeries = ({ data, id, selections, animated = true, disabled = false, colorScheme = 'cybertron', outerLabel = React__default['default'].createElement(VennOuterLabel, null), arc = React__default['default'].createElement(VennArc, null), label = React__default['default'].createElement(VennLabel, null) }) => {
      const transition = animated ? {} : { type: false, delay: 0 };
      const [actives, setActives] = React.useState([]);
      const [hovered, setHovered] = React.useState(null);
      const onActivate = React.useCallback((point) => {
          setHovered(point);
          setActives(data
              .filter((d) => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.key.indexOf(point)) > -1; })
              .map((d) => { var _a; return (_a = d.data) === null || _a === void 0 ? void 0 : _a.key; }));
      }, [data]);
      const renderArc = React.useCallback((d, index) => {
          var _a;
          // Get the colors of the fill
          const fill = getColor({
              data,
              colorScheme,
              point: d.data,
              index
          });
          const arcFill = arc.props.fill || fill;
          const key = (_a = d === null || d === void 0 ? void 0 : d.data) === null || _a === void 0 ? void 0 : _a.key;
          const safeKey = getSafeKey(d);
          const isSelected = selections === null || selections === void 0 ? void 0 : selections.includes(key);
          // Get the state of the arc
          const isHovered = hovered === key || isSelected;
          const isActive = isSelected ||
              actives.includes(key) ||
              (actives.length > 0 ? null : false);
          // Get the colors for the stroke
          const stroke = typeof arc.props.stroke === 'function'
              ? arc.props.stroke(data, index, isActive, isHovered)
              : arc.props.stroke;
          const arcStroke = stroke ||
              chroma__default['default'](arcFill)
                  .darken(isActive ? 0.8 : 0.5)
                  .hex();
          return (React__default['default'].createElement(React.Fragment, { key: safeKey },
              React__default['default'].createElement(rdk.CloneElement, { element: arc, id: `${id}-${safeKey}`, data: d, fill: arcFill, stroke: arcStroke, disabled: disabled, animated: animated, active: isActive, onMouseEnter: () => onActivate(key), onMouseLeave: () => {
                      setActives([]);
                      setHovered(null);
                  } }),
              React__default['default'].createElement(rdk.CloneElement, { element: label, data: d, id: `${id}-${safeKey}`, active: isActive, animated: animated }),
              d.set && outerLabel && (React__default['default'].createElement(rdk.CloneElement, { element: outerLabel, data: d, animated: animated }))));
      }, [
          colorScheme,
          data,
          arc,
          animated,
          label,
          outerLabel,
          hovered,
          selections,
          actives,
          onActivate
      ]);
      const topArcs = React.useMemo(() => {
          const result = [];
          if (actives.length > 0) {
              result.push(...actives.filter((s) => s !== hovered));
          }
          if (selections === null || selections === void 0 ? void 0 : selections.length) {
              result.push(...selections.filter((s) => !actives.includes(s) && s !== hovered));
          }
          if (hovered) {
              result.push(hovered);
          }
          return result;
      }, [hovered, actives, selections]);
      return (React__default['default'].createElement(framerMotion.motion.g, { initial: { opacity: 0, scale: 0 }, animate: { opacity: 1, scale: 1 }, transition: transition },
          data.map(renderArc),
          topArcs.length > 0 &&
              topArcs.map((a) => (React__default['default'].createElement("use", { key: a, xlinkHref: `#${id}-${a}-arc`, style: { pointerEvents: 'none' } }))),
          data.map((d, index) => (React__default['default'].createElement("use", { key: index, xlinkHref: `#${id}-${getSafeKey(d)}-text`, style: { pointerEvents: 'none' } })))));
  };

  var sets$5 = [
  ];
  var intersections$5 = [
  ];
  var bb$5 = {
  	x: 0,
  	y: 0,
  	width: 10,
  	height: 10
  };
  var venn0 = {
  	sets: sets$5,
  	intersections: intersections$5,
  	bb: bb$5
  };

  var sets$4 = [
  	{
  		cx: 0,
  		cy: 0,
  		r: 5,
  		text: {
  			x: 3.5,
  			y: -4
  		},
  		align: "start",
  		verticalAlign: "bottom"
  	}
  ];
  var intersections$4 = [
  	{
  		sets: [
  			0
  		],
  		x1: 0,
  		y1: 5,
  		arcs: [
  			{
  				mode: "i",
  				ref: 0,
  				x2: 0,
  				y2: -5,
  				sweep: false,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 0,
  				x2: 0,
  				y2: 5,
  				sweep: false,
  				large: false
  			}
  		],
  		text: {
  			x: 0,
  			y: 0
  		}
  	}
  ];
  var bb$4 = {
  	x: -5,
  	y: -5,
  	width: 10,
  	height: 10
  };
  var venn1 = {
  	sets: sets$4,
  	intersections: intersections$4,
  	bb: bb$4
  };

  var sets$3 = [
  	{
  		cx: -4,
  		cy: 0,
  		r: 5,
  		text: {
  			x: -7.5,
  			y: 4
  		},
  		align: "end",
  		verticalAlign: "top"
  	},
  	{
  		cx: 4,
  		cy: 0,
  		r: 5,
  		text: {
  			x: 7.5,
  			y: -4
  		},
  		align: "start",
  		verticalAlign: "bottom"
  	}
  ];
  var intersections$3 = [
  	{
  		sets: [
  			0
  		],
  		x1: 0,
  		y1: -3,
  		arcs: [
  			{
  				mode: "i",
  				ref: 0,
  				x2: 0,
  				y2: 3,
  				sweep: false,
  				large: true
  			},
  			{
  				mode: "o",
  				ref: 1,
  				x2: 0,
  				y2: -3,
  				sweep: true,
  				large: false
  			}
  		],
  		text: {
  			x: -4,
  			y: 0
  		}
  	},
  	{
  		sets: [
  			1
  		],
  		x1: 0,
  		y1: 3,
  		arcs: [
  			{
  				mode: "i",
  				ref: 1,
  				x2: 0,
  				y2: -3,
  				sweep: false,
  				large: true
  			},
  			{
  				mode: "o",
  				ref: 0,
  				x2: 0,
  				y2: 3,
  				sweep: true,
  				large: false
  			}
  		],
  		text: {
  			x: 4,
  			y: 0
  		}
  	},
  	{
  		sets: [
  			0,
  			1
  		],
  		x1: 0,
  		y1: 3,
  		arcs: [
  			{
  				mode: "i",
  				ref: 0,
  				x2: 0,
  				y2: -3,
  				sweep: false,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 1,
  				x2: 0,
  				y2: 3,
  				sweep: false,
  				large: false
  			}
  		],
  		text: {
  			x: 0,
  			y: 0
  		}
  	}
  ];
  var bb$3 = {
  	x: -9,
  	y: -5,
  	width: 18,
  	height: 10
  };
  var venn2 = {
  	sets: sets$3,
  	intersections: intersections$3,
  	bb: bb$3
  };

  var sets$2 = [
  	{
  		cx: -3.464,
  		cy: -2,
  		r: 5,
  		text: {
  			x: -7,
  			y: -6
  		},
  		align: "end"
  	},
  	{
  		cx: 3.464,
  		cy: -2,
  		r: 5,
  		text: {
  			x: 7,
  			y: -6
  		},
  		align: "start"
  	},
  	{
  		cx: 0,
  		cy: 4,
  		r: 5,
  		text: {
  			x: 4,
  			y: 7.5
  		},
  		align: "start",
  		verticalAlign: "top"
  	}
  ];
  var intersections$2 = [
  	{
  		sets: [
  			0
  		],
  		x1: -4.855,
  		y1: 2.803,
  		arcs: [
  			{
  				mode: "o",
  				ref: 2,
  				x2: -1.39,
  				y2: -0.803,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "o",
  				ref: 1,
  				x2: 0,
  				y2: -5.606,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 0,
  				x2: -4.855,
  				y2: 2.803,
  				sweep: false,
  				large: true
  			}
  		],
  		text: {
  			x: -4.216,
  			y: -2.434
  		}
  	},
  	{
  		sets: [
  			1
  		],
  		x1: 0,
  		y1: -5.606,
  		arcs: [
  			{
  				mode: "o",
  				ref: 0,
  				x2: 1.39,
  				y2: -0.803,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "o",
  				ref: 2,
  				x2: 4.855,
  				y2: 2.803,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 1,
  				x2: 0,
  				y2: -5.606,
  				sweep: false,
  				large: true
  			}
  		],
  		text: {
  			x: 4.216,
  			y: -2.434
  		}
  	},
  	{
  		sets: [
  			2
  		],
  		x1: -4.855,
  		y1: 2.803,
  		arcs: [
  			{
  				mode: "o",
  				ref: 0,
  				x2: 0,
  				y2: 1.606,
  				sweep: false,
  				large: false
  			},
  			{
  				mode: "o",
  				ref: 1,
  				x2: 4.855,
  				y2: 2.803,
  				sweep: false,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 2,
  				x2: -4.855,
  				y2: 2.803,
  				sweep: true,
  				large: true
  			}
  		],
  		text: {
  			x: 0,
  			y: 4.869
  		}
  	},
  	{
  		sets: [
  			0,
  			1
  		],
  		x1: 0,
  		y1: -5.606,
  		arcs: [
  			{
  				mode: "i",
  				ref: 1,
  				x2: -1.39,
  				y2: -0.803,
  				sweep: false,
  				large: false
  			},
  			{
  				mode: "o",
  				ref: 2,
  				x2: 1.39,
  				y2: -0.803,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 0,
  				x2: 0,
  				y2: -5.606,
  				sweep: false,
  				large: false
  			}
  		],
  		text: {
  			x: 0,
  			y: -2.404
  		}
  	},
  	{
  		sets: [
  			0,
  			2
  		],
  		x1: -4.855,
  		y1: 2.803,
  		arcs: [
  			{
  				mode: "i",
  				ref: 2,
  				x2: -1.39,
  				y2: -0.803,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "o",
  				ref: 1,
  				x2: 0,
  				y2: 1.606,
  				sweep: false,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 0,
  				x2: -4.855,
  				y2: 2.803,
  				sweep: true,
  				large: false
  			}
  		],
  		text: {
  			x: -2.082,
  			y: 1.202
  		}
  	},
  	{
  		sets: [
  			1,
  			2
  		],
  		x1: 4.855,
  		y1: 2.803,
  		arcs: [
  			{
  				mode: "i",
  				ref: 2,
  				x2: 1.39,
  				y2: -0.803,
  				sweep: false,
  				large: false
  			},
  			{
  				mode: "o",
  				ref: 0,
  				x2: 0,
  				y2: 1.606,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 1,
  				x2: 4.855,
  				y2: 2.803,
  				sweep: false,
  				large: false
  			}
  		],
  		text: {
  			x: 2.082,
  			y: 1.202
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			2
  		],
  		x1: 1.39,
  		y1: -0.803,
  		arcs: [
  			{
  				mode: "i",
  				ref: 0,
  				x2: 0,
  				y2: 1.606,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 1,
  				x2: -1.39,
  				y2: -0.803,
  				sweep: true,
  				large: false
  			},
  			{
  				mode: "i",
  				ref: 2,
  				x2: 1.39,
  				y2: -0.803,
  				sweep: true,
  				large: false
  			}
  		],
  		text: {
  			x: 0,
  			y: 0
  		}
  	}
  ];
  var bb$2 = {
  	x: -8.464,
  	y: -7,
  	width: 16.928,
  	height: 16
  };
  var venn3 = {
  	sets: sets$2,
  	intersections: intersections$2,
  	bb: bb$2
  };

  var sets$1 = [
  	{
  		cx: 0.439,
  		cy: -1.061,
  		rx: 2.5,
  		ry: 5,
  		rotation: 45,
  		text: {
  			x: 4.5,
  			y: -4.5
  		},
  		align: "start",
  		verticalAlign: "bottom"
  	},
  	{
  		cx: 2.561,
  		cy: 1.061,
  		rx: 2.5,
  		ry: 5,
  		rotation: 45,
  		text: {
  			x: 4,
  			y: 3.75
  		},
  		align: "start",
  		verticalAlign: "top"
  	},
  	{
  		cx: -2.561,
  		cy: 1.061,
  		rx: 2.5,
  		ry: 5,
  		rotation: -45,
  		text: {
  			x: -4,
  			y: 3.7
  		},
  		align: "end",
  		verticalAlign: "top"
  	},
  	{
  		cx: -0.439,
  		cy: -1.061,
  		rx: 2.5,
  		ry: 5,
  		rotation: -45,
  		text: {
  			x: -4.5,
  			y: -4.5
  		},
  		align: "end",
  		verticalAlign: "bottom"
  	}
  ];
  var intersections$1 = [
  	{
  		sets: [
  			0
  		],
  		x1: 0,
  		y1: -3.94,
  		arcs: [
  			{
  				ref: 0,
  				mode: "i",
  				x2: 4.328,
  				y2: -2.828,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 2.179,
  				y2: -1.858,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 0,
  				y2: -3.94,
  				large: false
  			}
  		],
  		text: {
  			x: 2.914,
  			y: -3.536
  		}
  	},
  	{
  		sets: [
  			1
  		],
  		x1: 4.328,
  		y1: -2.828,
  		arcs: [
  			{
  				ref: 1,
  				mode: "i",
  				x2: 0,
  				y2: 5.006,
  				sweep: true,
  				large: true
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: 1.328,
  				y2: 2.828
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 3.108,
  				y2: -0.328
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 4.328,
  				y2: -2.828
  			}
  		],
  		text: {
  			x: 5.036,
  			y: -1.414
  		}
  	},
  	{
  		sets: [
  			2
  		],
  		x1: 0,
  		y1: 5.006,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: -4.328,
  				y2: -2.828,
  				sweep: true,
  				large: true
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -3.108,
  				y2: -0.328
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -1.328,
  				y2: 2.828
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 0,
  				y2: 5.006
  			}
  		],
  		text: {
  			x: -5.036,
  			y: -1.414
  		}
  	},
  	{
  		sets: [
  			3
  		],
  		x1: -4.328,
  		y1: -2.828,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: 0,
  				y2: -3.94,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -2.179,
  				y2: -1.858,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -4.328,
  				y2: -2.828,
  				large: false
  			}
  		],
  		text: {
  			x: -2.914,
  			y: -3.536
  		}
  	},
  	{
  		sets: [
  			0,
  			1
  		],
  		x1: 4.328,
  		y1: -2.828,
  		arcs: [
  			{
  				ref: 1,
  				mode: "i",
  				x2: 3.108,
  				y2: -0.328,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 2.179,
  				y2: -1.858,
  				sweep: false,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: 4.328,
  				y2: -2.828,
  				sweep: true,
  				large: false
  			}
  		],
  		text: {
  			x: 3.205,
  			y: -1.672
  		}
  	},
  	{
  		sets: [
  			0,
  			2
  		],
  		x1: -1.328,
  		y1: 2.828,
  		arcs: [
  			{
  				ref: 0,
  				mode: "i",
  				x2: -3.108,
  				y2: -0.328,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -0.969,
  				y2: 1.755,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: -1.328,
  				y2: 2.828,
  				large: false
  			}
  		],
  		text: {
  			x: -2.212,
  			y: 1.591
  		}
  	},
  	{
  		sets: [
  			0,
  			3
  		],
  		x1: 0,
  		y1: -3.94,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: 2.179,
  				y2: -1.858,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 0,
  				y2: 0.188,
  				sweep: false,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -2.179,
  				y2: -1.858,
  				sweep: false,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: 0,
  				y2: -3.94,
  				sweep: true
  			}
  		],
  		text: {
  			x: 0,
  			y: -1.87
  		}
  	},
  	{
  		sets: [
  			1,
  			2
  		],
  		x1: 1.328,
  		y1: 2.828,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: 0,
  				y2: 5.006,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: -1.328,
  				y2: 2.828,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 0,
  				y2: 2.346,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 1.328,
  				y2: 2.828
  			}
  		],
  		text: {
  			x: 0,
  			y: 3.393
  		}
  	},
  	{
  		sets: [
  			1,
  			3
  		],
  		x1: 3.108,
  		y1: -0.328,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: 1.328,
  				y2: 2.828,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: 0.969,
  				y2: 1.755,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: 3.108,
  				y2: -0.328,
  				large: false
  			}
  		],
  		text: {
  			x: 2.212,
  			y: 1.591
  		}
  	},
  	{
  		sets: [
  			2,
  			3
  		],
  		x1: -3.108,
  		y1: -0.328,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: -4.328,
  				y2: -2.828,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "i",
  				x2: -2.179,
  				y2: -1.858,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -3.108,
  				y2: -0.328,
  				large: false
  			}
  		],
  		text: {
  			x: -3.205,
  			y: -1.672
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			2
  		],
  		x1: 0,
  		y1: 2.346,
  		arcs: [
  			{
  				ref: 0,
  				mode: "i",
  				x2: -1.328,
  				y2: 2.828,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: -0.969,
  				y2: 1.755,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 0,
  				y2: 2.346,
  				large: false
  			}
  		],
  		text: {
  			x: -0.766,
  			y: 2.31
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			3
  		],
  		x1: 2.179,
  		y1: -1.858,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: 3.108,
  				y2: -0.328,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: 0.969,
  				y2: 1.755,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: 0,
  				y2: 0.188,
  				sweep: false,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: 2.179,
  				y2: -1.858,
  				sweep: true
  			}
  		],
  		text: {
  			x: 1.558,
  			y: -0.056
  		}
  	},
  	{
  		sets: [
  			0,
  			2,
  			3
  		],
  		x1: -0.969,
  		y1: 1.755,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: -3.108,
  				y2: -0.328,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: -2.179,
  				y2: -1.858,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "i",
  				x2: 0,
  				y2: 0.188,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: -0.969,
  				y2: 1.755
  			}
  		],
  		text: {
  			x: -1.558,
  			y: -0.056
  		}
  	},
  	{
  		sets: [
  			1,
  			2,
  			3
  		],
  		x1: 1.328,
  		y1: 2.828,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: 0,
  				y2: 2.346,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 0.969,
  				y2: 1.755,
  				sweep: false,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "i",
  				x2: 1.328,
  				y2: 2.828,
  				sweep: true,
  				large: false
  			}
  		],
  		text: {
  			x: 0.766,
  			y: 2.31
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			2,
  			3
  		],
  		x1: 0,
  		y1: 0.188,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: 0.969,
  				y2: 1.755,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: 0,
  				y2: 2.346,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "i",
  				x2: -0.969,
  				y2: 1.755,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: 0,
  				y2: 0.188,
  				sweep: true
  			}
  		],
  		text: {
  			x: 0,
  			y: 1.43
  		}
  	}
  ];
  var bb$1 = {
  	x: -6.5,
  	y: -5,
  	width: 13,
  	height: 10
  };
  var venn4 = {
  	sets: sets$1,
  	intersections: intersections$1,
  	bb: bb$1
  };

  var sets = [
  	{
  		cx: 0.5,
  		cy: -1,
  		rx: 2.5,
  		ry: 5,
  		rotation: 0,
  		text: {
  			x: 2.25,
  			y: -5
  		},
  		icon: {
  			x: 0,
  			y: -6.3
  		},
  		align: "start",
  		verticalAlign: "bottom"
  	},
  	{
  		cx: 1.106,
  		cy: 0.167,
  		rx: 2.5,
  		ry: 5,
  		rotation: 72,
  		text: {
  			x: 4.5,
  			y: 1.5
  		},
  		icon: {
  			x: 6.2,
  			y: -1.9
  		},
  		align: "start",
  		verticalAlign: "top"
  	},
  	{
  		cx: 0.183,
  		cy: 1.103,
  		rx: 2.5,
  		ry: 5,
  		rotation: 144,
  		icon: {
  			x: 3.2,
  			y: 6
  		},
  		text: {
  			x: 4,
  			y: 4
  		},
  		align: "start",
  		verticalAlign: "bottom"
  	},
  	{
  		cx: -0.992,
  		cy: 0.515,
  		rx: 2.5,
  		ry: 5,
  		rotation: 216,
  		icon: {
  			x: -4.4,
  			y: 5.2
  		},
  		text: {
  			x: -4.7,
  			y: 2
  		},
  		align: "end",
  		verticalAlign: "bottom"
  	},
  	{
  		cx: -0.797,
  		cy: -0.785,
  		rx: 2.5,
  		ry: 5,
  		rotation: 288,
  		icon: {
  			x: -6,
  			y: -2
  		},
  		text: {
  			x: -4,
  			y: -3.6
  		},
  		align: "end",
  		verticalAlign: "bottom"
  	}
  ];
  var intersections = [
  	{
  		sets: [
  			0
  		],
  		x1: -1.653,
  		y1: -3.541,
  		arcs: [
  			{
  				ref: 0,
  				mode: "i",
  				x2: 2.857,
  				y2: -2.666,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 2.5,
  				y2: -2.648,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -0.495,
  				y2: -3.303,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: -1.653,
  				y2: -3.541
  			}
  		],
  		text: {
  			x: 0.5,
  			y: -5
  		}
  	},
  	{
  		sets: [
  			1
  		],
  		x1: 2.857,
  		y1: -2.666,
  		arcs: [
  			{
  				ref: 1,
  				mode: "i",
  				x2: 3.419,
  				y2: 1.893,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: 3.291,
  				y2: 1.559,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: 2.988,
  				y2: -1.492,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 2.857,
  				y2: -2.666
  			}
  		],
  		text: {
  			x: 4.91,
  			y: -1.07
  		}
  	},
  	{
  		sets: [
  			2
  		],
  		x1: 3.419,
  		y1: 1.893,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: -0.744,
  				y2: 3.837,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -0.466,
  				y2: 3.612,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 2.342,
  				y2: 2.381,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 3.419,
  				y2: 1.893
  			}
  		],
  		text: {
  			x: 2.534,
  			y: 4.339
  		}
  	},
  	{
  		sets: [
  			3
  		],
  		x1: -0.744,
  		y1: 3.837,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: -3.879,
  				y2: 0.478,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: -3.579,
  				y2: 0.673,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: -1.54,
  				y2: 2.963,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -0.744,
  				y2: 3.837
  			}
  		],
  		text: {
  			x: -3.343,
  			y: 3.751
  		}
  	},
  	{
  		sets: [
  			4
  		],
  		x1: -3.879,
  		y1: 0.478,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: -1.653,
  				y2: -3.541,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -1.746,
  				y2: -3.196,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -3.294,
  				y2: -0.549,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -3.879,
  				y2: 0.478
  			}
  		],
  		text: {
  			x: -4.601,
  			y: -2.021
  		}
  	},
  	{
  		sets: [
  			0,
  			1
  		],
  		x1: 2.5,
  		y1: -2.648,
  		arcs: [
  			{
  				ref: 1,
  				mode: "i",
  				x2: 2.857,
  				y2: -2.666,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: 2.988,
  				y2: -1.492,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: 2.572,
  				y2: -1.839,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 2.5,
  				y2: -2.648
  			}
  		],
  		text: {
  			x: 2.741,
  			y: -2.152
  		}
  	},
  	{
  		sets: [
  			0,
  			2
  		],
  		x1: 2.342,
  		y1: 2.381,
  		arcs: [
  			{
  				ref: 0,
  				mode: "i",
  				x2: -0.466,
  				y2: 3.612,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 0.257,
  				y2: 2.922,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 2.342,
  				y2: 2.381,
  				large: false
  			}
  		],
  		text: {
  			x: 0.5,
  			y: 3.5
  		}
  	},
  	{
  		sets: [
  			0,
  			3
  		],
  		x1: -0.495,
  		y1: -3.303,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: 2.5,
  				y2: -2.648,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 1.51,
  				y2: -2.515,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: -0.495,
  				y2: -3.303,
  				large: false
  			}
  		],
  		text: {
  			x: 1.653,
  			y: -3.125
  		}
  	},
  	{
  		sets: [
  			0,
  			4
  		],
  		x1: -1.653,
  		y1: -3.541,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: -0.495,
  				y2: -3.303,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -0.954,
  				y2: -3.015,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -1.746,
  				y2: -3.196,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: -1.653,
  				y2: -3.541
  			}
  		],
  		text: {
  			x: -1.199,
  			y: -3.272
  		}
  	},
  	{
  		sets: [
  			1,
  			2
  		],
  		x1: 3.291,
  		y1: 1.559,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: 3.419,
  				y2: 1.893,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: 2.342,
  				y2: 2.381,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 2.544,
  				y2: 1.878,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: 3.291,
  				y2: 1.559
  			}
  		],
  		text: {
  			x: 2.894,
  			y: 1.942
  		}
  	},
  	{
  		sets: [
  			1,
  			3
  		],
  		x1: -1.54,
  		y1: 2.963,
  		arcs: [
  			{
  				ref: 1,
  				mode: "i",
  				x2: -3.579,
  				y2: 0.673,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: -2.7,
  				y2: 1.147,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -1.54,
  				y2: 2.963,
  				large: false
  			}
  		],
  		text: {
  			x: -3.174,
  			y: 1.557
  		}
  	},
  	{
  		sets: [
  			1,
  			4
  		],
  		x1: 2.988,
  		y1: -1.492,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: 3.291,
  				y2: 1.559,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: 2.858,
  				y2: 0.659,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 2.988,
  				y2: -1.492,
  				large: false
  			}
  		],
  		text: {
  			x: 3.483,
  			y: 0.606
  		}
  	},
  	{
  		sets: [
  			2,
  			3
  		],
  		x1: -0.466,
  		y1: 3.612,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: -0.744,
  				y2: 3.837,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "i",
  				x2: -1.54,
  				y2: 2.963,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: -1,
  				y2: 3,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -0.466,
  				y2: 3.612
  			}
  		],
  		text: {
  			x: -0.953,
  			y: 3.352
  		}
  	},
  	{
  		sets: [
  			2,
  			4
  		],
  		x1: -3.294,
  		y1: -0.549,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: -1.746,
  				y2: -3.196,
  				sweep: true
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -1.925,
  				y2: -2.213
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -3.294,
  				y2: -0.549
  			}
  		],
  		text: {
  			x: -2.462,
  			y: -2.538
  		}
  	},
  	{
  		sets: [
  			3,
  			4
  		],
  		x1: -3.579,
  		y1: 0.673,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: -3.879,
  				y2: 0.478,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "i",
  				x2: -3.294,
  				y2: -0.549,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -3.162,
  				y2: -0.024,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: -3.579,
  				y2: 0.673
  			}
  		],
  		text: {
  			x: -3.483,
  			y: 0.13
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			2
  		],
  		x1: 2.544,
  		y1: 1.878,
  		arcs: [
  			{
  				ref: 0,
  				mode: "i",
  				x2: 2.342,
  				y2: 2.381,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: 0.257,
  				y2: 2.922,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 0.983,
  				y2: 2.049,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: 2.544,
  				y2: 1.878
  			}
  		],
  		text: {
  			x: 1.457,
  			y: 2.331
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			3
  		],
  		x1: 1.51,
  		y1: -2.515,
  		arcs: [
  			{
  				ref: 1,
  				mode: "i",
  				x2: 2.5,
  				y2: -2.648,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "i",
  				x2: 2.572,
  				y2: -1.839,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: 1.51,
  				y2: -2.515,
  				large: false
  			}
  		],
  		text: {
  			x: 2.194,
  			y: -2.334
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			4
  		],
  		x1: 2.572,
  		y1: -1.839,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: 2.988,
  				y2: -1.492,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: 2.858,
  				y2: 0.659,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: 2.253,
  				y2: -0.302,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 2.572,
  				y2: -1.839
  			}
  		],
  		text: {
  			x: 2.667,
  			y: -0.665
  		}
  	},
  	{
  		sets: [
  			0,
  			2,
  			3
  		],
  		x1: 0.257,
  		y1: 2.922,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: -0.466,
  				y2: 3.612,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: -1,
  				y2: 3,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 0.257,
  				y2: 2.922,
  				large: false
  			}
  		],
  		text: {
  			x: -0.403,
  			y: 3.178
  		}
  	},
  	{
  		sets: [
  			0,
  			2,
  			4
  		],
  		x1: -1.746,
  		y1: -3.196,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: -0.954,
  				y2: -3.015,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: -1.925,
  				y2: -2.213,
  				sweep: false,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: -1.746,
  				y2: -3.196,
  				sweep: true,
  				large: false
  			}
  		],
  		text: {
  			x: -1.542,
  			y: -2.808
  		}
  	},
  	{
  		sets: [
  			0,
  			3,
  			4
  		],
  		x1: -0.495,
  		y1: -3.303,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: 1.51,
  				y2: -2.515,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: 0.409,
  				y2: -2.236,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -0.954,
  				y2: -3.015,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "i",
  				x2: -0.495,
  				y2: -3.303
  			}
  		],
  		text: {
  			x: 0.192,
  			y: -2.742
  		}
  	},
  	{
  		sets: [
  			1,
  			2,
  			3
  		],
  		x1: -1.54,
  		y1: 2.963,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: -2.7,
  				y2: 1.147,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: -1.645,
  				y2: 1.568,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -1,
  				y2: 3,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: -1.54,
  				y2: 2.963
  			}
  		],
  		text: {
  			x: -1.767,
  			y: 2.106
  		}
  	},
  	{
  		sets: [
  			1,
  			2,
  			4
  		],
  		x1: 2.858,
  		y1: 0.659,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: 3.291,
  				y2: 1.559,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "i",
  				x2: 2.544,
  				y2: 1.878,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: 2.858,
  				y2: 0.659,
  				large: false
  			}
  		],
  		text: {
  			x: 2.898,
  			y: 1.365
  		}
  	},
  	{
  		sets: [
  			1,
  			3,
  			4
  		],
  		x1: -2.7,
  		y1: 1.147,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: -3.579,
  				y2: 0.673,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: -3.162,
  				y2: -0.024,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: -2.7,
  				y2: 1.147,
  				large: false
  			}
  		],
  		text: {
  			x: -3.147,
  			y: 0.599
  		}
  	},
  	{
  		sets: [
  			2,
  			3,
  			4
  		],
  		x1: -3.294,
  		y1: -0.549,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: -1.925,
  				y2: -2.213,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -2,
  				y2: -1.08,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: -3.162,
  				y2: -0.024,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "i",
  				x2: -3.294,
  				y2: -0.549
  			}
  		],
  		text: {
  			x: -2.548,
  			y: -1.029
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			2,
  			3
  		],
  		x1: 0.983,
  		y1: 2.049,
  		arcs: [
  			{
  				ref: 3,
  				mode: "i",
  				x2: 0.257,
  				y2: 2.922,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: -1,
  				y2: 3,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: -1.645,
  				y2: 1.568,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "o",
  				x2: 0.983,
  				y2: 2.049
  			}
  		],
  		text: {
  			x: -0.407,
  			y: 2.31
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			2,
  			4
  		],
  		x1: 2.253,
  		y1: -0.302,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: 2.858,
  				y2: 0.659,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: 2.544,
  				y2: 1.878,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "i",
  				x2: 0.983,
  				y2: 2.049,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "o",
  				x2: 2.253,
  				y2: -0.302
  			}
  		],
  		text: {
  			x: 2.071,
  			y: 1.101
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			3,
  			4
  		],
  		x1: 1.51,
  		y1: -2.515,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: 2.572,
  				y2: -1.839,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "i",
  				x2: 2.253,
  				y2: -0.302,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "o",
  				x2: 0.409,
  				y2: -2.236,
  				sweep: false,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: 1.51,
  				y2: -2.515,
  				sweep: true
  			}
  		],
  		text: {
  			x: 1.687,
  			y: -1.63
  		}
  	},
  	{
  		sets: [
  			0,
  			2,
  			3,
  			4
  		],
  		x1: -2,
  		y1: -1.08,
  		arcs: [
  			{
  				ref: 0,
  				mode: "i",
  				x2: -1.925,
  				y2: -2.213,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "i",
  				x2: -0.954,
  				y2: -3.015,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "i",
  				x2: 0.409,
  				y2: -2.236,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "o",
  				x2: -2,
  				y2: -1.08
  			}
  		],
  		text: {
  			x: -1.028,
  			y: -2.108
  		}
  	},
  	{
  		sets: [
  			1,
  			2,
  			3,
  			4
  		],
  		x1: -1.645,
  		y1: 1.568,
  		arcs: [
  			{
  				ref: 4,
  				mode: "i",
  				x2: -2.7,
  				y2: 1.147,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 2,
  				mode: "i",
  				x2: -3.162,
  				y2: -0.024,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: -2,
  				y2: -1.08,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "o",
  				x2: -1.645,
  				y2: 1.568
  			}
  		],
  		text: {
  			x: -2.323,
  			y: 0.327
  		}
  	},
  	{
  		sets: [
  			0,
  			1,
  			2,
  			3,
  			4
  		],
  		x1: 0.409,
  		y1: -2.236,
  		arcs: [
  			{
  				ref: 2,
  				mode: "i",
  				x2: 2.253,
  				y2: -0.302,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 3,
  				mode: "i",
  				x2: 0.983,
  				y2: 2.049,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 4,
  				mode: "i",
  				x2: -1.645,
  				y2: 1.568,
  				sweep: true,
  				large: false
  			},
  			{
  				ref: 0,
  				mode: "i",
  				x2: -2,
  				y2: -1.08,
  				sweep: true
  			},
  			{
  				ref: 1,
  				mode: "i",
  				x2: 0.409,
  				y2: -2.236,
  				sweep: true
  			}
  		],
  		text: {
  			x: 0,
  			y: 0
  		}
  	}
  ];
  var bb = {
  	x: -5.5,
  	y: -6,
  	width: 11.6,
  	height: 11.8
  };
  var venn5 = {
  	sets: sets,
  	intersections: intersections,
  	bb: bb
  };

  // Static shapes for rendering
  const shapes = [venn0, venn1, venn2, venn3, venn4, venn5];
  /**
   * Sort helper.
   * Reference: https://stackoverflow.com/a/64449554/1288340
   */
  const upto = (limit) => Array.from({ length: limit }, (_, i) => i);
  /**
   * Detect ellipse.
   * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4
   */
  function isEllipse(d) {
      return typeof d.rx === 'number';
  }
  /**
   * Generate all combinations of a given array.
   * Reference: https://stackoverflow.com/questions/5752002/find-all-possible-subset-combos-in-an-array
   */
  function combinations(array) {
      return new Array(1 << array.length)
          .fill()
          .map((_e1, i) => array.filter((_e2, j) => i & (1 << j)));
  }
  /**
   * Given a array set, lookup the data.
   */
  function lookup(combo, data) {
      const key = combo.join('|');
      const found = data.find((d) => d.key === key);
      return {
          key,
          sets: combo,
          size: (found === null || found === void 0 ? void 0 : found.size) || 0
      };
  }
  /**
   * Build the data combinations for the layout.
   */
  function buildData(data) {
      // Collect all unique sets and sort by size
      const uniqueSets = data
          .filter((d) => d.sets.length === 1)
          .sort((a, b) => b.size - a.size);
      // Map our unique sets
      const uniqueSetKeys = uniqueSets.map((u) => u.key);
      // Build all combos and return 1+ combos
      const sets = combinations(uniqueSetKeys);
      const filteredSets = sets.slice(1, sets.length);
      // Sort the child sets based on the parent
      const result = filteredSets.map((d) => [...d].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b)));
      // Sort the data based on index of keys and length
      // Reference: https://stackoverflow.com/a/64449554/1288340
      result.sort((a, b) => a.length - b.length ||
          upto(a.length).reduce((diff, i) => diff || uniqueSetKeys.indexOf(a[i]) - uniqueSetKeys.indexOf(b[i]), 0));
      // reshape the data key so they will match combos
      const keyedData = data.map((d) => {
          const sets = [...d.sets].sort((a, b) => uniqueSetKeys.indexOf(a) - uniqueSetKeys.indexOf(b));
          const key = sets.join('|');
          return {
              size: d.size,
              sets,
              key
          };
      });
      return {
          uniqueCount: uniqueSets.length,
          data: result.map((r) => lookup(r, keyedData))
      };
  }
  /**
   * Generate the arc slice path.
   * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4
   */
  function generateArcSlicePath(s, refs) {
      return `M ${s.x1},${s.y1} ${s.arcs
        .map((arc) => {
        const ref = refs[arc.ref];
        const rx = isEllipse(ref) ? ref.rx : ref.r;
        const ry = isEllipse(ref) ? ref.ry : ref.r;
        const rot = isEllipse(ref) ? ref.rotation : 0;
        return `A ${rx} ${ry} ${rot} ${arc.large ? 1 : 0} ${arc.sweep ? 1 : 0} ${arc.x2} ${arc.y2}`;
    })
        .join(' ')}`;
  }
  /**
   * Build the layout for the given chart.
   * Reference: https://github.com/upsetjs/chartjs-chart-venn/blob/master/src/model/generate.ts#L4
   */
  function buildLayout({ data, uniqueCount }, box) {
      const shape = shapes[Math.min(shapes.length - 1, uniqueCount)];
      const f = Math.min(box.width / shape.bb.width, box.height / shape.bb.height);
      const x = f * -shape.bb.x + (box.width - f * shape.bb.width) / 2 + 0;
      const y = f * -shape.bb.y + (box.height - f * shape.bb.height) / 2 + 0;
      const mx = (v) => x + f * v;
      const my = (v) => y + f * v;
      const shapeSets = shape.sets.map((c, i) => (Object.assign(Object.assign(Object.assign({}, c), Object.assign({ data: data[i], cx: mx(c.cx), cy: my(c.cy), text: {
              x: mx(c.text.x),
              y: my(c.text.y)
          } }, (c.icon
          ? {
              icon: {
                  x: mx(c.icon.x),
                  y: my(c.icon.y)
              }
          }
          : {}))), (isEllipse(c)
          ? {
              rx: c.rx * f,
              ry: c.ry * f
          }
          : {
              r: c.r * f
          }))));
      const intersections = shape.intersections.map((c, i) => ({
          text: {
              x: mx(c.text.x),
              y: my(c.text.y)
          },
          x1: mx(c.x1),
          y1: my(c.y1),
          data: data[i],
          set: shapeSets[i],
          arcs: c.arcs.map((a) => (Object.assign(Object.assign({}, a), { x2: mx(a.x2), y2: my(a.y2) })))
      }));
      return intersections.map((i) => (Object.assign(Object.assign({}, i), { path: generateArcSlicePath(i, shapeSets) })));
  }
  /**
   * Generate the star euler layout.
   * Adapted from: https://github.com/upsetjs/chartjs-chart-venn
   */
  function starEulerLayout(data, bb) {
      return buildLayout(buildData(data), bb);
  }

  const VennDiagram = ({ id, type = 'venn', width, height, margins, className, data, disabled, series = React__default['default'].createElement(VennSeries, null) }) => {
      const renderChart = React.useCallback((containerProps) => {
          const normalized = data.map((d) => ({
              key: d.key.join('|'),
              sets: d.key,
              size: d.data
          }));
          let layoutData;
          if (type === 'starEuler') {
              layoutData = starEulerLayout(normalized, {
                  height: containerProps.height,
                  width: containerProps.width
              });
          }
          else {
              layoutData = venn_js.layout(normalized, {
                  height: containerProps.height,
                  width: containerProps.width,
                  distinct: type !== 'euler'
              });
          }
          return (React__default['default'].createElement(rdk.CloneElement, { element: series, data: layoutData, disabled: disabled, id: containerProps.id }));
      }, [data, series, type]);
      return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, center: false, className: className }, renderChart));
  };

  const Bubble = ({ id, data, fill, mask, gradient, onClick, onMouseEnter, onMouseLeave, tooltip = React__default['default'].createElement(ChartTooltip, null) }) => {
      const [internalActive, setInternalActive] = React.useState(false);
      const bubbleRef = React.useRef(null);
      const arcFill = gradient && !mask
          ? `url(#gradient-${id})`
          : mask
              ? `url(#mask-pattern-${id})`
              : fill;
      return (React__default['default'].createElement(React.Fragment, null,
          React__default['default'].createElement(framerMotion.motion.circle, { id: `${id}-bubble`, ref: bubbleRef, fill: arcFill, initial: {
                  r: data.r,
                  cx: data.x,
                  cy: data.y
              }, animate: {
                  r: data.r,
                  cx: data.x,
                  cy: data.y
              }, onClick: onClick, onMouseEnter: event => {
                  setInternalActive(true);
                  onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(event);
              }, onMouseLeave: event => {
                  setInternalActive(false);
                  onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(event);
              } }),
          mask && (React__default['default'].createElement(React.Fragment, null,
              React__default['default'].createElement(Mask, { id: `mask-${id}`, fill: `url(#gradient-${id})` }),
              React__default['default'].createElement(rdk.CloneElement, { element: mask, id: `mask-pattern-${id}`, fill: fill }))),
          gradient && (React__default['default'].createElement(rdk.CloneElement, { element: gradient, id: `gradient-${id}`, color: fill })),
          tooltip && !tooltip.props.disabled && (React__default['default'].createElement(rdk.CloneElement, { element: tooltip, visible: !!internalActive, reference: bubbleRef, value: { y: data.data.data, x: data.data.key } }))));
  };

  const BubbleLabel = ({ id, data, wrap = true, fill = '#000', fontSize = 14, fontFamily = 'sans-serif' }) => {
      const text = wrap ? wrapText({
          key: data.data.key,
          fontFamily,
          fontSize,
          width: data.r
      }) : data.data.key;
      return (React__default['default'].createElement(framerMotion.motion.text, { initial: {
              x: data.x,
              y: data.y
          }, animate: {
              x: data.x,
              y: data.y
          }, id: `${id}-text`, style: { pointerEvents: 'none', fontFamily, fontSize }, fill: fill, textAnchor: "middle" }, text));
  };

  const BubbleSeries = ({ id, data, colorScheme = 'cybertron', animated = true, bubble = React__default['default'].createElement(Bubble, null), label = React__default['default'].createElement(BubbleLabel, null) }) => {
      const transition = animated ? {} : { type: false, delay: 0 };
      const renderBubble = (item, index) => {
          const fill = getColor({
              data,
              colorScheme,
              point: item.data,
              index
          });
          return (React__default['default'].createElement(framerMotion.motion.g, { key: item.data.key, initial: {
                  scale: .5,
                  opacity: 0
              }, animate: {
                  scale: 1,
                  opacity: 1
              }, transition: transition },
              React__default['default'].createElement(rdk.CloneElement, { element: bubble, id: `${id}-bubble`, animated: animated, data: item, fill: fill }),
              React__default['default'].createElement(rdk.CloneElement, { element: label, id: `${id}-label`, animated: animated, data: item })));
      };
      return (React__default['default'].createElement(React.Fragment, null, data.map(renderBubble)));
  };

  const BubbleChart = ({ data = [], id, width, height, className, margins = 10, series = React__default['default'].createElement(BubbleSeries, null) }) => {
      const getData = React.useCallback((cw, ch) => {
          const bubble = d3Hierarchy.pack()
              .size([cw, ch])
              .padding(3);
          const root = d3Hierarchy.hierarchy({ children: data })
              .sum(d => d.data)
              .sort((a, b) => b.data - a.data);
          return bubble(root).leaves();
      }, [data]);
      const renderChart = React.useCallback((_a) => {
          var { chartWidth, chartHeight } = _a, rest = __rest(_a, ["chartWidth", "chartHeight"]);
          const circles = getData(chartWidth, chartHeight);
          return (React__default['default'].createElement(rdk.CloneElement, { element: series, id: `${rest.id}-series`, data: circles }));
      }, [series, getData, id]);
      return (React__default['default'].createElement(ChartContainer, { id: id, width: width, height: height, margins: margins, xAxisVisible: false, yAxisVisible: false, className: className }, renderChart));
  };

  exports.Area = Area;
  exports.AreaChart = AreaChart;
  exports.AreaSeries = AreaSeries;
  exports.AreaSparklineChart = AreaSparklineChart;
  exports.Bar = Bar;
  exports.BarChart = BarChart;
  exports.BarLabel = BarLabel;
  exports.BarSeries = BarSeries;
  exports.BarSparklineChart = BarSparklineChart;
  exports.Brush = Brush;
  exports.BrushSlice = BrushSlice;
  exports.Bubble = Bubble;
  exports.BubbleChart = BubbleChart;
  exports.BubbleLabel = BubbleLabel;
  exports.BubbleSeries = BubbleSeries;
  exports.CalendarHeatmap = CalendarHeatmap;
  exports.ChartBrush = ChartBrush;
  exports.ChartContainer = ChartContainer;
  exports.ChartTooltip = ChartTooltip;
  exports.ChartZoomPan = ChartZoomPan;
  exports.DEFAULT_TRANSITION = DEFAULT_TRANSITION;
  exports.DiscreteLegend = DiscreteLegend;
  exports.DiscreteLegendEntry = DiscreteLegendEntry;
  exports.DiscreteLegendSymbol = DiscreteLegendSymbol;
  exports.Gradient = Gradient;
  exports.GradientStop = GradientStop;
  exports.GridStripe = GridStripe;
  exports.Gridline = Gridline;
  exports.GridlineSeries = GridlineSeries;
  exports.GuideBar = GuideBar;
  exports.Heatmap = Heatmap;
  exports.HeatmapCell = HeatmapCell;
  exports.HeatmapSeries = HeatmapSeries;
  exports.HistogramBarChart = HistogramBarChart;
  exports.HistogramBarSeries = HistogramBarSeries;
  exports.HivePlot = HivePlot;
  exports.Line = Line;
  exports.LineChart = LineChart;
  exports.LineSeries = LineSeries;
  exports.LinearAxis = LinearAxis;
  exports.LinearAxisLine = LinearAxisLine;
  exports.LinearAxisTickLabel = LinearAxisTickLabel;
  exports.LinearAxisTickLine = LinearAxisTickLine;
  exports.LinearAxisTickSeries = LinearAxisTickSeries;
  exports.LinearGauge = LinearGauge;
  exports.LinearGaugeBar = LinearGaugeBar;
  exports.LinearGaugeOuterBar = LinearGaugeOuterBar;
  exports.LinearGaugeSeries = LinearGaugeSeries;
  exports.LinearXAxis = LinearXAxis;
  exports.LinearXAxisTickLabel = LinearXAxisTickLabel;
  exports.LinearXAxisTickLine = LinearXAxisTickLine;
  exports.LinearXAxisTickSeries = LinearXAxisTickSeries;
  exports.LinearYAxis = LinearYAxis;
  exports.LinearYAxisTickLabel = LinearYAxisTickLabel;
  exports.LinearYAxisTickLine = LinearYAxisTickLine;
  exports.LinearYAxisTickSeries = LinearYAxisTickSeries;
  exports.Map = Map$1;
  exports.MapMarker = MapMarker;
  exports.MarimekkoBarSeries = MarimekkoBarSeries;
  exports.MarimekkoChart = MarimekkoChart;
  exports.MarkLine = MarkLine;
  exports.Mask = Mask;
  exports.MotionPath = MotionPath;
  exports.Move = Move;
  exports.Pan = Pan;
  exports.PieArc = PieArc;
  exports.PieArcLabel = PieArcLabel;
  exports.PieArcSeries = PieArcSeries;
  exports.PieChart = PieChart;
  exports.PointSeries = PointSeries;
  exports.RadialArea = RadialArea;
  exports.RadialAreaChart = RadialAreaChart;
  exports.RadialAreaSeries = RadialAreaSeries;
  exports.RadialAxis = RadialAxis;
  exports.RadialAxisArc = RadialAxisArc;
  exports.RadialAxisArcSeries = RadialAxisArcSeries;
  exports.RadialAxisTick = RadialAxisTick;
  exports.RadialAxisTickLabel = RadialAxisTickLabel;
  exports.RadialAxisTickLine = RadialAxisTickLine;
  exports.RadialAxisTickSeries = RadialAxisTickSeries;
  exports.RadialBar = RadialBar;
  exports.RadialBarChart = RadialBarChart;
  exports.RadialBarSeries = RadialBarSeries;
  exports.RadialGauge = RadialGauge;
  exports.RadialGaugeArc = RadialGaugeArc;
  exports.RadialGaugeLabel = RadialGaugeLabel;
  exports.RadialGaugeSeries = RadialGaugeSeries;
  exports.RadialGaugeValueLabel = RadialGaugeValueLabel;
  exports.RadialGradient = RadialGradient;
  exports.RadialGuideBar = RadialGuideBar;
  exports.RadialLine = RadialLine;
  exports.RadialPointSeries = RadialPointSeries;
  exports.RadialScatterPlot = RadialScatterPlot;
  exports.RadialScatterPoint = RadialScatterPoint;
  exports.RadialScatterSeries = RadialScatterSeries;
  exports.RangeLines = RangeLines;
  exports.Sankey = Sankey;
  exports.SankeyLabel = SankeyLabel;
  exports.SankeyLink = SankeyLink;
  exports.SankeyNode = SankeyNode;
  exports.ScatterPlot = ScatterPlot;
  exports.ScatterPoint = ScatterPoint;
  exports.ScatterSeries = ScatterSeries;
  exports.SequentialLegend = SequentialLegend;
  exports.SonarChart = SonarChart;
  exports.SparklineChart = SparklineChart;
  exports.StackedAreaChart = StackedAreaChart;
  exports.StackedAreaSeries = StackedAreaSeries;
  exports.StackedBarChart = StackedBarChart;
  exports.StackedBarSeries = StackedBarSeries;
  exports.StackedNormalizedAreaChart = StackedNormalizedAreaChart;
  exports.StackedNormalizedAreaSeries = StackedNormalizedAreaSeries;
  exports.StackedNormalizedBarChart = StackedNormalizedBarChart;
  exports.StackedNormalizedBarSeries = StackedNormalizedBarSeries;
  exports.StackedRadialGaugeLabel = StackedRadialGaugeLabel;
  exports.StackedRadialGaugeSeries = StackedRadialGaugeSeries;
  exports.Stripes = Stripes;
  exports.TooltipArea = TooltipArea;
  exports.TooltipTemplate = TooltipTemplate;
  exports.VennArc = VennArc;
  exports.VennDiagram = VennDiagram;
  exports.VennLabel = VennLabel;
  exports.VennOuterLabel = VennOuterLabel;
  exports.VennSeries = VennSeries;
  exports.Zoom = Zoom;
  exports.ZoomPan = ZoomPan;
  exports.addWeeksToDate = addWeeksToDate;
  exports.bigIntegerToLocaleString = bigIntegerToLocaleString;
  exports.buildBarStackData = buildBarStackData;
  exports.buildBins = buildBins;
  exports.buildDataScales = buildDataScales;
  exports.buildMarimekkoData = buildMarimekkoData;
  exports.buildNestedChartData = buildNestedChartData;
  exports.buildShallowChartData = buildShallowChartData;
  exports.buildStackData = buildStackData;
  exports.buildWaterfall = buildWaterfall;
  exports.calculateDimensions = calculateDimensions;
  exports.calculateShowStroke = calculateShowStroke;
  exports.constrainMatrix = constrainMatrix;
  exports.constructFunctionProps = constructFunctionProps;
  exports.extent = extent;
  exports.formatValue = formatValue;
  exports.functionProps = functionProps;
  exports.getClosestPoint = getClosestPoint;
  exports.getColor = getColor;
  exports.getDegrees = getDegrees;
  exports.getDimension = getDimension;
  exports.getDurationTicks = getDurationTicks;
  exports.getLimitMatrix = getLimitMatrix;
  exports.getMaxBigIntegerForNested = getMaxBigIntegerForNested;
  exports.getMaxBigIntegerForShallow = getMaxBigIntegerForShallow;
  exports.getMaxTicks = getMaxTicks;
  exports.getParentSVG = getParentSVG;
  exports.getPointFromMatrix = getPointFromMatrix;
  exports.getPositionForTarget = getPositionForTarget;
  exports.getTicks = getTicks;
  exports.getXDomain = getXDomain;
  exports.getYDomain = getYDomain;
  exports.humanFormatBigInteger = humanFormatBigInteger;
  exports.interpolate = interpolate;
  exports.isAxisVisible = isAxisVisible;
  exports.isZoomLevelGoingOutOfBounds = isZoomLevelGoingOutOfBounds;
  exports.normalizeValue = normalizeValue;
  exports.normalizeValueForFormatting = normalizeValueForFormatting;
  exports.reduceTicks = reduceTicks;
  exports.schemes = schemes;
  exports.toggleTextSelection = toggleTextSelection;
  exports.uniqueBy = uniqueBy;
  exports.weekDays = weekDays;
  exports.wrapText = wrapText;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
